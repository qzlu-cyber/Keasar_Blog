<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://keasar.com.cn</id>
    <title>Keasar`Blog</title>
    <updated>2020-08-23T13:08:31.366Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://keasar.com.cn"/>
    <link rel="self" href="https://keasar.com.cn/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://keasar.com.cn/images/avatar.png</logo>
    <icon>https://keasar.com.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, Keasar`Blog</rights>
    <entry>
        <title type="html"><![CDATA[React 进阶 -- 高阶组件 HOC]]></title>
        <id>https://keasar.com.cn/post/react-jin-jie-gao-jie-zu-jian-hoc/</id>
        <link href="https://keasar.com.cn/post/react-jin-jie-gao-jie-zu-jian-hoc/">
        </link>
        <updated>2020-08-23T13:05:14.000Z</updated>
        <summary type="html"><![CDATA[<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧，是一种基于 React 的组合特性而形成的设计模式。</p>
<p><strong>高阶组件是参数为组件，返回值为新组件的函数</strong>。组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
]]></summary>
        <content type="html"><![CDATA[<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧，是一种基于 React 的组合特性而形成的设计模式。</p>
<p><strong>高阶组件是参数为组件，返回值为新组件的函数</strong>。组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
<!-- more -->
<h4 id="使用">使用</h4>
<pre><code class="language-jsx">const EnhancedComponent = higherOrderComponent(WrappedComponent);
</code></pre>
<p>以下代码及组件基于<a href="https://react.docschina.org/docs/higher-order-components.html">官方文档例子</a>补充并扩展：</p>
<p><code>DataSource数据源</code>：</p>
<pre><code class="language-js">let comments = [{
    id: 0,
    msg: &quot;Hello&quot;
  },
  {
    id: 1,
    msg: &quot;Hello1&quot;
  },
  {
    id: 2,
    msg: &quot;Hello2&quot;
  },
];

let blogPosts = [{
    id: 0,
    msg: &quot;文章1&quot;
  },
  {
    id: 1,
    msg: &quot;文章2&quot;
  },
  {
    id: 2,
    msg: &quot;文章3&quot;
  },
];

let listeners = []; // 存放所有监听事件

const DataSource = {
  getComments() { // 获取评论
    return comments;
  },
  getBlogPosts() { // 获取所有文章
    return blogPosts;
  },
  getBlogPost(id) { // 根据 id 获取文章
    return blogPosts.find(function (blog) {
      return blog.id === id;
    })
  },
  addBlogPost(blog) { // 发布文章
    blogPosts.push(blog);
    DataSource.broadCast(); // 数据源更新，调用 broadCast 函数执行
  },
  updateBlogPost(blog) { // 更新文章
    let hasUpdate = false;
    for (let i = 0; i &lt; blogPosts.length; i++) {
      const curBlog = blogPosts[i];
      if (blog.id === curBlog.id) {
        blogPosts[i] = Object.assign({}, curBlog, blog);
        hasUpdate = true;
      }
    }

    if (hasUpdate) {
      DataSource.broadCast(); // 数据源更新，调用 broadCast 函数执行
    }
  },
  addComment(comment) { // 添加评论
    comments.push(comment);
    DataSource.broadCast(); // 数据源更新，调用 broadCast 函数执行
  },
  addChangeListener(hander) {
    listeners.push(hander); // 添加监听，向 listeners 数组中添加需要执行的函数
  },
  removeChangeListener(hander) { // 移除监听
    let listenersNew = [];
    for (let i = 0; i &lt; listeners.length; i++) {
      if (listeners[i] !== hander) {
        listenersNew.push(listeners[i]);
      }
    }
    listeners = listenersNew; // 移除后覆盖
  },
  broadCast() {
    listeners.map(listener =&gt; listener()); // 遍历 listeners 并执行其中的每个监听函数
  }
}

export default DataSource;
</code></pre>
<p><code>CommentList</code> 组件，它订阅外部数据源，用以渲染评论列表：</p>
<pre><code class="language-jsx">class Comment extends Component {
  render() {
    return &lt;div&gt;{this.props.comment.msg}&lt;/div&gt;;
  }
}

class CommentList extends Component {
  constructor(props) {
    super(props);
    this.state = {
      comments: DataSource.getComments(),
    };
  }

  componentDidMount() {
    // 订阅更改
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // 清除订阅
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange = () =&gt; {
    // 当数据源更新时，更新组件状态
    this.setState({
      comments: DataSource.getComments(),
    });
  };

  handleAddNewComment = () =&gt; {
    const id = Date.now();
    DataSource.addComment({ id: id, msg: &quot;新评论&quot; + id });
  };

  render() {
    return (
      &lt;div&gt;
        {this.state.comments.map((comment) =&gt; (
          &lt;Comment comment={comment} key={comment.id} /&gt;
        ))}
        &lt;button onClick={this.handleAddNewComment}&gt;添加新评论&lt;/button&gt; {/*点击按钮添加新评论*/}
      &lt;/div&gt;
    );
  }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/08/23/d04CW9.png" alt="添加新评论" loading="lazy"></figure>
<p><code>BlogList</code> 组件用于订阅单个博客帖子：</p>
<pre><code class="language-jsx">class BlogPost extends Component {
  constructor(props) {
    super(props);
    this.state = {
      blogPost: DataSource.getBlogPost(this.props.id),
    };
  }

  componentDidMount() {
    // 订阅更改
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // 清除订阅
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange = () =&gt; {
    // 当数据源更新时，更新组件状态
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id),
    });
  };

  handleChangeBlog = () =&gt; {
    const id = Date.now();
    const newBlog = Object.assign({}, this.state.blogPost, {
      msg: &quot;修改后的文章&quot; + id,
    });
    DataSource.updateBlogPost(newBlog);
  };

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;{this.state.blogPost.msg}&lt;/div&gt;
        &lt;button onClick={this.handleChangeBlog}&gt;修改文章&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>对比 <code>CommentList</code> 和 <code>BlogPost</code> 组件我们可以发现：虽然它们在 <code>DataSource</code> 上调用不同的方法，且渲染不同的结果，但它们的大部分实现都是一样的：</p>
<ul>
<li>在挂载时，向 <code>DataSource</code> 添加一个更改侦听器。</li>
<li>在侦听器内部，当数据源发生变化时，调用 <code>setState</code>。</li>
<li>在卸载时，删除侦听器。</li>
</ul>
<p>所以，当我们的应用很大时，订阅和调用将会发生很多次，高阶组件正是解决了这个问题。它允许我们在一个地方定义这个逻辑，并在许多组件之间共享它。</p>
<p>对于订阅了 <code>DataSource</code> 的组件，比如 <code>CommentList</code> 和 <code>BlogPost</code>，我们可以编写一个创建组件函数。该函数将接受一个子组件作为它的其中一个参数，该子组件将订阅数据作为 <code>prop</code>。让我们调用函数 <code>withSubscription</code>：</p>
<pre><code class="language-jsx">const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) =&gt; DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) =&gt; DataSource.getBlogPost(props.id)
);
// withSubscription 第一个参数是被包装组件。第二个参数通过 DataSource 和当前的 props 返回我们需要的数据。
</code></pre>
<p>需要接收返回数据的通过 <code>props</code> 传递：</p>
<pre><code class="language-jsx">/*
    //BlogPost里的 
    state = {
        blogPost: DataSource.getBlogPost(props.id)
    }
    //使用高阶组件
    withSubscription(BlogPost, (DataSource,props) =&gt; DataSource.getBlogPost(props.id))
*/

function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        data: selectData(DataSource, props),
      };
    }

    componentDidMount() {
      // ...负责订阅相关的操作...
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange = () =&gt; {
      this.setState({
        data: selectData(DataSource, this.props),
      });
    };

    render() {
      return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;;
    }
  };
}
</code></pre>
<p>完成了抽离后，我们就可以在多个不同的地方复用它：</p>
<pre><code class="language-jsx">// 修改后的 CommentList 组件
class CommentList extends Component {
  handleAddNewComment = () =&gt; {
    const id = Date.now();
    DataSource.addComment({ id: id, msg: &quot;新评论&quot; + id });
  };

  render() {
    return (
      &lt;div&gt;
        {this.props.data.map((comment) =&gt; (
          &lt;Comment comment={comment} key={comment.id} /&gt;
        ))}
        &lt;button onClick={this.handleAddNewComment}&gt;添加新评论&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default withSubscription(CommentList, (DataSource) =&gt;
  DataSource.getComments()
);

// 修改后的 BlogPost 组件
class BlogPost extends Component {
  constructor(props) {
    super(props);
    this.state = {
      data: this.props.data,
    };
  }

  handleChangeBlog = () =&gt; {
    const id = Date.now();
    const newBlog = Object.assign({}, this.props.data, {
      msg: &quot;修改后的文章&quot; + id,
    });
    DataSource.updateBlogPost(newBlog);
  };

  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;{this.props.data.msg}&lt;/div&gt;
        &lt;button onClick={this.handleChangeBlog}&gt;修改文章&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default withSubscription(BlogPost, (DataSource, props) =&gt;
  DataSource.getBlogPost(props.id)
);

// App.js
function App() {
  return (
    &lt;div className='App'&gt;
      &lt;CommentList /&gt;
      &lt;BlogPost id={0} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/08/23/d0o46s.png" alt="最终效果" loading="lazy"></figure>
<p>HOC 可以只接收被包裹的组件也可接收多个参数，例如 Redux 中的 <code>connect</code> 函数：</p>
<pre><code class="language-jsx">connect(mapStateToProps, mapDispatchToProps)(Component);
</code></pre>
<p>不难看出 <code>connect</code> 是一个返回高阶组件的高阶组件，它采用了类似下面的写法：</p>
<pre><code class="language-jsx">function connect(mapStateToProps, mapDispatchToProps){
    return function(Component){
        return class extends React.Component {}
    }
}
</code></pre>
<h4 id="注意">注意</h4>
<ol>
<li>
<p>不要在 render 方法中使用 HOC</p>
<p>React 的 <code>diff</code> 算法（称为协调）使用组件标识来确定它是应该更新现有子树还是将其丢弃并挂载新子树。 如果从 <code>render</code> 返回的组件与前一个渲染中的组件相同（<code>===</code>），则 React 通过将子树与新子树进行区分来递归更新子树。 如果它们不相等，则完全卸载前一个子树。</p>
<pre><code class="language-jsx">render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent，既损失性能又会导致该组件及其所有子组件的状态丢失
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return &lt;EnhancedComponent /&gt;;
}
</code></pre>
</li>
<li>
<p>复制静态方法</p>
<p>当 React 组件上有静态方法，使用 HOC 包装后，新组件无法拥有原始组件的任何静态方法：</p>
<pre><code class="language-jsx">// 定义静态函数
WrappedComponent.staticMethod = function() {/*...*/}
// 现在使用 HOC
const EnhancedComponent = enhance(WrappedComponent);

// 增强组件没有 staticMethod
typeof EnhancedComponent.staticMethod === 'undefined' // true
</code></pre>
<p>可以使用下面的方法解决：</p>
<pre><code class="language-jsx">// 1.返回之前把这些方法拷贝到容器组件上
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // 必须准确知道应该拷贝哪些方法
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}

// 2. 使用 hoist-non-react-statics 自动拷贝所有非 React 静态方法
import hoistNonReactStatic from 'hoist-non-react-statics';
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  hoistNonReactStatic(Enhance, WrappedComponent);
  return Enhance;
}
</code></pre>
</li>
<li>
<p>Refs 无法被传递</p>
<p>如果将 <code>ref</code> 添加到 HOC 的返回组件中，则 <code>ref</code> 引用指向容器组件，而不是被包装组件。可以通过 <code>React.forwardRef</code> API 解决该问题。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript -- this 关键字]]></title>
        <id>https://keasar.com.cn/post/javascript-this-guan-jian-zi/</id>
        <link href="https://keasar.com.cn/post/javascript-this-guan-jian-zi/">
        </link>
        <updated>2020-08-23T04:50:51.000Z</updated>
        <summary type="html"><![CDATA[<p>面向对象语言中 <code>this</code> 表示当前对象的一个引用。但在 JavaScript 中 <code>this</code> 不是固定不变的，它会随着执行环境的改变而改变。</p>
]]></summary>
        <content type="html"><![CDATA[<p>面向对象语言中 <code>this</code> 表示当前对象的一个引用。但在 JavaScript 中 <code>this</code> 不是固定不变的，它会随着执行环境的改变而改变。</p>
<!-- more -->
<h4 id="每一个函数内部都有一个关键字this-并且this-可供直接调用">每一个函数内部都有一个关键字<code>this</code> ，并且<code>this</code> 可供直接调用</h4>
<h4 id="函数内部的-this-只和函数的调用方式有关系和函数的定义方式没有关系"><strong>函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系</strong></h4>
<ul>
<li>
<p>全局定义的函数直接调用，<code>this =&gt; window</code></p>
<pre><code class="language-js">function fn() {
  console.log(this);
}
fn();
// 此时 this 指向 window
</code></pre>
</li>
<li>
<p>对象内部的方法调用，<code>this =&gt; 调用者</code></p>
<pre><code class="language-js">const obj = {
  fn: function () {
    console.log(this);
  }
}
obj.fn();
// 此时 this 指向 obj
</code></pre>
</li>
</ul>
<ul>
<li>
<p>定时器的处理函数，<code>this =&gt; window</code></p>
<pre><code class="language-javascript">setTimeout(function () {
  console.log(this)
}, 0)
// 此时定时器处理函数里面的 this 指向 window
</code></pre>
</li>
<li>
<p>事件处理函数，<code>this =&gt; 事件源</code></p>
<pre><code class="language-javascript">div.onclick = function () {
  console.log(this)
}
// 当你点击 div 的时候，this 指向 div
</code></pre>
</li>
<li>
<p>自调用函数，<code>this =&gt; window</code></p>
<pre><code class="language-javascript">(function () {
  console.log(this)
})()
// 此时 this 指向 window
</code></pre>
</li>
</ul>
<ul>
<li>
<p>箭头函数，箭头函数内部没有 <code>this</code>，箭头函数的 <code>this</code> 是<code>上下文的 this</code></p>
<pre><code class="language-js">// 在箭头函数定义的位置往上查找，这一行是可以打印出 this 的
// 因为这里的 this 是 window
// 所以箭头函数内部的 this 就是 window
const obj = {
  fn: function () {
    console.log(this)
  },
  // 这个位置是箭头函数的上一行，但是不能打印出 this
  fun: () =&gt; {
    // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置
    console.log(this)
  }
}

obj.fn()
obj.fun()
</code></pre>
</li>
</ul>
<h4 id="显式函数绑定"><strong>显式函数绑定</strong></h4>
<p>在 JavaScript 中函数也是对象，对象则有方法，<code>apply</code> 和 <code>call</code> 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 <code>this</code> 绑定的对象。</p>
<ul>
<li>
<p><code>apply</code></p>
<ul>
<li><code>apply</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 <code>this</code> 指向</li>
<li>语法： <code>函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])</code></li>
</ul>
<pre><code class="language-js">const obj = { name: 'Jack' };
function fn(a, b) {
  console.log(this);
  console.log(a);
  console.log(b);
}
fn(1, 2); // this =&gt; window
fn.call(obj, [1, 2]); // this =&gt; obj
</code></pre>
<ul>
<li>使用 <code>apply</code> :
<ul>
<li>会立即执行函数</li>
<li>第一个参数是你要改变的函数内部的 <code>this</code> 指向</li>
<li>第二个参数是一个 <strong>数组</strong>，数组里面的每一项依次是向函数传递的参数</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>call</code></p>
<ul>
<li><code>call</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 <code>this</code> 指向</li>
<li>语法： <code>函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)</code></li>
</ul>
<pre><code class="language-js">const obj = { name: 'Jack' };
function fn(a, b) {
  console.log(this);
  console.log(a);
  console.log(b);
}
fn(1, 2); // this =&gt; window
fn.call(obj, 1, 2); // this =&gt; obj
</code></pre>
<ul>
<li>使用 <code>call</code>:
<ul>
<li>会立即执行函数</li>
<li>第一个参数是你要改变的函数内部的 <code>this</code> 指向</li>
<li>第二个参数开始，依次是向函数传递参数</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>bind</code></p>
<ul>
<li><code>bind</code> 方法是附加在函数调用后面使用，可以忽略函数本身的 <code>this</code> 指向</li>
<li>和 <code>call / apply</code> 有一些不一样，它不会立即执行函数，而是返回一个已经改变了 <code>this</code> 指向的函数</li>
<li>语法： <code>const newFn = 函数名.bind(要改变的 this 指向); newFn(传递参数)</code></li>
</ul>
<pre><code class="language-js">const obj = { name: 'Jack' };
function fn(a, b) {
  console.log(this);
  console.log(a);
  console.log(b);
}
fn(1, 2);
const newFn = fn.bind(obj); // 改变了 this 指向
newFn(1, 2); // 执行结果一致，但是 this =&gt; obj
</code></pre>
</li>
</ul>
<h4 id="总结">总结</h4>
<ul>
<li><code>this</code> 是作用域内部使用的关键字</li>
<li><code>this</code> 指向不看函数定义，只和调用方式有关
<ul>
<li>全局调用 <code>fn() this =&gt; window</code></li>
<li>对象调用 <code>obj. fn() this =&gt; obj</code></li>
<li>定时器函数 <code>this =&gt; window</code></li>
<li>事件处理函数 <code>this =&gt; 事件源</code></li>
<li>自执行函数 <code>this =&gt; window</code></li>
<li>构造函数 <code>this =&gt; 当前实例</code></li>
<li>箭头函数 <code>没有 this ，它的 this 是上下文，即外部作用域的 this</code></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 进阶 -- Refs and DOM]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-refs-and-dom/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-refs-and-dom/">
        </link>
        <updated>2020-08-22T10:27:06.000Z</updated>
        <summary type="html"><![CDATA[<p>React 数据流是单向的，通过 <code>props</code> 由父组件向子组件传递数据，如果要修改子组件，需要修改 <code>props</code> 来重新渲染子组件。<code>refs</code> 就是另一种方法，它允许我们访问真实的 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p>
]]></summary>
        <content type="html"><![CDATA[<p>React 数据流是单向的，通过 <code>props</code> 由父组件向子组件传递数据，如果要修改子组件，需要修改 <code>props</code> 来重新渲染子组件。<code>refs</code> 就是另一种方法，它允许我们访问真实的 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p>
<!-- more -->
<h4 id="何时使用">何时使用</h4>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<p><strong>请勿过度使用 Refs，尽可能少地操作 DOM。</strong></p>
<h4 id="使用-refs">使用 Refs</h4>
<ul>
<li>
<p>利用 <code>React.createRef()</code> 构建：</p>
<pre><code class="language-jsx">export default class App extends Component {
  render() {
    return &lt;Hello /&gt;;
  }
}

class Hello extends Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef(); // 创建 Refs
  }

  render() {
    return (
      &lt;div style={{ margin: &quot;0 auto&quot;, width: &quot;80px&quot; }}&gt;
        &lt;h1 ref={this.myRef}&gt;Hello&lt;/h1&gt; {/*通过 ref 属性附加到 React 元素*/}
      &lt;/div&gt;
    );
  }
}
</code></pre>
</li>
<li>
<p>回调形式的 <code>refs</code></p>
<pre><code class="language-jsx">export default class App extends Component {
  render() {
    return &lt;Hello /&gt;;
  }
}

class Hello extends Component {
  constructor(props) {
    super(props);
    this.myRef = null; // 创建 Refs
  }

  render() {
    return (
      &lt;div style={{ margin: &quot;0 auto&quot;, width: &quot;80px&quot; }}&gt;
        &lt;h1 ref={(element) =&gt; this.myRef = element}&gt;Hello&lt;/h1&gt; {/*通过 ref 属性附加到 React 元素*/}
      &lt;/div&gt;
    );
  }
}	
</code></pre>
</li>
</ul>
<h4 id="访问-refs">访问 Refs</h4>
<pre><code class="language-jsx">const node = this.myRefs.current; // 将会得到 &lt;h1&gt; 标签
</code></pre>
<p>当使用回调形式的 <code>refs</code> 时无 <code>current</code> 属性，<code>this.myRefs</code> 即为 DOM。可通过下面的形式定义出 <code>current</code>，可简单理解为利用 <code>React.createRef()</code> 构建的 <code>refs</code> 即是这种原理（实际上官方还做了密封处理）：</p>
<pre><code class="language-jsx">class Hello extends Component {
  constructor(props) {
    super(props);
    this.myRef = {
      current: null
    }; // 创建 Refs
  }
  
  render() {
    return (
      &lt;div style={{ margin: &quot;0 auto&quot;, width: &quot;80px&quot; }}&gt;
        &lt;h1 ref={this.myRef}&gt;Hello&lt;/h1&gt; {/*通过 ref 属性附加到 React 元素*/}
      &lt;/div&gt;
    );
  }
}	
</code></pre>
<p><code>ref</code> 的值根据节点的类型而有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>
<li>当 <code>ref</code> 属性用于自定义 <code>class</code> 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例。</li>
</ul>
<p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/08/22/daHKUS.png" alt="何时获取到DOM" loading="lazy"></figure>
<h4 id="操作-dom">操作 DOM</h4>
<pre><code class="language-jsx">class Hello extends Component {
...
  componentDidMount() {
    if (this.myRef &amp;&amp; this.myRef.current) {
    this.myRef.current.innerHTML = &quot;World&quot;; // 原本 &lt;h1&gt; 标签中的 Hello 将被替换为 World
    }
  }
...
}

export default Hello;
</code></pre>
<h4 id="为-dom-元素添加-ref">为 DOM 元素添加 <code>ref</code></h4>
<pre><code class="language-jsx">import React from &quot;react&quot;;

export default class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 textInput 的 DOM 元素
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // 直接使用原生 API 使 text 输入框获得焦点
    // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点
    this.textInput.current.focus();
  }

  render() {
    // 告诉 React 我们想把 &lt;input&gt; ref 关联到
    // 构造器里创建的 `textInput` 上
    return (
      &lt;div&gt;
        &lt;input type='text' ref={this.textInput} /&gt;
        &lt;input
          type='button'
          value='Focus the text input'
          onClick={this.focusTextInput} {/*每当点击按钮输入框将自动获得焦点*/}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h4 id="为类组件添加-ref">为类组件添加 <code>Ref</code></h4>
<pre><code class="language-jsx">class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput(); //挂载后调用 current 内部方法实现输入框自动获取到焦点
  }

  render() {
    return (
      &lt;CustomTextInput ref={this.textInput} /&gt;
    );
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 网络请求 Fetch]]></title>
        <id>https://keasar.com.cn/post/javascript-wang-luo-qing-qiu-fetch/</id>
        <link href="https://keasar.com.cn/post/javascript-wang-luo-qing-qiu-fetch/">
        </link>
        <updated>2020-08-22T03:40:07.000Z</updated>
        <summary type="html"><![CDATA[<p>JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息。例如在表单提交、从服务器加载数据等都需要使用网络请求。对于来自 JavaScript 的网络请求，有一个总称术语 “AJAX”，有很多方式可以向服务端发送网络请求获取到数据。<code>fetch()</code>是目前比较通用的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息。例如在表单提交、从服务器加载数据等都需要使用网络请求。对于来自 JavaScript 的网络请求，有一个总称术语 “AJAX”，有很多方式可以向服务端发送网络请求获取到数据。<code>fetch()</code>是目前比较通用的方法。</p>
<!-- more -->
<h4 id="基本语法">基本语法</h4>
<pre><code class="language-js">let promise = fetch(url, [options])
</code></pre>
<ul>
<li><code>url</code>：要访问的 <code>url</code>地址</li>
<li><code>options</code>：可选参数，<code>method</code>、<code>header</code>等，参数为空则发起 <code>GET</code>请求</li>
<li>返回值为一个 <code>Promise</code> 对象</li>
</ul>
<h4 id="请求阶段">请求阶段</h4>
<p>获取到响应通常要经历两个阶段。</p>
<p>第一阶段：当服务器发送了响应头（response header），<code>fetch</code> 返回的 <code>promise</code> 就使用内建的 <a href="https://fetch.spec.whatwg.org/#response-class">Response</a> class 对象来对响应头进行解析。此时，我们可以通过检查响应头来检查 HTTP 状态来确认网络请求是否成功，这是还没有响应体 <code>response body</code>。</p>
<p>若<code>fetch</code> 无法建立一个 HTTP 请求，如网络问题，或是请求的网址不存在，那么 <code>promise</code> 就会 <code>reject</code>。异常的 HTTP 状态，例如 404 或 500，不会导致出现 <code>error</code>。</p>
<ul>
<li><code>response.status</code> -- HTTP 状态码</li>
<li><code>response.ok</code> -- Boolean，若为 200 - 299 为 <code>true</code></li>
</ul>
<p>第二阶段：获取到 <code>response body</code>，<code>Response</code> 提供了多种基于 <code>promise</code> 的方法，来以不同的格式访问 <code>body</code>：</p>
<ul>
<li><strong><code>response.text()</code></strong> —— 读取 response，并以文本形式返回 response</li>
<li><strong><code>response.json()</code></strong> —— 将 response 解析为 JSON</li>
<li><strong><code>response.formData()</code></strong> —— 以 <code>FormData</code> 对象的形式返回 response</li>
<li><strong><code>response.blob()</code></strong> —— 以 <a href="https://zh.javascript.info/blob">Blob</a>（具有类型的二进制数据）形式返回 response</li>
<li><strong><code>response.arrayBuffer()</code></strong> —— 以 <a href="https://zh.javascript.info/arraybuffer-binary-arrays">ArrayBuffer</a>（低级别的二进制数据）形式返回 response</li>
<li>另外，<code>response.body</code> 是 <a href="https://streams.spec.whatwg.org/#rs-class">ReadableStream</a> 对象，它允许你逐块读取 body，我们稍后会用一个例子解释它。</li>
</ul>
<blockquote>
<p>我们只能选择一种读取 <code>body</code> 的方法。</p>
<p>如果我们已经使用了 <code>response.text()</code> 方法来获取 <code>response</code>，那么如果再用 <code>response.json()</code>，则不会生效，因为 <code>body</code> 内容已经被处理过了。</p>
</blockquote>
<h4 id="post-请求"><code>POST</code> 请求</h4>
<pre><code class="language-js">let response = await fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: requestBody
});
</code></pre>
<ul>
<li><code>body</code> -- 请求体，可以是字符串、<code>FormData</code>对象（以 <code>form/multipart</code> 形式发送）、<code>Blob/BufferSource</code>二进制数据等</li>
</ul>
<blockquote>
<p>如果请求的 <code>body</code> 是字符串，则 <code>Content-Type</code> 会默认设置为 <code>text/plain;charset=UTF-8</code>。但是，当我们要发送 JSON 时，我们会使用 <code>headers</code> 选项来发送 <code>application/json</code>，这是 JSON 编码的数据的正确的 <code>Content-Type</code>。</p>
</blockquote>
<h4 id="用法小结">用法小结</h4>
<p>典型的 <code>fetch</code> 请求由两个 <code>await</code> 调用组成：</p>
<pre><code class="language-js">let response = await fetch(url, [options]); // 解析 response header
let result = await response.json(); // 将 body 读取为 json
</code></pre>
<p>或者以 <code>promise</code> 形式：</p>
<pre><code class="language-js">fetch(url, [options])
  .then(response =&gt; response.json())
  .then(result =&gt; /* 处理结果 */)
</code></pre>
<h4 id="实例">实例</h4>
<p>从 GitHub 获取用户信息：</p>
<pre><code class="language-js">  async function getUsers(names) {
    const response = await fetch(`https://api.github.com/users/${names}`);
    if (response.ok) {
    		const result = await response.json();
    		console.log(result);
    } else {
      return null;
    }
  }
  getUsers('qzlu-cyber');
</code></pre>
<h4 id="fetch-跟踪下载进度"><code>Fetch</code> 跟踪下载进度</h4>
<p><code>fetch()</code> 无法跟踪上传进度，但是可以跟踪下载进度。要跟踪下载进度，可以使用 <code>response.body</code> 属性。它是 <code>ReadableStream</code> —— 一个特殊的对象，它可以逐块（chunk）提供 <code>body</code>。</p>
<pre><code class="language-js">// 代替 response.json() 以及其他方法
const reader = response.body.getReader();

// 在 body 下载时，一直为无限循环
while(true) {
  // 当最后一块下载完成时，done 值为 true，否则为 false
  // value 是块字节的 Uint8Array
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
</code></pre>
<h4 id="fetch-中止"><code>fetch</code> 中止</h4>
<p>JavaScript 有一个特殊的内建对象 <code>AbortController</code>，既可以中止 <code>fetch</code> 也可以中止其他异步任务。</p>
<p>用法：</p>
<pre><code class="language-js">let controller = new AbortController();
</code></pre>
<p><code>controller</code> 对象具有 <code>abort()</code> 方法和 <code>signal</code>属性。当 <code>abort()</code> 被调用时，<code>abort</code> 事件会在 <code>controller.signal</code> 上触发，同时 <code>controller.signal.aborted</code> 属性变为 <code>true</code>。</p>
<pre><code class="language-js">let controller = new AbortController();
fetch(url, {
  signal: controller.signal // 将 signal 属性传递给 fetch 参数
}); // fetch 会监听 signal 上的 abort

controller.abort(); // 调用 controller.abort() 来中止
</code></pre>
<p>当一个 <code>fetch</code> 被中止，它的 <code>promise</code> 就会以一个 error <code>AbortError</code> 被 reject：</p>
<pre><code class="language-js">try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // 处理 abort()
    alert(&quot;Aborted!&quot;);
  } else {
    throw err;
  }
}
</code></pre>
<p><code>AbortController</code> 是可扩展的，它允许一次取消多个 fetch。也可以等待需要完成的 <code>fetch</code> 异步网络请求后中止其他 <code>fetch</code>。</p>
<pre><code class="language-js">let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) =&gt; { // 需要完成的 fetch
  ...
  controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url =&gt; fetch(url, { // 所有 fetch
  signal: controller.signal
}));

// 等待完成我们的任务和所有 fetch
let results = await Promise.all([...fetchJobs, ourJob]);

// 如果 controller.abort() 被从其他地方调用，
// 它将中止所有 fetch 和 ourJob
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 进阶 -- Context]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-context/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-context/">
        </link>
        <updated>2020-08-21T10:32:07.000Z</updated>
        <summary type="html"><![CDATA[<p>在 React 中数据总是单向传递的，如果某个属性许多组件都需要就会使该过程变得极其繁琐，Context 提供了在组件间共享此类数据的方式，而不必显式地通过组件树的逐层传递 props。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在 React 中数据总是单向传递的，如果某个属性许多组件都需要就会使该过程变得极其繁琐，Context 提供了在组件间共享此类数据的方式，而不必显式地通过组件树的逐层传递 props。</p>
<!-- more -->
<h3 id="什么情况下使用-context">什么情况下使用 Context</h3>
<ol>
<li>
<p>当某个（些）属性需要传递的层级很深时</p>
<p>考虑下面的例子：</p>
<pre><code class="language-jsx">class App extends Component {
  state = { count: 1 }
  render() {
    return (
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father count={this.state.count} /&gt;
        &lt;/div&gt;
    );
  }
}

class Father extends Component {
  render() {
    return (
      &lt;div className='father'&gt;
        &lt;h1&gt;这是父组件&lt;/h1&gt;
        &lt;Son count={this.props.count} /&gt;
      &lt;/div&gt;
    );
  }
}

class Son extends Component {
  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
      	&lt;h2&gt;{this.props.count}&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>如果 <code>Son</code> 组件需要来自根组件的 count，则需要从 <code>App</code> 组件开始通过props 属性自上而下传递给 <code>Son</code> 组件。使用 context, 我们可以避免通过中间元素传递 props：</p>
<pre><code class="language-jsx">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
// 为当前的 theme 创建一个 context（1为默认值）。
const countContext = React.createContext(1);
class App extends Component {
  state = { count: 1 };
  render() {
    return (
     // 使用一个 Provider 来将当前的 state 传递给以下的组件树。
    // 无论多深，任何组件都能读取这个值。
    // 在这个例子中，我们将 state 作为当前的值传递下去。
      &lt;Provider value={this.state}&gt;
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    );
  }
}

// 中间的组件再也不必指明往下传递了。
class Father extends Component {
  render() {
    return (
      &lt;div className='father'&gt;
        &lt;h1&gt;这是父组件&lt;/h1&gt;
        &lt;Son /&gt;
      &lt;/div&gt;
    );
  }
}

class Son extends Component {
  // 指定 contextType 读取当前的 count context。
  // React 会往上找到最近的 count Provider，然后使用它的值。
  // 在这个例子中，当前的 count 值为 1。
  static contextType = countContext; 
  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
        &lt;h2&gt;{this.context.count}&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
  // 也可使用 Consumer 渲染出 context
  /*
  render() {
    const { Consumer } = globalContext;
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
        &lt;h2&gt;{this.context.count}&lt;/h2&gt;
        &lt;Consumer&gt;{(context) =&gt; &lt;h2&gt;{context.count}&lt;/h2&gt;}&lt;/Consumer&gt;
        &lt;button onClick={this.add}&gt;点我加1&lt;/button&gt;
        &lt;button onClick={this.minus}&gt;点我减1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
  */
}
</code></pre>
<p>如何在 <code>Son</code> 组件中更改 Context 呢？</p>
<pre><code class="language-jsx">// 导出 context 修改函数
const actions = (self) =&gt; ({
  add() {
    self.setState((preState) =&gt; ({ count: preState.count + 1 }));
  },
  minus() {
    self.setState((preState) =&gt; ({ count: preState.count - 1 }));
  },
});

class App extends Component {
  // 扩展 actions 并传入 this
  state = { count: InitialContext.count, ...actions(this) };
  render() {
    return (
      &lt;Provider value={this.state}&gt;
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    );
  }
}

class Son extends Component {
  static contextType = globalContext;

  // 调用在 context 中定义好的加减函数
  add = () =&gt; {
    this.context.add();
  };

  minus = () =&gt; {
    this.context.minus();
  };

  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
        &lt;h2&gt;{this.context.count}&lt;/h2&gt;
        &lt;button onClick={this.add}&gt;点我加1&lt;/button&gt;
        &lt;button onClick={this.minus}&gt;点我减1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。如果仅仅是为了避免层层传递属性可以使用<strong>组件组合</strong>。</p>
</li>
<li>
<p>无亲属关系的组件需要共用的数据</p>
<p>考虑下面的例子：</p>
<pre><code class="language-jsx">class App extends Component {
  render() {
    return (
      &lt;div className='App'&gt;
        &lt;h1&gt;这是根组件&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

class Test extends Component {
  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是另一个组件&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p><code>App</code> 组件和 <code>Test</code> 组件既不是父子关系也不是兄弟关系，如果想要将 <code>App</code>组件中的数据传递给 <code>Test</code> 组件可以利用 Context 来实现：</p>
<pre><code class="language-jsx">const countContext = React.createContext(&quot;我是要传递的数据&quot;);
class App extends Component {
  render() {
    return (
      &lt;div className='App'&gt;
        &lt;h1&gt;这是根组件&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

class Test extends Component {
  static contextType = globalContext;

  render() {
    return (
      &lt;div className='test'&gt;
        &lt;h1&gt;这是另一个组件&lt;/h1&gt;
        &lt;h2&gt;{this.context}&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<p>Context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 <code>Provider</code> 的父组件进行重渲染时，可能会在 <code>Consumers</code> 组件中触发意外的渲染。举个例子，当每一次 <code>Provider</code> 重渲染时，以下的代码会重渲染所有下面的 <code>Consumers</code> 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>
<pre><code class="language-jsx">class App extends Component {
  render() {
    return (
      &lt;Provider value={1}&gt;
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    );
  }
}
</code></pre>
<p>因此，将 <code>value</code> 状态提升到父节点的 <code>state</code> 中是更好的做法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 进阶 -- 状态提升]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-zhuang-tai-ti-sheng/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-zhuang-tai-ti-sheng/">
        </link>
        <updated>2020-07-13T12:12:03.000Z</updated>
        <summary type="html"><![CDATA[<p>如果多个组件需要反映相同的变化数据，可将它们提升至最近的父组件，由父组件渲染后再分发个子组件。</p>
<p>下面是一个汇率转换示例</p>
]]></summary>
        <content type="html"><![CDATA[<p>如果多个组件需要反映相同的变化数据，可将它们提升至最近的父组件，由父组件渲染后再分发个子组件。</p>
<p>下面是一个汇率转换示例</p>
<!-- more -->
<p><code>Money</code>组件渲染出input标签：</p>
<pre><code class="language-js">import React, { Component } from &quot;react&quot;;

const scaleNames = {
  R: &quot;RMB&quot;,
  D: &quot;dollar&quot;,
};

class Money extends Component {
  handleChange = (e) =&gt; {
    this.props.onValueChange(e.target.value);
  };

  render() {
    const value = this.props.value;
    const scale = this.props.scale;
    return (
      &lt;fieldset&gt;
        &lt;legend&gt;请输入{scaleNames[scale]}:&lt;/legend&gt;
        &lt;input value={value} onChange={this.handleChange} /&gt;
      &lt;/fieldset&gt;
    );
  }
}

export default Money;
</code></pre>
<p><code>Calculator</code>组件我们会把当前输入的 <code>value</code> 和 <code>scale</code> 保存在组件内部的 state 中。这个 state 就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的<strong>共同“数据源”</strong>。这是我们为了渲染两个输入框所需要的所有数据的最小表示。</p>
<pre><code class="language-js">import React, { Component } from &quot;react&quot;;
import Money from &quot;./money&quot;;
import { toRMB, toDollar, tryConvert } from &quot;./transform&quot;;

class Calculator extends Component {
  constructor(props) {
    super(props);
    this.state = { value: 1, scale: &quot;R&quot; };
  }

  handleRMBChange = (value) =&gt; {
    this.setState({ scale: &quot;R&quot;, value });
  };

  handleDollarChange = (value) =&gt; {
    this.setState({ scale: &quot;D&quot;, value });
  };

  onValueChange = () =&gt; {
    this.setState({
      value: &quot;&quot;,
      scale: &quot;&quot;,
    });
  };

  render() {
    const scale = this.state.scale;
    const value = this.state.value;
    const RMB = scale === &quot;D&quot; ? tryConvert(value, toRMB) : value;
    const dollar = scale === &quot;R&quot; ? tryConvert(value, toDollar) : value;
    return (
      &lt;div&gt;
        &lt;Money scale=&quot;R&quot; value={RMB} onValueChange={this.handleRMBChange} /&gt; //人民币
        &lt;Money
          scale=&quot;D&quot;
          value={dollar}
          onValueChange={this.handleDollarChange}
        /&gt; //美元
      &lt;/div&gt;
    );
  }
}

export default Calculator;
</code></pre>
<p><code>transform</code>汇率转换组件：</p>
<pre><code class="language-js">export function toRMB(dollar) {
  return dollar * 7;
}

export function toDollar(RMB) {
  return RMB / 7;
}

export function tryConvert(value, convert) {
  const input = parseFloat(value);
  if (Number.isNaN(input)) {
    return &quot;&quot;;
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}
</code></pre>
<p>当对输入框内容进行编辑时会发生些什么:</p>
<ol>
<li>React 会调用 DOM 中 <code>&lt;input&gt;</code> 的 <code>onChange</code> 方法。在本实例中，它是 <code>Money</code> 组件的 <code>handleChange</code> 方法。</li>
<li><code>Money</code> 组件中的 <code>handleChange</code> 方法会调用 <code>this.props.onValueChange()</code>，并传入新输入的值作为参数。其 props 诸如 <code>onValueChange</code> 之类，均由父组件 <code>Calculator</code> 提供。</li>
<li>起初渲染时，用于人民币输入的子组件 <code>Money</code> 中的 <code>onValueChange</code> 方法与 <code>Calculator</code> 组件中的 <code>handleRMBChange</code> 方法相同，而，用于美元输入的子组件 <code>Money</code> 中的 <code>onValueChange</code> 方法与 <code>Calculator</code> 组件中的 <code>handleDollarChange</code> 方法相同。因此，无论哪个输入框被编辑都会调用 <code>Calculator</code> 组件中对应的方法。</li>
<li>在这些方法内部，<code>Calculator</code> 组件通过使用新的输入值与当前输入框对应的货币类型来调用 <code>this.setState()</code> 进而请求 React 重新渲染自己本身。</li>
<li>React 调用 <code>Calculator</code> 组件的 <code>render</code> 方法得到组件的 UI 呈现。汇率转换在这时进行，两个输入框中的数值通过当前输入值和其货币类型来重新计算获得。</li>
<li>React 使用 <code>Calculator</code> 组件提供的新 props 分别调用两个 <code>Money</code> 子组件的 <code>render</code> 方法来获取子组件的 UI 呈现。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 进阶 -- 表单]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-biao-dan/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-biao-dan/">
        </link>
        <updated>2020-07-13T12:08:48.000Z</updated>
        <summary type="html"><![CDATA[<ol>
<li>
<p>受控组件</p>
<p>利用 state 管理 input等标签 的输入内容。内容只能通过 <strong>setState</strong> 改变。</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<ol>
<li>
<p>受控组件</p>
<p>利用 state 管理 input等标签 的输入内容。内容只能通过 <strong>setState</strong> 改变。</p>
</li>
</ol>
<!-- more -->
<pre><code class="language-js">class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  //没有onChange事件会触发警告，导致文本框中的内容无法更改和显示
  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          名字:
          &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
<ol start="2">
<li>
<p>非受控组件</p>
<p>建议采用受控组件，但是当你需要编写很多事件处理函数时可以使用非受控组件，即使用 ref 获取到真实的DOM节点。</p>
<pre><code class="language-js">class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef(); 
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value); //通过current定位到当前DOM节点
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          Name:
          &lt;input type=&quot;text&quot; ref={this.input} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统（三）--  处理机调度与死锁]]></title>
        <id>https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/</id>
        <link href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">
        </link>
        <updated>2020-06-09T04:21:13.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a></p>
<h3 id="1-处理机调度的层次和调度算法的目标">1. 处理机调度的层次和调度算法的目标</h3>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a></p>
<h3 id="1-处理机调度的层次和调度算法的目标">1. 处理机调度的层次和调度算法的目标</h3>
<!-- more -->
<ol>
<li>
<p>处理机调度的层次</p>
<ul>
<li>高级调度：对象是作业，将处于后备队列的作业调入到内存。</li>
<li>中级调度：即内存调度，旨在提高内存利用率和系统吞吐量，将暂时不能运行/能运行的进程调出/入内存。</li>
<li>低级调度：对象是进程，决定就绪队列中哪个进程获得处理机，运行频率最高。</li>
</ul>
</li>
<li>
<p>调度算法的目标</p>
<ul>
<li>
<p>共同目标</p>
<ul>
<li>
<p>资源利用率，即尽可能使所有资源都处于忙碌状态</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/09/t4UP3T.png" alt="t4UP3T.png" loading="lazy"></figure>
</li>
<li>
<p>公平性</p>
</li>
<li>
<p>平衡性</p>
</li>
<li>
<p>策略强制执行</p>
</li>
</ul>
</li>
<li>
<p>批处理系统目标</p>
<ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
</li>
<li>
<p>分时系统的目标</p>
<ul>
<li>响应时间快</li>
<li>均衡性</li>
</ul>
</li>
<li>
<p>实时系统的目标</p>
<ul>
<li>截止时间的保证</li>
<li>可预测性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-作业与作业调度">2. 作业与作业调度</h3>
<ol>
<li>
<p>批处理系统中的作业</p>
<ul>
<li>作业：包含通常的程序和数据即作业说明书。</li>
<li>作业步：各个作业间相互独立，每个加工步骤成为一个作业步。</li>
<li>作业控制块(JCB)：作业进入系统时建立JCB，保存了对作业进行管理和调度所需的全部信息。</li>
<li>三种状态和三个阶段
<ul>
<li>收容阶段(后备状态)</li>
<li>运行阶段(运行状态)</li>
<li>完成阶段(完成状态)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>作业调度</p>
<ul>
<li>
<p>先来先服务(FCFS)调度算法：可用于作业、进程调度，系统按照作业到达的先后次序进行调度。</p>
</li>
<li>
<p>短作业优先(SJF)调度算法：可用于作业、进程调度，作业越短优先级越高。</p>
<ul>
<li>优点：能有效地降低作业的平均等待时间，提高系统吞吐量。</li>
<li>缺点：需要预知作业运行时间；对长作业不利；无法实现交互；未考虑作业优先性。</li>
</ul>
</li>
<li>
<p>高优先权优先调度算法</p>
<ul>
<li>
<p>优先级调度算法(PSA)的类型</p>
<ul>
<li>非抢占式优先权算法：主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
<li>抢占式优先权调度算法：常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
<li>
<p>优先权的类型<br>
① 静态优先权：静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变<br>
② 动态优先权：动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</p>
</li>
<li>
<p>高响应比优先(HRRN)调度算法：既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。<br>
Rp优先级 =（等待时间 + 要求服务时间）/ 要求服务时间 = 响应时间 / 要求服务时间</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-进程调度">3. 进程调度</h3>
<ol>
<li>
<p>进程调度的任务、机制和方式</p>
<ul>
<li>
<p>任务</p>
<p>① 保存处理及现场信息；</p>
<p>② 按某种算法选取进程；</p>
<p>③ 把处理器分配给进程。</p>
</li>
<li>
<p>机制</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/09/t40Ez6.png" alt="t40Ez6.png" loading="lazy"></figure>
</li>
<li>
<p>方式</p>
<p>① 非抢占方式：进程一旦分配到处理机，就让其一直运行下去，不会因其他条件抢占当前正在运行进程的处理机，直至结束。</p>
<p>② 抢占方式：暂停某个正在运行的进程，将其处理机分配给另一个进程。遵循三个原则：优先权原则、短进程优先原则、时间片原则。</p>
</li>
</ul>
</li>
<li>
<p>轮转调度算法</p>
<p>主要应用于分时系统。</p>
<p>让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有 n 个进程，则每个进程每次大约都可获得 1/n 的处理机时间。</p>
<p>时间片大小的确定：时间片略大于一次典型的交互所需要的时间。</p>
</li>
<li>
<p>多队列调度算法</p>
<p>将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法。</p>
</li>
<li>
<p>多级反馈队列调度算法</p>
<p>设置多个就绪队列，每个就绪队列都采用 <em><strong>FCFS</strong></em> 算法，按队列优先级调度。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/09/t4suct.png" alt="t4suct.png" loading="lazy"></figure>
<p>若进程在本就绪队列的时间片完成则结束该进程，否则进入下一优先级就绪队列末尾等待执行，以此类推；若进程从阻塞队列被唤醒，则插入到比其本身高一优先级队列的末尾执行。</p>
</li>
</ol>
<h3 id="4-实时调度">4. 实时调度</h3>
<ol>
<li>
<p>实现条件</p>
<p>① 提供必要的信息<br>
② 系统处理能力强<br>
③ 采用抢占式调度机制<br>
④ 具有快速切换机制</p>
</li>
<li>
<p>分类<br>
① 非抢占式调度算法</p>
<ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ul>
<p>② 抢占式调度算法</p>
<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/09/t4ck7T.png" alt="t4ck7T.png" loading="lazy"></figure>
</li>
<li>
<p>最早截止时间优先(EDF)算法：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。具有最早截止时间的任务排在队列的最前面。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。</p>
</li>
<li>
<p>最低松弛度优先(LLF)算法：根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。</p>
</li>
</ol>
<h3 id="5-死锁概述">5. 死锁概述</h3>
<ol>
<li>
<p>资源</p>
<ul>
<li>可重用性资源：可供用户重复使用多次的资源；此类资源中的单元只能分配给一个进程使用，不允许多个进程共享；遵循请求资源 -&gt; 使用资源 -&gt; 释放资源的顺序；数目固定，进程既不能创建也不能删除。</li>
<li>可消耗性资源：临时性资源，由进程在运行期间动态地创建和删除。</li>
<li>可抢占性资源：某进程得到该资源后，该资源仍可被其他进程或系统抢占，如CPU、主存等。</li>
<li>不可抢占性资源：某进程得到该资源后，不能将此类资源强制回收，只能等待其主动释放，如打印机等。</li>
</ul>
</li>
<li>
<p>计算机系统中的死锁</p>
<ul>
<li>
<p>竞争不可抢占性资源引起死锁</p>
<img src="https://s1.ax1x.com/2020/06/09/t420k8.png" alt="t420k8.png" style="zoom:80%;" />
</li>
<li>
<p>竞争可消耗资源引起死锁</p>
</li>
<li>
<p>进程推进顺序不当引起死锁</p>
<img src="https://s1.ax1x.com/2020/06/09/t4RS9e.png" alt="t4RS9e.png" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>死锁</p>
<ul>
<li>
<p>定义：在多道程序系统中，一组进程中的每一个进程都在无限期地等待另一组进程所占有且永远不会释放的资源。</p>
</li>
<li>
<p>产生的必要条件</p>
<p>① 互斥条件</p>
<p>② 请求和保持条件</p>
<p>③ 不可抢占条件</p>
<p>④ 循环等待条件</p>
</li>
<li>
<p>处理死锁的方法</p>
<p>① 预防死锁</p>
<p>② 避免死锁</p>
<p>③ 检测死锁</p>
<p>④ 解除死锁</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-预防死锁">6. 预防死锁</h3>
<ol>
<li>
<p>破坏“请求和保持”条件</p>
<ul>
<li>
<p>第一种协议：进程在运行前，必须一次性地申请运行过程中的全部资源。</p>
<ul>
<li>优点：简单、易行、安全。</li>
<li>缺点：资源被严重浪费，严重恶化了资源利用率；使进程经常会发生饥饿现象(某进程所需某资源可能被其他进程长期占用)。</li>
</ul>
</li>
<li>
<p>第二种协议：获得运行必不可少的资源后立即开始运行，在运行过程中逐步释放已分配的且已用毕的资源再申请所需新资源。</p>
<ul>
<li>使进程更快完成任务，提高设备利用率，减少进程发生饥饿的几率。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>破坏“不可抢占”条件</p>
<p>进程已占有的资源会被暂时地释放，待以后需要时再重新申请。</p>
<ul>
<li>代价较高，延长了进程周转时间，增加了系统开销，降低了系统吞吐量。</li>
</ul>
</li>
<li>
<p>破坏“循环等待”条件</p>
<p>对系统所有资源类型线性排序，规定每个进程必须按序号递增的顺序请求资源</p>
<ul>
<li>优缺点：限制了新类型设备的增加，造成资源浪费，限制用户简单、自主编程。</li>
</ul>
</li>
</ol>
<h3 id="7-避免死锁">7. 避免死锁</h3>
<p><strong>避免死锁的实质在于,系统在进行资源分配时,应使系统不进入不安全状态。</strong></p>
<ol>
<li>
<p>安全状态：在系统进行资源分配前计算此次资源分配是否安全，安全则分配，否则令进程等待。</p>
</li>
<li>
<p>利用银行家算法避免死锁</p>
<ul>
<li>
<p>数据结构</p>
<p>可用 <em>Available</em><br>
最大需求 <em>Max</em><br>
已分配 <em>Allocation</em><br>
还需要 <em>Need</em></p>
<p><em>Need = Max - Allocation</em></p>
</li>
<li>
<p>银行家算法</p>
<p>设 Requesti 是进程 Pi 的请求向量，如果 Requesti[ j ] == K，表示进程 Pi 需要 K 个 Rj 类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査</p>
<p>(1) 如果 Requesti[ j ] ≤ Need[ i, j ]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。<br>
(2) 如果 Requesti[ j ] ≤ Available[ i ]，便转向步骤(3)；否则，表示尚无足够资源，Pi 须等待。<br>
(3) 系统试探把资源分配给进程 Pi 并修改下面数据结构中的数值</p>
<blockquote>
<p>Available[ j ] = Available[ j ] - Requesti[ j ]</p>
<p>Allocation[ i, j ] = Allocation[ i, j ] + Requesti[ j ]</p>
<p>Need[ i, j ] = Need[ i, j ] - Requesti[ j ]</p>
</blockquote>
<p>(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程P，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程P等待。</p>
</li>
<li>
<p>安全性算法</p>
<p>(1) 设置两个向量：①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全性算法开始时，</p>
<p>Wok = Available；② Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[ i ] = false；当有足够资源分配给进程时，再令 Finish[ i ] = true。<br>
(2) 从进程集合中找到一个能满足下述条件的进程 ① Finish[ i ] = false；② Needl[ i, j ] ≤ Work[ j ]；若找到，执行步骤(3)，否则，执行步骤(4)。<br>
(3) 当进程 P 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行</p>
<blockquote>
<p>Work[ j ] = Work[ j ] + Allocation[ i, j ]</p>
<p>Finish[ i ] = true</p>
<p>go to step 2；</p>
</blockquote>
<p>(4) 如果所有进程的 Finish[ⅰ] = true 都满足,则表示系统处于安全状态，否则，系统处于不安全状态。</p>
</li>
</ul>
</li>
</ol>
<h3 id="8-死锁的检测与解除">8. 死锁的检测与解除</h3>
<ol>
<li>
<p>检测</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/09/t44dJK.png" alt="t44dJK.png" loading="lazy"></figure>
<p>若能消去图中所有的边，使所有的进程结点都成为孤立结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。</p>
</li>
<li>
<p>死锁的解除</p>
<ul>
<li>抢占资源。从一个或多个进程中抢占足够数量的资源,分配给死锁进程,以解除死锁状态。</li>
<li>终止(或撇消)进程。终止(或撤消)系统中的一个或多个死锁进程,直至打破循环环路,使系统从死锁状态解脱出来。
<ul>
<li>终止所有死锁进程</li>
<li>逐个终止进程</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统学习笔记（二）--  进程的描述与控制]]></title>
        <id>https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/</id>
        <link href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">
        </link>
        <updated>2020-06-08T07:29:37.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
<a href="https://imgchr.com/i/tRv9l6"><img src="https://s1.ax1x.com/2020/06/08/tRv9l6.md.png" alt="tRv9l6.md.png" style="zoom:80%;" /></a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
<a href="https://imgchr.com/i/tRv9l6"><img src="https://s1.ax1x.com/2020/06/08/tRv9l6.md.png" alt="tRv9l6.md.png" style="zoom:80%;" /></a></p>
<!-- more -->
<h3 id="1-前趋图和程序执行">1. 前趋图和程序执行</h3>
<ol>
<li>
<p>前驱图</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/08/tRv4BD.png" alt="tRv4BD.png" loading="lazy"></figure>
</li>
<li>
<p>程序的顺序执行</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/08/tRv74A.png" alt="tRv74A.png" loading="lazy"></figure>
<p>特征：</p>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
</li>
<li>
<p>程序的井发执行</p>
<p>特征：</p>
<ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
</li>
</ol>
<h3 id="2-进程的描述">2. 进程的描述</h3>
<ol>
<li>
<p>进程的定义和特征</p>
<ol>
<li>
<p>定义</p>
<ul>
<li>由程序段、相关的数据段和 <strong>PCB</strong> 三部分便构成了进程实体(又称进程映像)。</li>
</ul>
</li>
<li>
<p>特征</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>进程的基本状态及转换</strong></p>
<ol>
<li>
<p>三种基本状态</p>
<ul>
<li>就绪 Ready</li>
<li>执行 Running</li>
<li>阻塞 Block</li>
</ul>
</li>
<li>
<p>三种基本状态的转换</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/08/tRzKeS.png" alt="tRzKeS.png" loading="lazy"></figure>
<ul>
<li>就绪状态→执行状态：为就绪队列队首的程序分配处理器。</li>
<li>执行状态→就绪状态：时间片用完</li>
<li>执行状态→阻塞状态：I/O请求</li>
<li>阻塞状态→就绪状态：I/O完成</li>
</ul>
</li>
<li>
<p>加入创建和终止的五状态转换</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/08/tWSVk4.png" alt="tWSVk4.png" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>挂起操作和进程状态的转换</p>
<p>​		当该操作作用千某个进程时，该进程将被<strong>挂起</strong>，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。 若原本处千就绪状态， 则该进程此时暂不接受调度。与挂起操作对应的操作是激活操作。</p>
<ol>
<li>
<p>挂起操作的引入</p>
<ul>
<li>终端用户的需要</li>
<li>父进程请求</li>
<li>负荷调节的需要</li>
<li>操作系统的需要</li>
</ul>
</li>
<li>
<p>引入挂起原语操作后三个进程状态的转换</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/08/tWPNa8.png" alt="tWPNa8.png" loading="lazy"></figure>
<ul>
<li>活动就绪(Readya) → 静止就绪(Readys)：未被挂起可以接受调度为Readya，挂起原语 Suspend 将该进程挂起后，变为Readys，不能接受调度。</li>
<li>活动阻塞(Blockeda) → 静止阻塞(Blockeds)：未被挂起的阻塞为Blockeda，经 Suspend 挂起后，为 Blockeds；处于该状态的进程在其所期待的事件出现后，它将从 Blockeds 变为 Readys 状态。</li>
<li>静止就绪(Readys) → 活动就绪(Readya)：处于 Readys 的进程被激活原语 Active 激活。</li>
<li>静止阻塞(Blockeds) → 活动阻塞(Blockeda)：。处于 Blockeds 的进程被激活原语 Active 激活。</li>
</ul>
</li>
<li>
<p>引入挂起操作后五个进程状态的转换</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/08/tWPdPg.png" alt="tWPdPg.png" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>进程管理中的数据结构</p>
<ol>
<li>
<p>进程控制块 PCB 的作用</p>
<p>PCB 的作用是使 在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位一个能与其他进程并发执行的进程。</p>
<ul>
<li>作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其它进程的同步与通信</li>
</ul>
</li>
<li>
<p>PCB 中的信息</p>
<ol>
<li>
<p>进程标识符</p>
<ul>
<li>外部 ~ 用户</li>
<li>内部 ~ OS</li>
</ul>
</li>
<li>
<p>处理机状态</p>
<p>即处理机的上下文，由下面的寄存器组成</p>
<ul>
<li>通用寄存器：用户程序可访问，用于暂存信息。</li>
<li>指令计数器：存放要访问的下一条指令的地址。</li>
<li>程序状态字 PSW：含有状态信息，如条件码、执行方式、中断屏蔽标志。</li>
<li>用户栈指针：用于存放过程和系统调用参数及调用地址。</li>
</ul>
</li>
<li>
<p>进程调度信息</p>
<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>进程调度其他信息</li>
<li>事件</li>
</ul>
</li>
<li>
<p>进程控制信息</p>
<ul>
<li>程序和数据的地址</li>
<li>程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
</ol>
</li>
<li>
<p>进程控制块的组织方式</p>
<ul>
<li>
<p>线性方式</p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/08/tWktVx.png" alt="tWktVx.png" loading="lazy"></figure>
</li>
<li>
<p>链接方式</p>
<figure data-type="image" tabindex="8"><img src="https://s1.ax1x.com/2020/06/08/tWkrMd.png" alt="tWkrMd.png" loading="lazy"></figure>
</li>
<li>
<p>索引方式</p>
<figure data-type="image" tabindex="9"><img src="https://s1.ax1x.com/2020/06/08/tWkhRg.png" alt="tWkhRg.png" loading="lazy"></figure>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="3-进程控制">3. 进程控制</h3>
<ol>
<li>
<p>操作系统内核</p>
<p>分类：</p>
<ul>
<li>系统态（管态）：高权限，能执行一切指令，传统 OS 运行在此。</li>
<li>应用态（目态）：低权限，只能运行一部分指令，应用程序运行在此。</li>
</ul>
<p>功能：</p>
<ol>
<li>
<p>支撑功能</p>
<ul>
<li>中断处理</li>
<li>时钟管理</li>
<li>原语操作</li>
</ul>
</li>
<li>
<p>资源管理功能</p>
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ol>
</li>
<li>
<p>进程的创建与撤销</p>
<ol>
<li>
<p>创建</p>
<ul>
<li>方式：由系统程序创建、由父进程创建</li>
<li>引起创建的事件：用户登录、作业调度、提供服务、应用请求</li>
<li>过程：<br>
① 申请空白PCB<br>
② 为新进程分配资源<br>
③ 初始化进程控制块<br>
④ 将新进程插入就绪队列</li>
</ul>
</li>
<li>
<p>撤销</p>
<ul>
<li>
<p>方式：由操作系统终止、有进程发出请求</p>
</li>
<li>
<p>引起撤销的事件：正常结束、异常结束（越界错误、运行超时）、外界干预（父进程请求、父进程终止）</p>
</li>
<li>
<p>过程：</p>
<p>① 根据标识符找到该进程，读取状态</p>
<p>② 若正处于执行状态，立即终止该，并置调度标志为真，用于指示该进程被终止后应重新进行调度</p>
<p>③ 若该进程还有子孙进程，一并终止</p>
<p>④ 将该进程所有资源还给父进程或 OS</p>
<p>⑤ 将该进程 PCB 移出PCB表</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>进程的阻塞与唤醒</p>
<ol>
<li>
<p>引起阻塞或唤醒的主要事件：</p>
<ul>
<li>请求系统服务</li>
<li>启动某些操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ul>
</li>
<li>
<p>进程阻塞过程</p>
<p>​		正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语 block 将自己阻塞(主动行为)。立即停止执行，把进程控制块中的现行状态由“执行“改为阻塞，并将 PCB 插入阻塞队列。</p>
</li>
<li>
<p>进程唤醒过程</p>
<p>​		调用唤醒原语 wakeup， 首先把被阻塞的进程从等待该事件的阻塞队列中移出， 将其 PCB 的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。</p>
</li>
</ol>
</li>
<li>
<p>程序的挂起与激活</p>
<p>激活过程：（挂起为其逆过程）</p>
<ul>
<li>将进程从外存调入内存</li>
<li>检查该进程现行状态</li>
<li>若是静止就绪，改为活动就绪；若是静止阻塞，改为活动阻塞</li>
</ul>
</li>
</ol>
<h3 id="4-进程同步">4. 进程同步</h3>
<p>为保证多个进程能有条不紊地运行，在多道程序系统中，必须引入进程同步机制。</p>
<ol>
<li>
<p>进程同步的基本概念</p>
<ol>
<li>
<p>两种形式的制约关系</p>
<ul>
<li>间接相互制约关系</li>
<li>直接相互制约关系</li>
</ul>
</li>
<li>
<p>临界资源</p>
<p>​		虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p>
</li>
<li>
<p>临界区</p>
<p>在每个进程中访问临界资源的那段代码称为临界区。</p>
<p>访问临界资源的循环进程描述如下：</p>
<pre><code class="language-c">while (TRUE) 
{
	进入区
	临界区
	退出区
	剩余区
}
</code></pre>
</li>
<li>
<p>同步机制应遵循的规则</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
</ol>
</li>
<li>
<p>硬件同步机制</p>
<ol>
<li>
<p>关中断</p>
</li>
<li>
<p>利用 <em><strong>Test-and-Set</strong></em> 指令实现互斥</p>
<pre><code class="language-C">//lock=FALSE 时，表示该资源空闲； lock=TRUE 时， 表示该资源正在被使用。
boolean TS(boolean *lock) 
{
	Boolean old;
	old = *lock;
	*lock = TRUE;
	return old;
}
</code></pre>
<pre><code class="language-C">//为每个临界资源设置一个布尔变量lock, 初值为FALSE, 表示该临界资源空闲。进程在进入临界区之前，首先用TS测试lock, 若为FALSE则表示没有进程在临界区可以进入，并将TRUE值赋予lock，即关闭临界资源，使任何进程都不能进入临界区，否则必须循环测试直到TS(s)为TRUE。
do {
	while TS(&amp;lock);
	critical section;
	lock := FALSE;
	remainder section;
} while(TRUE) ; 
//不符合让权等待原则
</code></pre>
</li>
<li>
<p>利用 <em><strong>Swap</strong></em> 指令实现进程互斥</p>
<pre><code class="language-C">void swap(boolean *a, booJean *b)
{
	boolean temp ;
	temp = *a;
	*a = *b;
	*b = temp; 
}
</code></pre>
<pre><code class="language-c">//为每个临界资源设置一个全局的布尔变lock，其初值为false，在每个进程中再利用一个局部布尔变量key
do {
	key=TRUE;
	do {
	swap(&amp;lock , &amp;key);
} while (key!=FALSE );
	/*临界区操作*/
	lock = FALSE;
} while (TRUE); 
//不符合让权等待原则
</code></pre>
</li>
</ol>
</li>
<li>
<p>信号量机制</p>
<ol>
<li>
<p>整型信号量</p>
<pre><code class="language-C">//S表示资源数目；P-V操作
wait(S)
{
	while (S&lt;=O);
	S--;
}
signal(S)
{
	S++; 
}
//不符合让权等待原则
</code></pre>
</li>
<li>
<p>记录型信号量</p>
<pre><code class="language-C">typedef struct {
	int value; //表示资源数目
	struct process_control_block *list; //用于链接所有等待进程
} semaphore ; 
</code></pre>
<pre><code class="language-C">//每次wait操作代表有一个进程试图访问临界资源
wait(semap hore *S) 
{ 
	S-&gt;value--; //临界资源减1之后，≥0代表还有资源可以访问
	if (S-&gt;value &lt; 0) block (S-&gt;list); //小于0随即进入等待队列
}

//每次signal操作代表有一个进程试图释放临界资源
signal(semaphore *S) 
{
	S-&gt;value++; //临界资源加1后，小于0代表还没有临界资源可以访问
	if (S-&gt;value &lt;= O) wakeup(S-&gt;list); //≤0代表还有进程试图访问临界资源，随即唤醒等待队列中的第一个进程
}
</code></pre>
</li>
<li>
<p>AND 型信号量</p>
<p>适用于一个进程需要访问两个及以上的临界资源。</p>
<pre><code class="language-C">Swait(Sl , S2,..., Sn)
{
	while (TRUE)
	{
		if (Si&gt;=1 &amp;&amp;... &amp;&amp; Sn&gt;=1)
        {
			for (i=1; i&lt;=n; i++) Si--;
			break; 
        }
        else 
        {
			place the process in the waiting queue associated with the frrst Si found with
			Si&lt;1 , and set the program count of this process to the beginning of Swait operation 
        }
	}
}

Ssignal(Sl , S2, .. ., Sn)
{
	while (TRUE) 
    {
		for(i=1; i&lt;=n; i++) 
        {
			Si++;
			Remove all the process waiting in the queue associated with Si into the ready queue 
        }
    }
}
</code></pre>
</li>
<li>
<p>信号量集</p>
<p>对 AND 信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量在一次 P、V 原语操作中完成申请或释放。</p>
<pre><code class="language-c">//资源分配下限值ti,即要求Si≥ti,否则不予分配。一旦允许分配，进程对该资源的需求值为di,即表示资源占用量,进行Si = Si - di操作。
Swait(S1 t1, d1, ..., Sn, tn, dn);

Ssignal(S1, d1,.. ., Sn, dn);
</code></pre>
<pre><code class="language-C">Swait(S, d, d) //此时在信号量集中只有一个信号量S, 但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
Swait(S, 1, 1) //此时的信号量集已蜕化为一般的记录型信号量(S &gt; 1时）或 互斥信号量(S = 1时）。
Swait(S, 1, 0) //当 S≥1 时，允许多个进程进入某特定区;当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。
</code></pre>
</li>
</ol>
</li>
<li>
<p>信号量的应用</p>
<ol>
<li>
<p>利用信号量实现进程互斥</p>
<pre><code class="language-c">//mutex 互斥信号量其初值为1, 当mutex = 1时，表示两个进程皆未进入需要互斥的临界区; mutex = 0，表示有一个进程进入临界区运行，另外一个必须等待，挂入阻塞队列; 当mutex = -1 时，表示有一个进程正在临界区运行，另个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。
semaphore mutex= 1;
P(A)
{
    while(1) 
    {
		wait(mutex);
    	/*临界区*/
		signal(mutex);
		/*剩余区*/
	}
}

P(B)
{
    while(1)
    {
		wait(mutex);
		/*临界区*/
		signal(mutex);
		/*剩余区*/
    }
}
//wait(mutex) signal(mutex) 必须成对地出现，缺少wait(mutex)将会导致系统混乱，不能保证对临界资源的互斥访问; 缺少signal(mutex)将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程不能被唤醒。
</code></pre>
</li>
<li>
<p>利用信号量实现前趋关系</p>
<figure data-type="image" tabindex="10"><img src="https://s1.ax1x.com/2020/06/08/tW88Q1.png" alt="tW88Q1.png" loading="lazy"></figure>
<pre><code class="language-C">p1() { S1; signal(a); signal(b);}
p2() { wait(a); S2; signal(c); signal(d);}
p3() { wait(b); S3; signal(e);}
p4() { wait(c); S4; signal(t);}
p5() { wait(d); Ss; signal(g);}
p6() { wait(e); wait(f); wait(g); S6;}
main() 
{
    semaphore a, b, c, d, e, f, g;
    a.value = b.value = c.value = 0；
    d.value = e.value = 0;
    f.value = g.value = 0;
    cobegin
        pl(); p2(); p3(); p4(); p5(); p6(); 
    coend
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="5-经典进程的同步问题">5. 经典进程的同步问题</h3>
<ol>
<li>
<p>生产者－消费者问题</p>
<ul>
<li>
<p>问题描述</p>
<p>​		一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p>
</li>
<li>
<p>问题分析</p>
<ol>
<li>
<p>关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</p>
</li>
<li>
<p>整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。</p>
</li>
<li>
<p>信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-C">int in=0, out=0; //指向生产、消费的指针
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
void producer() //生产者进程
{ 
    do{
        produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元 /*wait(empty);wait(mutex); 或 Swait(empty, mutex );*/
        P(mutex);  //进入临界区
        add nextp to buffer;  //将数据放入缓冲区
        in=(in+ 1) % n; //指针后移
        V(mutex);  //离开临界区,释放互斥信号量 /*signal(mutex);signal(full); 或 Ssignal(mutex, full);*/
        V(full);  //满缓冲区数加1
    }while(TRUE)
}
void consumer() //消费者进程
{  
    do{
        P(full);  //获取满缓冲区单元 /*wait(full);wait(mutex); 或 Swait(full, mutex );*/
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        out=(out+l) % n; //指针后移
        V (mutex);  //离开临界区，释放互斥信号量 /*signal(mutex);signal(empty); 或 Ssignal(mutex, empty);*/
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    }while(TRUE)
}
</code></pre>
<p>该类问题要注意对缓冲区大小为 <em>n</em> 的处理，当缓冲区中有空时便可对empty变量执行 P操作，一旦取走一个产品便要执行 V操作 以释放空闲区。对empty和full变量的 P操作 必须放在对 <em>mutex</em> 的 P操作 之前。</p>
<blockquote>
<p>如果生产者进程先执行P(mutex)，然后执行P(empty)，消费者执行P(mutex),然后执行P(fall),这样可不可以？</p>
<p>答案是否定的。设想生产者进程已经将缓冲区放满，消费者进程并没有取产品，即 empty = 0，当下次仍然是生产者进程运行时，它先执行P(mutex)封锁信号量，再执行P(empty)时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行P(mutex)，然而由于生产者进程已经封锁mutex信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，陷入了无休止的等待。同理，如果消费者进程已经将缓冲区取空，即 full = 0,下次如果还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex、full先释放哪一个无所谓，消费者先释放mutex还是empty都可以。</p>
</blockquote>
</li>
<li>
<p>哲学家进餐问题</p>
<ul>
<li>
<p>问题描述</p>
<p>​		一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
</li>
<li>
<p>问题分析</p>
<ol>
<li>
<p>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li>
<p>整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。</p>
</li>
<li>
<p>信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {1, 1, 1, 1, 1}用于对5个筷子的互斥访问。</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-c">//对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
void Pi() //i号哲学家的进程
{  
    do{
        P(chopstick[i]); //取左边筷子 /*wait(chopstick[i]);wait(chopstick[(i+l)%5]); 或 Sswait(chopstick[(i+1)%5], chopstick[i]);*/
        P(chopstick[(i+1)%5]); //取右边篌子
        eat; //进餐
        V(chopstick[i]); //放回左边筷子 /*signal(chopstick[i]);signal(chopstick[(i+l)%5]); 或 Ssignal(chopstick[(i+1)%5], chopstick[i]);*/
        V(chopstick[(i+l)%5]); //放回右边筷子
        think; //思考
    } while(1);
}
</code></pre>
<p>该算法存在以下问题：<br>
当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完<em>wait(chopstick[i]</em>);)筷子已经被拿光了，等到他们再想拿右边的筷子的时候（执行 <em>wait(chopstick[(i+l)%5]</em>);)就全被阻塞了，这就出现了死锁。</p>
<p>​		为了防止死锁的发生，可以对哲学家进程施加一些限制条件：</p>
<ul>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有 1 位哲学家能 够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐</li>
<li>仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐</li>
<li>规定奇数号哲学家先拿左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定将是 1、2号哲学家竞争 1号筷子，3、4号哲学家竞争 3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有 1位哲学家 能获得两只筷子而进餐.</li>
</ul>
</li>
<li>
<p>读者-写者问题</p>
<ul>
<li>
<p>问题描述</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：<br>
① 允许多个读者可以同时对文件执行读操作；<br>
② 只允许一个写者往文件中写信息；<br>
③ 任一写者在完成写操作之前不允许其他读者或写者工作；<br>
④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>
</li>
<li>
<p>问题分析</p>
<ol>
<li>
<p>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
</li>
<li>
<p>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。</p>
</li>
<li>
<p>信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-C">int count=0;  //用于记录当前的读者数量
semaphore mutex=1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
void writer() //写者进程
{  
    do{
        P(rw); // 互斥访问共享文件
        Writing;  //写入
        V(rw) ;  //释放共享文件
    }while(TRUE)
}
void reader () //读者进程
{  
    do{
        P (mutex) ;  //互斥访问count变量
        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写
        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        reading;  //读取
        P (mutex) ;  //互斥访问count变量
        count--; //读者计数器减1
        if (count==0)  //当最后一个读进程读完共享文件
            V(rw) ;  //允许写进程写
        V (mutex) ;  //释放互斥变量 count
    }while(TRUE)
}
void main() 
{
	cobegin
	reader(); writer();
	coend 
}
</code></pre>
</li>
</ol>
<h3 id="6-进程通信">6. 进程通信</h3>
<ol>
<li>
<p>类型</p>
<p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。</p>
<ol>
<li>
<p>共享存储器系统</p>
<ul>
<li>基于共享数据结构的通信方式：通信效率低下，属于低级通信。</li>
<li>基于共享存储区的通信方式：属于高级通信。</li>
</ul>
</li>
<li>
<p>管道(pipe)通信系统</p>
<p>​		一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p>
</li>
<li>
<p>消息传递系统</p>
<p>​		以格式化的消息(Message)为单位。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>
<ul>
<li>直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li>
<li>间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</li>
</ul>
</li>
<li>
<p>客户机－服务器系统</p>
<ul>
<li>套接字Socket
<ul>
<li>基于文件型</li>
<li>基于网络型</li>
</ul>
</li>
<li>远程过程调用和远程方法调用</li>
</ul>
</li>
</ol>
</li>
<li>
<p>消息传递通信的实现方式</p>
<ol>
<li>
<p>直接消息传递系统</p>
<ul>
<li>
<p>直接通信原语</p>
<ul>
<li>
<p>对称寻址方式</p>
<p>send(recei ver, message); 发送一个消息给接收进程</p>
<p>receive(sender, message); 接收 Sender 发来的消息</p>
<p>缺点：进程一旦改变名字，则要找到其所有历史名字以便修改。</p>
</li>
<li>
<p>非对称寻址方式</p>
<p>send(P , message); 发送一个消息给进程</p>
<p>receive (id, message); 接收来自任何进程的消息， id变量可设置为进行通信的发送方进程 id 或名字。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信箱通信</p>
<ul>
<li>
<p>信箱结构</p>
<ul>
<li>信箱头，用以存放有关信箱的描述信息，如信箱标识符、信箱的拥有者、信箱口令、信箱的空格数等；</li>
<li>信箱体，由若干个可以存放消息（或消息头）的信箱格组成，信箱格的数目以及每格的大小是在创建信箱时确定的。</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://s1.ax1x.com/2020/06/08/tWo39S.png" alt="tWo39S.png" loading="lazy"></figure>
</li>
<li>
<p>信箱通信原语</p>
<ul>
<li>
<p>邮箱的创建和撤消</p>
</li>
<li>
<p>消息的发送和接收</p>
<p>进程之间要利用邮箱进行通信时，必须使用共享邮箱。</p>
<p>Send(mailbox, message); 个消息发送到指定邮箱</p>
<p>Receive(mailbox, message); 从指定邮箱中接收一个消息</p>
</li>
</ul>
</li>
<li>
<p>信箱的类型</p>
<ul>
<li>私用邮箱：进程自己创建，所有者可以读取消息，其他进程只能发送。进程结束时，邮箱也随之消失。</li>
<li>公用邮箱：OS 创建，经核准的进程可向其发送消息也可读取给自己的消息。在系统运行期间始终存在。</li>
<li>共享邮箱：进程创建，创建时指明为共享邮箱并指出共享进程的名字，所有者和共享者可以读取给自己的消息。进程结束时，邮箱也随之消失。</li>
</ul>
</li>
<li>
<p>发送进程和接收进程的四种关系</p>
<ul>
<li>一对一关系</li>
<li>多对一关系</li>
<li>一对多关系</li>
<li>多对多关系</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="7-线程threads的基本概念">7. 线程（Threads）的基本概念</h3>
<p>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<ol>
<li>
<p>线程的引入</p>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是<strong>程序执行的最小单元</strong>，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p>
<p>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。</p>
</li>
<li>
<p>线程与进程的比较</p>
<ul>
<li>
<p>调度的基本单位</p>
<p>进程较重，在被调度时执行上下文开销较大。将线程作为调度和分派的基本单位，切换代价较低。</p>
<p>在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一进程中的线程时，必然会引起进程的切换。</p>
</li>
<li>
<p>并发性</p>
<p>进程间，一个进程中的多个/全部线程，不同进程中的线程。</p>
</li>
<li>
<p>拥有资源</p>
<p>线程仅拥有必不可少的保证独立运行的资源，共享该进程的所有资源。</p>
</li>
<li>
<p>独立性</p>
<p>线程间的独立性远远低于进程间的独立性。</p>
</li>
<li>
<p>系统开销</p>
<p>创建和撤销进程的开销远大于线程的开销。</p>
</li>
<li>
<p>支持多处理机系统</p>
<p>单线程进程，该进程只能运行在一个处理机上；多线程进程，可将进程中的多个线程分配到多个处理机上，并行执行。</p>
</li>
</ul>
</li>
<li>
<p>线程的状态和线程控制块</p>
<ol>
<li>
<p>三个状态</p>
<ul>
<li>执行状态，表示线程已获得处理机而正在运行；</li>
<li>就绪状态，指线程已具备了各种执行条件，只须再获得 CPU 便可立即执行；</li>
<li>阻塞状态，指线程在执行中因某事件受阻而处于暂停状态</li>
</ul>
<p>线程间的状态转换与进程间的状态转换相同。</p>
</li>
<li>
<p>线程控制块 TCB</p>
<p>① 线程标识符，为每个线程赋予一个唯一的线程标识符。</p>
<p>② 一组寄存器，程序寄存器等。</p>
<p>③ 线程运行状态，线程此时运行状态。</p>
<p>④ 优先级，描述线程执行的优先程度。</p>
<p>⑤ 线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。</p>
<p>⑥ 信号屏蔽，对某些信号加以屏蔽。</p>
<p>⑦ 堆栈指针，保存局部变量和返回地址。</p>
</li>
<li>
<p>多线程 OS 中的进程属性</p>
<p>① 进程是一个可拥有资源的基本单位。</p>
<p>② 多个线程可并发执行。</p>
<p>③ 进程已不是可执行的实体 。</p>
</li>
</ol>
</li>
</ol>
<h3 id="8-线程的实现">8. 线程的实现</h3>
<p>实现方式</p>
<ol>
<li><strong>以线程为基本调度单位的内核支持线程[与内核紧密相关]</strong></li>
<li><strong>以进程为基本调度单位的用户级线程[与内核无关]</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统学习笔记（一）--  引论]]></title>
        <id>https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/</id>
        <link href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">
        </link>
        <updated>2020-06-08T02:00:09.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
​		操作系统(OS)，是配置在计算机硬件的笫 一层软件，其主要作用是管理这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口便于用户使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
​		操作系统(OS)，是配置在计算机硬件的笫 一层软件，其主要作用是管理这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口便于用户使用。</p>
<!-- more -->
<h3 id="1-操作系统的目标和作用">1. 操作系统的目标和作用</h3>
<ol>
<li>
<p>目标</p>
<ul>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>
<p>OS 作为用户与计算机硬件系统之间的接口</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/08/tRbpSU.png" alt="tRbpSU.png" loading="lazy"></figure>
</li>
<li>
<p>OS 作为计算机系统资源的管理者</p>
</li>
<li>
<p>OS 实现了对计算机资源的抽象</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-操作系统的发展过程">2. 操作系统的发展过程</h3>
<ol>
<li>
<p>未配置操作系统的计算机系统</p>
<ul>
<li>
<p>人工操作方式：手工操作、速度慢、CPU浪费严重。</p>
</li>
<li>
<p>脱机输入/输出方式((Off-Line I/O)：该技术是事先将有用户程序和数据的纸袋装入纸袋输入机，在一台外围机的控制下，把纸带上的数据（程序）输入到磁带上。减少了 CPU 的空闲时间；提高了 I/O 速度。</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/08/tRqP9f.png" alt="tRqP9f.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>单道批处理系统：为实现对作业的连续处理，先把一批作业输入到磁带上，一个接一个的连续处理。注意<strong>在内存中始终只有一道作业</strong>。</p>
<ul>
<li>
<p>特征： 自动性、顺序性、单道性。</p>
</li>
<li>
<p>缺点：系统中的资源得不到充分的利用。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/08/tRqcVA.png" alt="tRqcVA.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>多道批处理系统：用户提交的作业先放在外存上，排成“<strong>后备队列</strong>”。由作业调度程序选择作业进入内存。</p>
<ul>
<li>
<p>特征：多道性、无序性、调度性。</p>
</li>
<li>
<p>优缺点：提高CPU利用率、提高内存和IO利用率、增加系统吞吐量；平均周转时间长、无交互能力。</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/08/tRqq5q.png" alt="tRqq5q.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>分时系统：在一台主机上链接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
<ul>
<li>关键问题：及时接受、及时处理(时间片轮转)。</li>
<li>特征：多路性、独占性、及时性、交互性。</li>
</ul>
</li>
<li>
<p>实时系统：系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<ul>
<li>分类：硬实时任务（对截止时间的要求十分严格）、软实时任务（对截止时间没那么严格）</li>
<li>特征：多路性、独占性、及时性、交互性、可靠性。</li>
</ul>
</li>
<li>
<p>微机操作系统：主要动力来源有不断提高计算机资源的利用率、方便用户、器件的不断更新换代、计算机体系结构的不断发展。每一代计算机几乎都是为了改进上一代计算机的缺点进而产生的，也促进了操作系统的不断发展。<br>
分类可以根据发展历程进行分类。</p>
<ul>
<li>单用户单任务：MS-DOS</li>
<li>单用户多任务：windows95</li>
<li>多用户多任务：UNIX OS</li>
</ul>
</li>
</ol>
<h3 id="3-操作系统的基本特性">3.  操作系统的基本特性</h3>
<ol>
<li><strong>并发性</strong>
<ul>
<li>并行性是指多个时间在同一时刻发生。</li>
<li>并发性是指多个事件在同一时间间隔内发生。<br>
并发性是指一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每个时刻只有一个程序在执行，微观上也是分时交替执行。若有多个处理机，则可以实现并行执行。</li>
<li>并发性是四大特征中，最基础的。</li>
</ul>
</li>
<li>共享性
<ul>
<li>共享是指系统中的资源可供内存中多个并发执行的进程共同使用。</li>
<li>互斥共享：指一段时间内只允许一个进程访问某种资源，也成为临界资源或独占资源。如打印机、磁带机。</li>
<li>同步共享：宏观上允许一段时间内多个进程同时对某资源进行访问。</li>
</ul>
</li>
<li>虚拟性<br>
虚拟是指利用某种技术，把一个物理实体变为若干个逻辑上的对应物。前者物理实体是实际存在的，而后者是用户感觉上的东西。如虚拟内存、虚拟处理机大等。
<ul>
<li>时分复用技术</li>
<li>空分复用技术</li>
</ul>
</li>
<li>异步性<br>
进程是以人们不可预知的速度向前推进的。</li>
</ol>
<h3 id="4-操作系统的主要功能">4. 操作系统的主要功能</h3>
<ol>
<li>
<p>处理机管理功能</p>
<ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度（作业调度、进程调度）</li>
</ul>
</li>
<li>
<p>存储器管理功能</p>
<ul>
<li>内存分配（静态分配方式，动态分配方式）</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充（请求调入、置换）</li>
</ul>
</li>
<li>
<p>设备管理功能</p>
<p>设备管理的主要任务如下： (1) 完成用户进程提出的 I/O 请求，为用户进程分配所需的 I/O 设备，并完成指定的 I/O 操作</p>
<p>(2) 提高 CPU I/O 设备的利用率 提高 I/O 速度，方便用户使用 I/O 设备</p>
<ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
</li>
<li>
<p>文件管理功能</p>
<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读 写管理和保护</li>
</ul>
</li>
<li>
<p>操作系统与用户之间的接口</p>
<ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
</ol>
<h3 id="5-os-结构设计">5. OS 结构设计</h3>
<ol>
<li>
<p>传统操作系统结构</p>
<ul>
<li>无结构操作系统</li>
<li>模块化结构 OS</li>
<li>分层式结构 OS</li>
</ul>
</li>
<li>
<p>现代操作系统的结构</p>
<ul>
<li>微内核结构：足够小的内核、基于客户-服务器模式、应用机制与策略分离原理、采用面向对象技术</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
</feed>