<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qzlu-cyber.github.io/Keasar_Blog</id>
    <title>Keasar`Blog</title>
    <updated>2020-06-04T05:54:41.525Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qzlu-cyber.github.io/Keasar_Blog"/>
    <link rel="self" href="https://qzlu-cyber.github.io/Keasar_Blog/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://qzlu-cyber.github.io/Keasar_Blog/images/avatar.png</logo>
    <icon>https://qzlu-cyber.github.io/Keasar_Blog/favicon.ico</icon>
    <rights>All rights reserved 2020, Keasar`Blog</rights>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（二）]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">
        </link>
        <updated>2020-06-04T04:31:50.000Z</updated>
        <summary type="html"><![CDATA[<p>😉😉😉<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）</a></p>
<h3 id="物理层特性">物理层特性</h3>
<ul>
<li><strong>机械特性</strong></li>
<li><strong>电气特性</strong></li>
<li><strong>功能特性</strong></li>
<li><strong>规程特性</strong></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>😉😉😉<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）</a></p>
<h3 id="物理层特性">物理层特性</h3>
<ul>
<li><strong>机械特性</strong></li>
<li><strong>电气特性</strong></li>
<li><strong>功能特性</strong></li>
<li><strong>规程特性</strong></li>
</ul>
<!-- more -->
<h3 id="数据通信基础知识">数据通信基础知识</h3>
<ol>
<li>
<h4 id="数据通信系统模型">数据通信系统模型</h4>
<ul>
<li>
<p>数据通信系统三部分：<strong>源系统(发送端)、传输系统、目的系统(接收端)</strong></p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/04/twjDlq.png" alt="twjDlq.png" loading="lazy"></figure>
</li>
<li>
<p><strong>模拟信号</strong>：连续信号，表示消息的参数取值是连续的。</p>
</li>
<li>
<p><strong>数字信号</strong>：离散信号，表示消息的参数取值是离散的。</p>
</li>
</ul>
</li>
<li>
<h4 id="信道">信道</h4>
<ul>
<li>按照通信双方信息交互的方式分为：<strong>单工通信</strong>、<strong>半双工通信</strong>、<strong>全双工通信</strong>。</li>
<li><strong>曼切斯特编码产生的信号频率比不归零制高。不归零制没有自同步能力，曼切斯特编码具有自同步能力。</strong></li>
<li>基带信号：来自信源的信号.计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。包含有较多低频成分，需要进行调制。<br>
调制分为：
<ul>
<li>基带调制：对基带信号波形进行变换，仍然是基带信号</li>
<li>带通调制：经过载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号。基本的带通调制方法有：</li>
<li>调幅AM：载波的振幅随基带数字信号而变化。</li>
<li>调频FM：载波的频率随基带数字信号而变化。</li>
<li>调相PM：载波的初始相位随基带数字信号而变化。</li>
<li>正交振幅调制QAM：多元制的振幅相位混合调制方法，信息传输速率更高。</li>
</ul>
</li>
<li>调制解调原因</li>
</ul>
<blockquote>
<p>无线电通信系统：通过空间辐射方式传送信号。<br>
电磁波理论可知：天线尺寸为被辐射信号波长的十分之一或更大些，信号才能有效的被辐射。<br>
对于语音信号：天线尺寸需要在几十公里以上，因此需要调制(语音信号的频率范围为300~3400Hz)。<br>
调制过程：将信号频谱搬移到任何所需的较高频率范围，这就容易以电磁波形式辐射出去。<br>
如果不进行调制，而是把被传送的信号直接辐射出去，那么各电台所发出的信号频率就会相同，他们混在一起，收信者将无法选择所要接收的信号。<br>
调制作用的实质：把各种信号的频谱搬移，使它们互不重叠地占据不同的频率范围，即信号分别托付于不同频率的载波上，接收机可以分离出所需要的频率的信号，不致相互干扰。（实现了多路复用）</p>
</blockquote>
</li>
<li>
<h4 id="信道极限容量">信道极限容量</h4>
<ul>
<li>
<p>码元传输的速率越高，或者信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形失真就越严重。</p>
</li>
<li>
<p>限制码元在信道上的传输速率的因素有：</p>
<ol>
<li>信道能够通过的频率范围<br>
奈氏准则：在任何信道中，码元传输的速率是由上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决成为不可能。</li>
<li>信噪比：信号的平均功率和噪声的平均功率之比(S/N)单位dB<br>
信噪比(dB)=10log10(S/N)(dB)<br>
信道的极限信息传输速率C=Wlog2(1+S/N) (b/s)</li>
</ol>
<p>可以看出：<strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</strong></p>
</li>
<li>
<p>提高信息的传输速率：尽可能的让每一个码元携带更多信息量。</p>
</li>
</ul>
</li>
</ol>
<h3 id="物理层下的传输媒体">物理层下的传输媒体</h3>
<ul>
<li>导向传输媒体：固体媒体(铜线或光纤)。双绞线、同轴电缆、光纤。</li>
<li>非导向传输媒体：指利用无线电波在自由空间传播。</li>
</ul>
<h3 id="信道复用技术">信道复用技术</h3>
<ol>
<li>
<h4 id="频分-时分-统计时分复用">频分、时分、统计时分复用</h4>
<ul>
<li>
<p><strong>频分复用</strong>FDM：所有用户在同样的时间占用不同的带宽资源。</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/04/t0FCDA.png" alt="t0FCDA.png" loading="lazy"></figure>
</li>
<li>
<p><strong>时分复用</strong>TDM：所有用户在不同的时间占用同样的频带宽度。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/04/t0Fegg.png" alt="t0Fegg.png" loading="lazy"></figure>
<p>TDM有时会造成信道利用率不高：</p>
  <img src="https://s1.ax1x.com/2020/06/04/t0eoin.png" alt="t0eoin.png" border="0" />
</li>
<li>
<p><strong>统计时分复用</strong>STDM：TDM的改进，提高信道利用率。</p>
  <div align="center"><img src="https://s1.ax1x.com/2020/06/04/t0e2M8.png" alt="t0e2M8.png" border="0" /></div>
</li>
</ul>
</li>
<li>
<h4 id="波分复用">波分复用</h4>
<ul>
<li><strong>波分复用</strong>WDM：即光的频分复用。</li>
</ul>
</li>
</ol>
  <div align="center"><img src="https://s1.ax1x.com/2020/06/04/t0FUKJ.png" alt="t0FUKJ.png" border="0" /></div>
<p>经过复用器合波后，速率达到8 x 2.5Gbit/s = 20Gbit/s。</p>
<ol start="3">
<li>
<h4 id="码分复用">码分复用</h4>
<ul>
<li>
<p><strong>码分复用</strong>CDM：即<strong>码分多址CDMA</strong>，每一个用户可以在同样的时间使用同样的频带进行通信。</p>
<p>为每个用户分配 m bit 的码片，并且所有的码片<strong>正交</strong>，对于任意两个码片 <em>S</em> (S站的码片向量) 和 <em>T</em> (T站的码片向量) 有</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/04/t0k1Ld.png" alt="t0k1Ld.png" loading="lazy"></figure>
<p>为了方便，取 m=8，设码片 <em>S</em> 为 00011011。在拥有该码片的用户<strong>发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码</strong> 11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/04/t0kUW8.png" alt="t0kUW8.png" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/04/t0k0yQ.png" alt="t0k0yQ.png" loading="lazy"></figure>
<p>其中 <em>S</em>' 为 <em>S</em> 的反码。</p>
<p><strong>任何一个码片向量和该码片向量自己的规格化内积都是1。</strong></p>
<p>利用上面的式子我们知道，当接收端使用码片 <em>S</em> 对接收到的数据进行内积运算时，<strong>结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</strong></p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
</li>
</ul>
</li>
</ol>
<h3 id="宽带接入技术">宽带接入技术</h3>
<ol>
<li>
<h4 id="xdsl技术用数字技术对现有的模拟电话用户线进行改造使它能够承载宽带业务">xDSL技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</h4>
<p>其中，0-4kHz低端频谱留给传统电话使用，高端频谱留给用户上网使用。几种类型:ADSL/HDSL/SDSL/VDSL</p>
<ul>
<li>ADSL技术：非对称数字用户线。ADSL把上行和下行带宽做成不对称的。上行指从用户到ISP,下行指从ISP到用户。用户线两端是调制解调器(DMT).<br>
DMT调制技术采用频分复用。40kHz-1.1MHz的高端频谱划分许多子信道，25个用于上行，249个用于下行。每个信道占据4kHz带宽。ADSL不能保证固定的数据率。</li>
<li>基于ADSL的接入网组成：
<ul>
<li>数字用户线接入复用器DSLAM（包含许多ADSL调制解调器，记为ATU-C和ATU-R）</li>
<li>用户线</li>
<li>用户家的设施</li>
<li>总结：ADSL是借助于在用户线两端安装ADSL调制解调器(即ATU-R和ATU-C)对数字信号进行调制，使得调制后的数字信号的频谱适合在原来的用线上传输。</li>
</ul>
</li>
<li>光纤同轴混合网(HFC网)<br>
HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民带宽接入网。
<ul>
<li>功能：传送CATV、电话业务、数据和其他宽带交互型业务。</li>
<li>特点：
<ol>
<li>HFC网的主干线路采用光纤</li>
<li>HFC网采用结点体系结构：从头端到各个光纤结点用模拟光纤连接，构成星型网。</li>
<li>HFC网具有比CATV网更宽的频谱，且具有双向传输功能</li>
<li>每个家庭要安装一个用户接口盒，其提供三种连接：使用同轴电缆连接到机顶盒再连接到用户的电视机；使用双绞线连接到用户的电话机；使用电缆调制解调器连接到用户的计算机。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="fttx技术光纤到">FTTx技术（光纤到…）</h4>
<ul>
<li>光纤到户FTTH：即将光纤一直铺设到用户家庭。</li>
<li>光纤到大楼FTTB：支持大中型企业、大公司高速率宽带业务需求，比FTTH经济。</li>
<li>光纤到路边FTTC：比较流行。</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（一）]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">
        </link>
        <updated>2020-06-04T03:06:42.000Z</updated>
        <summary type="html"><![CDATA[<p>👻👻👻</p>
<h3 id="互联网概述">互联网概述</h3>
<ul>
<li>计算机网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。计算机、集线器、交换机、路由器都可以是结点。</li>
<li>网络与网络之间通过<strong>路由器</strong>连接成互联网。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>👻👻👻</p>
<h3 id="互联网概述">互联网概述</h3>
<ul>
<li>计算机网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。计算机、集线器、交换机、路由器都可以是结点。</li>
<li>网络与网络之间通过<strong>路由器</strong>连接成互联网。</li>
</ul>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/04/tw57ge.png" alt="tw57ge.png" loading="lazy"></figure>
<h3 id="isp">ISP</h3>
<ul>
<li>互联网服务提供商 <strong>ISP</strong> 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</li>
<li>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。</li>
<li>互联网交换点 <strong>IXP</strong> 允许两个 ISP 直接相连而不用经过第三个 ISP。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/04/tw5qud.png" alt="tw5qud.png" loading="lazy"></figure>
<h3 id="互联网的组成">互联网的组成</h3>
<ol>
<li>
<h4 id="两大块">两大块</h4>
<ul>
<li>边缘部分：所有连接在互联网上的<strong>主机</strong>（又被称为端系统），用户可以直接使用。用来进行通信和资源共享等。</li>
<li>核心部分：由大量的网络和连接这些网络的<strong>路由器</strong>组成，用来为边缘部分的主机提供服务。</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/04/twIkbn.png" alt="twIkbn.png" loading="lazy"></figure>
<ol start="2">
<li>
<h4 id="主机间的通信方式">主机间的通信方式</h4>
<ul>
<li>客户-服务器方式（C/S）：客户即是服务请求方，服务器是服务提供方。</li>
<li>对等连接方式（P2P）：不区分客户和服务器。</li>
</ul>
</li>
<li>
<h4 id="互联网核心部分">互联网核心部分</h4>
<ul>
<li>路由器在核心部分起到特殊作用，任务是转发收到的分组，完成分组交换。</li>
</ul>
<ol>
<li>
<h4 id="电路交换">电路交换</h4>
<ul>
<li>
<p>交换过程必须经过建立连接（占用信道资源）--  通话（一直占用信道资源）--  释放连接（归还通信资源）。</p>
</li>
<li>
<p>在整个通信过程中通话的两个用户始终占用端到端的通信资源。</p>
</li>
</ul>
</li>
<li>
<h4 id="报文交换">报文交换</h4>
<ul>
<li>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</li>
</ul>
</li>
<li>
<h4 id="分组交换">分组交换</h4>
</li>
</ol>
<ul>
<li>分组交换使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了<strong>目的地址</strong>和<strong>源地址</strong>等控制信息。</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/04/twIn8U.png" alt="twIn8U.png" loading="lazy"></figure>
<h3 id="时延">时延</h3>
<p><strong>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</strong></p>
<ol>
<li>
<h4 id="发送时延">发送时延</h4>
<p>主机或路由器发送数据帧所需要的时间。</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/04/twomdI.png" alt="twomdI.png" loading="lazy"></figure>
<p>其中 l 表示数据帧的长度，v 表示发送速率。</p>
</li>
<li>
<h4 id="传播时延">传播时延</h4>
<p>电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/04/twTkt0.png" alt="twTkt0.png" loading="lazy"></figure>
<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。</p>
</li>
<li>
<h4 id="处理时延">处理时延</h4>
<p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据部分等。</p>
</li>
<li>
<h4 id="排队时延">排队时延</h4>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/04/twT6gS.png" alt="twT6gS.png" loading="lazy"></figure>
</li>
<li>
<h4 id="时延带宽积">时延带宽积</h4>
<p>时延带宽积 = 传播时延 x 带宽</p>
<p>链路的时延带宽积被称为以比特为单位的链路长度。</p>
</li>
</ol>
<h3 id="计算机网络体系结构">计算机网络体系结构</h3>
<p>​															<img src="https://s1.ax1x.com/2020/06/04/tw7hse.png" alt="tw7hse.png" loading="lazy"></p>
<ol>
<li>
<p><strong>应用层</strong>：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。<strong>数据单位为报文</strong>。</p>
</li>
<li>
<p><strong>运输层</strong>：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 <strong>TCP，提供面向连接、可靠的数据传输服务</strong>，<strong>数据单位为报文段</strong>；用户数据报协议 <strong>UDP，提供无连接、尽最大努力的数据传输服务</strong>，<strong>数据单位为用户数据报</strong>。</p>
</li>
<li>
<p><strong>网络层</strong>：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层产生的报文段或者用户数据报封装成**分组(IP数据报)**来进行传输。</p>
</li>
<li>
<p><strong>数据链路层</strong>：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组<strong>封装成帧</strong>。</p>
</li>
<li>
<p><strong>物理层</strong>：考虑的是怎样在传输媒体上传输数据<strong>比特流</strong>，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。</p>
<div align="center"><img src="https://s1.ax1x.com/2020/06/04/twbV9P.png" alt="twbV9P.png" border="0" /></div>
</li>
</ol>
<ul>
<li>
<p>TCP/IP体系结构</p>
<p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
</li>
</ul>
<div align="center"><img src="https://s1.ax1x.com/2020/06/04/twXlrT.png" alt="twXlrT.png" border="0" /></div>
<p>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p>
  <div align="center"><img src="https://s1.ax1x.com/2020/06/04/twqzee.png" alt="twqzee.png" border="0" /></div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/centos76-an-zhuang-docker-bing-zai-docker-zhong-li-yong-tomcat-bu-shu-jing-tai-wang-ye/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/centos76-an-zhuang-docker-bing-zai-docker-zhong-li-yong-tomcat-bu-shu-jing-tai-wang-ye/">
        </link>
        <updated>2020-06-03T06:40:59.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="centos76安装docker并在docker中利用tomcat部署静态网页">CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="centos76安装docker并在docker中利用tomcat部署静态网页">CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页</h3>
<!-- more -->
<h4 id="1-安装docker">1. 安装Docker</h4>
<ul>
<li>
<p>更新yum包</p>
<pre><code>yum update
</code></pre>
</li>
<li>
<p>查看是否安装过docker</p>
<pre><code>whereis docker
</code></pre>
</li>
<li>
<p>如果安装过，则删除之前的版本</p>
<pre><code>yum remove docker docker-common docker-selinux docker-engine
</code></pre>
</li>
<li>
<p>设置yum源</p>
<pre><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
</li>
<li>
<p>查看docker版本</p>
<pre><code>yum list docker-ce --showduplicates | sort -r
</code></pre>
</li>
<li>
<p>安装</p>
<pre><code>yum install docker-ce 
</code></pre>
</li>
<li>
<p>启动Docker</p>
<pre><code>systemctl start docker
</code></pre>
</li>
<li>
<p>开机启动</p>
<pre><code>systemctl enable docker
</code></pre>
</li>
<li>
<p>验证安装是否成功</p>
<pre><code>docker version
</code></pre>
<ul>
<li>
<p>如下存在Client和Server则成功</p>
<figure data-type="image" tabindex="1"><img src="X:%5Cclassworks%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5Cdockerversion.png" alt="dockerversion" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
<p>2.Docker常用命令</p>
<pre><code>docker 运行容器命令
docker ps
 
docker 所有容器命令
docker ps -a
 
docker 删除容器命令
docker rm 容器id
 
docker 镜像查看命令
</code></pre>
<p>3.利用Tomcat部署静态网页</p>
<ul>
<li>
<p>拉取Tomcat</p>
<pre><code>docker pull tomcat
</code></pre>
</li>
<li>
<p>启动容器，验证Tomcat服务</p>
<pre><code>docker run -p 8080:8080 tomcat
</code></pre>
</li>
<li>
<p>访问</p>
<p>服务器外网IP:8080即可</p>
<p>如果不行，看是否能ping通或者是服务器端口是否开放</p>
</li>
<li>
<p>将静态页面拷贝到docker中tomcat的webapps下，建议挂载</p>
<ul>
<li>
<p>将Tomcat启动，进入docker中查看命令：</p>
<pre><code>docker exec -it 容器id /bin/bash //容器ID可通过 docker ps命令查询
</code></pre>
</li>
<li>
<p>挂载静态文件</p>
<p>首先将静态资源文件夹上传至云服务器，例如我的上传至了/root下，即SongMove文件夹。下面这条命令即是将静态资源目录映射到容器的/ROOT下</p>
<pre><code>docker run -d -v /root/SongMove/:/usr/local/tomcat/webapps/ROOT/ -p 8080:8080 tomcat:latest
</code></pre>
</li>
</ul>
</li>
</ul>
<p>4.服务器IP:8080访问即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数（上）]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/han-shu-shang/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/han-shu-shang/">
        </link>
        <updated>2020-06-02T13:31:02.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="函数的概念">函数的概念</h2>
<ul>
<li>
<p>对于 js 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p>
</li>
<li>
<p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="函数的概念">函数的概念</h2>
<ul>
<li>
<p>对于 js 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p>
</li>
<li>
<p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p>
</li>
</ul>
<!-- more -->
<ul>
<li>
<p>先看一段代码</p>
<pre><code class="language-javascript">// 这个是我们以前写的一段代码
for (var i = 0; i &lt; 10; i++) {
  console.log(i)
}

// 函数，这个 {} 就是那个 “盒子”
function fn() {
  // 这个函数我们以前写的代码
  for (var i = 0; i &lt; 10; i++) {
    console.log(i)
  }
}
</code></pre>
</li>
</ul>
<h2 id="函数的两个阶段重点">函数的两个阶段（重点）</h2>
<ul>
<li>按照我们刚才的说法，两个阶段就是 <strong>放在盒子里面</strong> 和 <strong>让盒子里面的代码执行</strong></li>
</ul>
<h3 id="函数定义阶段">函数定义阶段</h3>
<ul>
<li>
<p>定义阶段就是我们把代码 <strong>放在盒子里面</strong></p>
</li>
<li>
<p>我们就要学习怎么 <strong>放进去</strong>，也就是书写一个函数</p>
</li>
<li>
<p>我们有两种定义方式 <strong>声明式</strong> 和 <strong>赋值式</strong></p>
</li>
</ul>
<h4 id="声明式">声明式</h4>
<ul>
<li>
<p>使用 <code>function</code> 这个关键字来声明一个函数</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-javascript">function fn() {
  // 一段代码
}
// function: 声明函数的关键字，表示接下来是一个函数了
// fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）
// (): 必须写，是用来放参数的位置（一会我们再聊）
// {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”）
</code></pre>
</li>
</ul>
<h4 id="赋值式">赋值式</h4>
<ul>
<li>
<p>其实就是和我们使用 <code>var</code> 关键字是一个道理了</p>
</li>
<li>
<p>首先使用 <code>var</code> 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-javascript">var fn = function () {
  // 一段代码
}
// 不需要在 function 后面书写函数的名字了，因为在前面已经有了
</code></pre>
</li>
</ul>
<h3 id="函数调用阶段">函数调用阶段</h3>
<ul>
<li>就是让 <strong>盒子里面</strong> 的代码执行一下</li>
<li>让函数执行</li>
<li>两种定义函数的方式不同，但是调用函数的方式都以一样的</li>
</ul>
<h4 id="调用一个函数">调用一个函数</h4>
<ul>
<li>
<p>函数调用就是直接写 <code>函数名()</code> 就可以了</p>
<pre><code class="language-javascript">// 声明式函数
function fn() {
  console.log('我是 fn 函数')
}

// 调用函数
fn()

// 赋值式函数
var fn2 = function () {
  console.log('我是 fn2 函数')
}

// 调用函数
fn()
</code></pre>
<ul>
<li>注意： <strong>定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行</strong></li>
</ul>
</li>
</ul>
<h4 id="调用上的区别">调用上的区别</h4>
<ul>
<li>
<p>虽然两种定义方式的调用都是一样的，但是还是有一些区别的</p>
</li>
<li>
<p>声明式函数： 调用可以在 <strong>定义之前或者定义之后</strong></p>
<pre><code class="language-javascript">// 可以调用
fn()

// 声明式函数
function fn() {
  console.log('我是 fn 函数')
}

// 可以调用
fn()
</code></pre>
</li>
<li>
<p>赋值式函数： 调用只能在 <strong>定义之前</strong></p>
<pre><code class="language-javascript">// 会报错
fn()

// 赋值式函数
var fn = function () {
  console.log('我是 fn 函数')
}

// 可以调用
fn()
</code></pre>
</li>
</ul>
<h2 id="函数的参数重点">函数的参数（重点）</h2>
<ul>
<li>
<p>我们在定义函数和调用函数的时候都出现过 <code>()</code></p>
</li>
<li>
<p>现在我们就来说一下这个 <code>()</code> 的作用</p>
</li>
<li>
<p>就是用来放参数的位置</p>
</li>
<li>
<p>参数分为两种 <strong>行参</strong> 和 <strong>实参</strong></p>
<pre><code class="language-javascript">// 声明式
function fn(行参写在这里) {
  // 一段代码
}

fn(实参写在这里)

// 赋值式函数
var fn = function (行参写在这里) {
  // 一段代码
}
fn(实参写在这里)
</code></pre>
</li>
</ul>
<h3 id="行参和实参的作用">行参和实参的作用</h3>
<ol>
<li>
<p>行参</p>
<ul>
<li>
<p>就是在函数内部可以使用的变量，在函数外部不能使用</p>
</li>
<li>
<p>每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范）</p>
</li>
<li>
<p>多个单词之间以 <code>,</code> 分隔</p>
<pre><code class="language-javascript">// 书写一个参数
function fn(num) {
  // 在函数内部就可以使用 num 这个变量
}

var fn1 = function (num) {
	// 在函数内部就可以使用 num 这个变量
}

// 书写两个参数
function fun(num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}

var fun1 = function (num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}
</code></pre>
</li>
<li>
<p>如果只有行参的话，那么在函数内部使用的值个变量是没有值的，也就是 <code>undefined</code></p>
</li>
<li>
<p><strong>行参的值是在函数调用的时候由实参决定的</strong></p>
</li>
</ul>
</li>
<li>
<p>实参</p>
<ul>
<li>
<p>在函数调用的时候给行参赋值的</p>
</li>
<li>
<p>也就是说，在调用的时候是给一个实际的内容的</p>
<pre><code class="language-javascript">function fn(num) {
  // 函数内部可以使用 num 
}

// 这个函数的本次调用，书写的实参是 100
// 那么本次调用的时候函数内部的 num 就是 100
fn(100) 

// 这个函数的本次调用，书写的实参是 200
// 那么本次调用的时候函数内部的 num 就是 200
fn(200)
</code></pre>
</li>
<li>
<p><strong>函数内部的行参的值，由函数调用的时候传递的实参决定</strong></p>
</li>
<li>
<p><strong>多个参数的时候，是按照顺序一一对应的</strong></p>
<pre><code class="language-javascript">function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 函数本次调用的时候，书写的参数是 100 和 200
// 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200
fn(100, 200)
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="参数个数的关系">参数个数的关系</h3>
<ol>
<li>
<p>行参比实参少</p>
<ul>
<li>
<p>因为是按照顺序一一对应的</p>
</li>
<li>
<p>行参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值</p>
<pre><code class="language-javascript">function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 本次调用的时候，传递了两个实参，100 200 和 300
// 100 对应了 num1，200 对应了 num2，300 没有对应的变量
// 所以在函数内部就没有办法依靠变量来使用 300 这个值
fn(100, 200, 300)
</code></pre>
</li>
</ul>
</li>
<li>
<p>行参比实参多</p>
<ul>
<li>
<p>因为是按照顺序一一对应的</p>
</li>
<li>
<p>所以多出来的行参就是没有值的，就是 <code>undefined</code></p>
<pre><code class="language-javascript">function fn(num1, num2, num3) {
  // 函数内部可以使用 num1 num2 和 num3
}

// 本次调用的时候，传递了两个实参，100 和 200
// 就分别对应了 num1 和 num2
// 而 num3 没有实参和其对应，那么 num3 的值就是 undefined
fn(100, 200)
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="函数的return重点">函数的return（重点）</h2>
<ul>
<li>return 返回的意思，其实就是给函数一个 <strong>返回值</strong> 和 <strong>终断函数</strong></li>
</ul>
<h3 id="终断函数">终断函数</h3>
<ul>
<li>
<p>当我开始执行函数以后，函数内部的代码就会从上到下的依次执行</p>
</li>
<li>
<p>必须要等到函数内的代码执行完毕</p>
</li>
<li>
<p>而 <code>return</code> 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行</p>
<pre><code class="language-javascript">function fn() {
  console.log(1)
  console.log(2)
  console.log(3)
  
  // 写了 return 以后，后面的 4 和 5 就不会继续执行了
  return
  console.log(4)
  console.log(5)
}

// 函数调用
fn()
</code></pre>
</li>
</ul>
<h3 id="返回值">返回值</h3>
<ul>
<li>
<p>函数调用本身也是一个表达式，表达式就应该有一个值出现</p>
</li>
<li>
<p>现在的函数执行完毕之后，是不会有结果出现的</p>
<pre><code class="language-javascript">// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3
console.log(1 + 2) // 3

function fn() {
  // 执行代码
}

// fn() 也是一个表达式，这个表达式就没有结果出现
console.log(fn()) // undefined
</code></pre>
</li>
<li>
<p><code>return</code> 关键字就是可以给函数执行完毕一个结果</p>
<pre><code class="language-javascript">function fn() {
  // 执行代码
  return 100
}

// 此时，fn() 这个表达式执行完毕之后就有结果出现了
console.log(fn()) // 100
</code></pre>
<ul>
<li>我们可以在函数内部使用 <code>return</code> 关键把任何内容当作这个函数运行后的结果</li>
</ul>
</li>
</ul>
<h2 id="函数的优点">函数的优点</h2>
<ul>
<li>函数就是对一段代码的封装，在我们想调用的时候调用</li>
<li>函数的几个优点
<ol>
<li>封装代码，使代码更加简洁</li>
<li>复用，在重复功能的时候直接调用就好</li>
<li>代码执行时机，随时可以在我们想要执行的时候执行</li>
</ol>
</li>
</ul>
<h2 id="预解析重点">预解析（重点）</h2>
<ul>
<li><strong>预解析</strong> 其实就是聊聊 js 代码的编译和执行</li>
<li>js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码</li>
<li>也就是说，我们的 js 代码在运行的时候，会经历两个环节 <strong>解释代码</strong> 和 <strong>执行代码</strong></li>
</ul>
<h3 id="解释代码">解释代码</h3>
<ul>
<li>
<p>因为是在所有代码执行之前进行解释，所以叫做 <strong>预解析（预解释）</strong></p>
</li>
<li>
<p>需要解释的内容有两个</p>
<ul>
<li>声明式函数
<ul>
<li>在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数</li>
</ul>
</li>
<li><code>var</code> 关键字
<ul>
<li>在内存中先声明有一个变量名</li>
</ul>
</li>
</ul>
</li>
<li>
<p>看下面一段代码</p>
<pre><code class="language-javascript">fn()
console.log(num)

function fn() {
  console.log('我是 fn 函数')
}

var num = 100
</code></pre>
</li>
<li>
<p>经过预解析之后可以变形为</p>
<pre><code class="language-javascript">function fn() {
  console.log('我是 fn 函数')
}
var num

fn()
console.log(num)
num = 100
</code></pre>
</li>
<li>
<p>赋值是函数会按照 <code>var</code> 关键字的规则进行预解析</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/hello-gridea/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>