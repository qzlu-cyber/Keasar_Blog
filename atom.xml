<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qzlu-cyber.github.io/Keasar_Blog</id>
    <title>Keasar`Blog</title>
    <updated>2020-06-04T12:01:58.070Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qzlu-cyber.github.io/Keasar_Blog"/>
    <link rel="self" href="https://qzlu-cyber.github.io/Keasar_Blog/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://qzlu-cyber.github.io/Keasar_Blog/images/avatar.png</logo>
    <icon>https://qzlu-cyber.github.io/Keasar_Blog/favicon.ico</icon>
    <rights>All rights reserved 2020, Keasar`Blog</rights>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（三）--  数据链路层]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/">
        </link>
        <updated>2020-06-04T11:53:32.000Z</updated>
        <summary type="html"><![CDATA[<p>😀<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）--  计算机网络概述</a></p>
<p>😃<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a></p>
<p>😄数据链路层使用的信道有两种类型：</p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>😀<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）--  计算机网络概述</a></p>
<p>😃<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a></p>
<p>😄数据链路层使用的信道有两种类型：</p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<!-- more -->
<h3 id="使用点对点信道的数据链路层">使用点对点信道的数据链路层</h3>
<ol>
<li>
<p>数据链路和帧</p>
<ul>
<li>
<p><strong>链路</strong> ：从一个结点到相邻结点的一段物理线路。</p>
</li>
<li>
<p><strong>数据链路</strong> ：把实现这些协议的硬件和软件加载链路上。<br>
现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
</li>
<li>
<p><strong>帧</strong>：点对点信道的数据链路层的协议数据单元。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/04/t05kPf.png" alt="t05kPf.png" loading="lazy"></figure>
<ul>
<li><strong>点对点信道通信时的主要步骤</strong>：
<ol>
<li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li>
<li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li>
<li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>数据链路层三个基本问题：</p>
<ol>
<li>
<p>封装成帧</p>
<p>就是在一段数据的前后分别<strong>添加首部</strong>（帧开始符 SOH 01）和<strong>尾部</strong>（帧结束符 EOT 04），然后就构成了一个<strong>帧</strong>。（数据部分 &lt;= 长度限制 MTU）首部和尾部的一个重要作用就是进行帧定界。<br>
<strong>帧定界是分组交换的必然要求</strong>。</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/04/t0IK6e.png" alt="t0IK6e.png" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/04/t0IJtP.png" alt="t0IJtP.png" loading="lazy"></figure>
</li>
<li>
<p>透明传输</p>
<p>为了达到透明传输（即传输的数据部分不会因为包含SOH和EOT而出错），在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制1B)<br>
<strong>透明传输避免消息符号与帧定界符号相混淆</strong>。</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/04/t0IxHA.png" alt="t0IxHA.png" loading="lazy"></figure>
</li>
<li>
<p>差错检测</p>
<p>现实通信链路中比特在传输中会产生差错，传输错误的比特占比称为<strong>误码率BER</strong>，为了保证可靠性，通常通过<strong>循环冗余检验CRC</strong>来做差错检测。<br>
<strong>差错检测防止无效数据帧浪费后续路由上的传输和处理资源</strong>。</p>
<p><strong>循环冗余检验CRC</strong>：</p>
<p>​		在发送端将数据分组，每组 <em>k</em> bit，在待传送数据 <em>M</em> (<em>k</em> bit) 后添加 <em>n</em> 位冗余码，构成一个帧发送出去，因此一共发送 <em>k+n</em> bit。</p>
<p>​		利用<strong>模二运算</strong>（不进位，不借位）计算 <em>2^n x M / P</em>, 即在待传送数据 <em>M</em> 后加 n 个0作为被除数，除以商定好的除数 <em>P</em>（比 n 多一位），得到的</p>
<p>余数 <em>R</em> （比 <em>n</em> 少一位）即为冗余码，将其拼接到数据 <em>M</em> 后发送出去。为了进行检错而添加的冗余码常称为帧检验序列 <em>FCS</em>。</p>
<p>​		在接收端把接收到的数据以帧为单位进行 CRC 检验：把收到的每一个帧都除以同样的 除数 <em>P</em>（模二运算），然后检查得到的余数 <em>R</em> 如果在传输过程中<strong>无差错，那么经过 CRC 检验后得出的余数肯定是0</strong>。</p>
<p>​		若 <em>M</em> = 101001(即<em>k</em> = 6)，除数 <em>P</em> = 1101, 还可表示为 <em>P(X) = X^3 + X^2 + 1</em>，此时被除数 <em>2^n x M</em> 为101001000除以 <em>P</em> 的余数 <em>R</em> 为001。因此加上 <em>FCS</em> 后发送的帧是 101001001。接收端被除数即为 101001001，除以除数 <em>P</em> 得到余数 <em>R</em>。若 <em>R</em> = 0，帧无错，接受；若 <em>R</em> ≠ 0，帧出错(无法判断哪一位出错)，丢弃。</p>
<p><strong>在数据链 路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</strong></p>
<p>对于通信质量良好的有线传输链路，不要求数据链路层向上提供可靠传输的服务。改正差错的任务就由上层协议（例如，运输层的 TCP 协议）来完成。 对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</p>
</li>
</ol>
</li>
</ol>
<h3 id="点对点协议-ppp">点对点协议 PPP</h3>
<h5 id="ppp-协议就是用户-计算机和-isp-进行通信时所使用的数据链路层协议">PPP 协议就是用户 计算机和 ISP 进行通信时所使用的数据链路层协议。</h5>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/04/tBaXtI.png" alt="tBaXtI.png" loading="lazy"></figure>
<!-- more -->
<!-- more -->
<p>在 TCP/IP 协议族中，可靠传输由运输层的 TCP 协议负责，因此数据链路层的 PPP 议不需要进行纠错，不需要设置序号，也不需要进行流量控制。 PPP 协议不支待多点线路 （即一个主站轮流和链路上的多个从站进行通信），而<strong>只支持点对点的链路通信</strong>。此外， PPP 协议<strong>只支持全双工链路</strong>。</p>
<ol>
<li>
<p>PPP 协议的组成</p>
<ul>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>链路控制协议 LCP (Link Control Protocol)，用来建立、测试、配置数据链路连接。</li>
<li>网络控制协议 NCP (Network Control Protocol)，用来支持不同的网络层协议。</li>
</ul>
</li>
<li>
<p>PPP 协议帧格式</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/04/tBPn9U.png" alt="tBPn9U.png" loading="lazy"></figure>
<p>若出现连续两个标志字段，就表示这是一个空帧，应当丢弃。</p>
<ul>
<li>首部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的)。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的开始或结束。</li>
<li>首部中的地址字段A规定为0xFF(即11111111)，没有携带PPP协议帧的信息。</li>
<li>首部中的控制字段C规定为0x03(即00000011)，没有携带PPP协议帧的信息。</li>
<li>首部中的2字节的协议字段：<br>
(1) 当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。<br>
(2) 当协议字段为0xC021时，PPP帧的信息字段就是PPP链路控制协议LCP的数据。<br>
(3) 当协议字段为0x8021时，PPP帧的信息字段就是网络层的控制数据。</li>
<li>信息部分不超过1500字节。</li>
<li>尾部中的第一个字段(2个字节)是使用CRC的帧检验序列FCS。</li>
</ul>
<p>透明传输的实现方法：</p>
<ul>
<li>当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。</li>
</ul>
<p>字节填充——PPP使用异步传输</p>
<ul>
<li>当 PPP 用在异步传输时，就使用一种特殊的字符填充法：将每一个 0x7E字节变为(0x7D, 0x5E)，0x7D转变成为(0x7D, 0x5D)。ASCII 码的控制字符（即数值小于 0x20 的字符），则在前面要加入0x7D，同时将该字符的编码加以改变。</li>
</ul>
<p>零比特填充——PPP使用同步传输</p>
<ul>
<li>只要发现有5个连续的1，则立即填入一个0。接收端把5个连续的1后的0比特删除。</li>
</ul>
</li>
<li>
<p>PPP 协议工作状态</p>
<p><strong>链路静止  --  建立物理层  --  链路建立  --  PC发LCP  --  NCP分配IP地址  --  链路打开，网络层建立。（释放时倒过来）</strong></p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/04/tBFzh6.png" alt="tBFzh6.png" loading="lazy"></figure>
</li>
</ol>
<h3 id="使用广播信道的数据链路层">使用广播信道的数据链路层</h3>
<h5 id="广播信道可以进行一对多的通信局域网具有广播功能局域网上的主机可共享连接在局-域网上的各种硬件和软件资源">广播信道可以进行一对多的通信，局域网具有广播功能，局域网上的主机可共享连接在局 域网上的各种硬件和软件资源。</h5>
<ol>
<li>
<p>局域网的数据链路层（局域网的数据链路层被拆分为了两个子层）</p>
<ul>
<li><strong>逻辑链路控制LLC子层</strong>：与传输媒体无关。</li>
<li><strong>媒体接入控制MAC子层</strong>：与接入到传输媒体有关的内容都放在 MAC 子层，和局域网都对 LLC 子层来说是透明的。</li>
</ul>
</li>
<li>
<p>适配器（网卡）的作用</p>
<p>包含了***数据链路层***及***物理层***这两个层次的功能。</p>
<figure data-type="image" tabindex="8"><img src="https://s1.ax1x.com/2020/06/04/tBAyLQ.png" alt="tBAyLQ.png" loading="lazy"></figure>
</li>
<li>
<p><strong>CSMA/CD 协议</strong></p>
<p>仅当数据帧中的目的地址与适配器 ROM 中存放的硬件地址(MAC 地址)一致时，该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧就丢弃。</p>
<p>以太网采用 CSMA/CD协议(<em><strong>载波监听多点接入／碰撞检测</strong></em>) 的方式来协调总线上各计算机的工作。具有两个特点：</p>
<ul>
<li>提供的服务是尽最大努力的交付，即不可靠的交付。</li>
<li>双向交替通信（半双工）。</li>
</ul>
<h5 id="csmacd协议的要点">CSMA/CD协议的要点：</h5>
<ul>
<li>
<p>**“多点接入”**就是计算机以多点接入（动态媒体接入控制）的方式连接在一根总线上。</p>
</li>
<li>
<p>**“载波监听”**就是”检测信道”，不管在发送前，还是在发送中，每个站都必须不停地检测信道。在发送前检测信道，是为了获得发送权。在发送中检测信道，是为了及时发现有 没有其他站的发送和本站发送的碰撞。即碰撞检测。</p>
</li>
<li>
<p>**“碰撞检测”**就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
</li>
</ul>
<p>把总线上的单程端到端传播时延记为 <em>τ</em> ，A 发送数据后，最迟要经过 <em>2τ</em> 才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。</p>
<figure data-type="image" tabindex="9"><img src="https://s1.ax1x.com/2020/06/04/tBZtZ4.png" alt="tBZtZ4.png" loading="lazy"></figure>
<p>电磁波在 1km 电缆的传播时延约为 <em>5µs</em>。</p>
<p>以太网的端到端往返时间 <em>2τ</em> 称为<em><strong>争用期***，又叫</strong>碰撞窗口</em>* 。<strong>经过争用期这 段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</strong></p>
<p>以太网使用<strong>截断二进制指数退避算法</strong>来确定碰撞后<strong>重传</strong>的时机。</p>
<ul>
<li>
<p>协议规定了基本退避时间为争用期 <em>2τ</em>, 具体的争用期时间是 <em><strong>51.2 µs</strong></em> 。对于 10 Mbit/s 以太网，在争用期内可发送 512 bit, 即 64字节。也可以说争用期是 512 比特时间。可以直接使用<strong>比特</strong>作为争用期的单位。争用期是 512bit, 即争用期是发送 512bit 所需的时间。</p>
</li>
<li>
<p>从 <em>[0,1, …，（2k -1)]</em> 中随机取出一个数，记为 <em>r</em> 。重传应推后的时间就是 <em><strong>r 倍的争用期</strong></em>。</p>
<div align="center">k=Min［重传次数， 10]</div>
</li>
<li>
<p>当重传达 16 次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突），则丢弃该帧，并向高层报告。</p>
</li>
</ul>
<p>最短帧长 64 字节，即 512 bit 。如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于 64 字节。<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</p>
<h5 id="强化碰撞">强化碰撞：</h5>
<p>​		当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的<em>人为干扰信号</em>，以便让所有用户都知道现在已经发生了碰撞。</p>
<figure data-type="image" tabindex="10"><img src="https://s1.ax1x.com/2020/06/04/tBnhWR.png" alt="tBnhWR.png" loading="lazy"></figure>
<p>​		总线被占用的时间是 <em>TB+ TJ + τ</em>。</p>
<p><strong>规定帧间最小间隔为 9.6 µs</strong>, 相当于 96 比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
<h5 id="总结">总结：</h5>
<div align="center"><img src="https://s1.ax1x.com/2020/06/04/tBuw7D.md.png" alt="tBuw7D.png" border="0" /></div>
</li>
<li>
<h5 id="以太网的信道利用率">以太网的信道利用率</h5>
<p><em>a</em> 是以太网单程端到端时延 <em>2τ</em> 与帧的发送时间 <em>To</em> 之比：</p>
<figure data-type="image" tabindex="11"><img src="https://s1.ax1x.com/2020/06/04/tBMVs0.png" alt="tBMVs0.png" loading="lazy"></figure>
<p>当 a -&gt; 0 时表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数 <em>a</em> 越大，表明争用期所占的比例越大，使得信道利用率明显降低。当数据率一定时，以太网的连线的长度受到限制（否则 <em>τ</em> 的数值 会太大），同时以太网的帧长不能太短（否则 <em>τ</em> 的值会太小，使 <em>To</em> 值太大）。</p>
<figure data-type="image" tabindex="12"><img src="https://s1.ax1x.com/2020/06/04/tBQccR.png" alt="tBQccR.png" loading="lazy"></figure>
<p>只有当参数 <em>a</em> 远小于 1 才能得到尽可能高的极限信道利用率。</p>
</li>
</ol>
<h3 id="以太网的mac层">以太网的MAC层</h3>
<ul>
<li>
<p>MAC地址<br>
<strong>MAC地址</strong>又叫做硬件地址或物理地址，实际上就是适配器地址或适配器标识符EUI-48。高位24位：注册管理机构 RA，组织唯一标识符 OUI，低位24位：由厂家自行指派，称为扩展标识符。</p>
<p>路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p>
</li>
<li>
<p>MAC帧的格式</p>
<figure data-type="image" tabindex="13"><img src="https://s1.ax1x.com/2020/06/04/tBGEQJ.png" alt="tBGEQJ.png" loading="lazy"></figure>
<p>以太网V2的MAC帧由五个字段组成。前两个字段分别为6字长的目标地址和源地址字段。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。后面数据字段46~1500字节，帧检验序列FCS字段4个字节（使用 CRC 检验）。</p>
<p><em>接收方可以很容易地通过发送方网络适配器的接口上的电压是否变化找到以太网帧的结束位置</em>。在这个位置往前数 4 字节 (FCS 字段长度是 4 字节），就能确定数据字段的结束位置。因此MAC帧首部中不需要帧长度字段。</p>
<p>当数据字段的长度小千 46 字节时， MAC 子层就会在数据字段的后面加入一个整数字节的<em>填充字段</em>，以保证以太网的 MAC 帧长不小于 64 字节。</p>
<p>为了接收端迅速实现位同步，从 MAC 子层向下传到物理层时还要在帧的前面插入8字节（由硬件生成），它由两个字段构成。</p>
<ul>
<li>第一个字段是 个字节的前同步码 (1 交替码），它的作用是“实现位同步”（比特同步）。</li>
<li>第二个字段是帧开始定界符，定义为 10101011 。它的前六位的作用和前同步码一样，最后的两个连续1的就是告诉接收端适配器： “MAC 帧的信息马上就要来了，请适配器注意接收'。MAC 帧的 FCS 字段的检验范围不包括前同步码和帧开始定界符。</li>
</ul>
<p>无效的 MAC 帧：</p>
<ul>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>收到的帧的 MAC 客户数据字段的长度不在 46 ~ 1500 字节之间。</li>
</ul>
<p><strong>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong></p>
</li>
</ul>
<h3 id="扩展的以太网">扩展的以太网</h3>
<h5 id="扩展的以太网在网络层看来仍然是一个网络">扩展的以太网在网络层看来仍然是一个网络。</h5>
<ol>
<li>
<p>在物理层扩展以太网</p>
<p>扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光纤）和一对光纤调制解调器。</p>
<p>光纤调制解调器的作用就是进行<em>电信号和光信号的转换</em>。</p>
<figure data-type="image" tabindex="14"><img src="https://s1.ax1x.com/2020/06/04/tBYkr9.png" alt="tBYkr9.png" loading="lazy"></figure>
<p>优点：</p>
<ul>
<li>跨网络通信。</li>
<li>扩大了以太网覆盖的地理范围。</li>
</ul>
<p>缺点：</p>
<ul>
<li>扩大了碰撞域。</li>
<li>不同的局域网使用不同的以太网技术（如数据率不同），那么就不可能用集线器将它们互连起来（速率向下兼容）。</li>
</ul>
</li>
<li>
<p>在数据链路层扩展以太网</p>
<h5 id="网桥自学习算法">网桥（自学习算法）</h5>
<h5 id="以太网交换机第二层交换机-即多接口网桥强调这种交换机工作在数据链路层">以太网交换机（第二层交换机 ），即多接口网桥，强调这种交换机工作在数据链路层。</h5>
<ul>
<li>
<p>特点</p>
<ol>
<li>全双工方式通信。</li>
<li>并行。</li>
<li>相互通信的主机都是独占传输媒体，无碰撞地传输数据。</li>
<li>接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。</li>
</ol>
</li>
<li>
<p>自学习功能</p>
<figure data-type="image" tabindex="15"><img src="https://s1.ax1x.com/2020/06/04/tBt5p8.png" alt="tBt5p8.png" loading="lazy"></figure>
<p>​		A 先向 B 发送一帧，从接口 1 进入到交换机。交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧（在 MAC 地址这一列中，找不到目的地址为 B 的项目）。然后，交换机把这个帧的源地址 A 和接口 1 写入交换表中并向除接口,以外的所有接口广播这个帧。C 和 D 丢弃该帧，因为目的地址不对。只有 B 才收下这个目的地址正确的帧。此即为<strong>过滤</strong>。</p>
<p>​		以后不管从哪一个接口收到帧，只要其目的地 址是 A, 就应当把收到的帧从接口 1 转发出去。</p>
<p>​		B 向 A 发送帧时，交换机把这个帧的源地址 B 和接口 3 写入交换表中，此时不再广播，因为交换表中已经存在 A 的地址。</p>
</li>
</ul>
</li>
<li>
<p>虚拟局域网VLAN</p>
<p>每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN，而与物理位置无关。</p>
<figure data-type="image" tabindex="16"><img src="https://s1.ax1x.com/2020/06/04/tBUZan.png" alt="tBUZan.png" loading="lazy"></figure>
<p>VLAN 标记的前两个字节总是设置为 0x8100 （即二进制的 10000001 00000000) ，称为 IEEE 802.1Q 标记类型。</p>
<p>VLAN 标识符 VID(VLANID) ，它唯一地标志了这个以太网帧属于哪一个 VLAN。</p>
<p>由于用于 VLAN 的以太网帧的首部增加了 4 个字节，因此以太网的最大帧长从原来的 1518 字节 (1500 字节的数据加上 18 字节的首部）变为 1522 字节。</p>
</li>
</ol>
<h3 id="高速以太网">高速以太网</h3>
<p>此部分转载自CSDN，<a href="%5Bhttps://blog.csdn.net/KnightOnHourse/article/details/80198611?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159127115919725219954270%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159127115919725219954270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-80198611.ecpm_v1_rank_ctr_v1&amp;utm_term=%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91%5D(https://blog.csdn.net/KnightOnHourse/article/details/80198611?ops_request_misc=%7B%22request%5Fid%22%3A%22159127115919725219954270%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=159127115919725219954270&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-80198611.ecpm_v1_rank_ctr_v1&amp;utm_term=%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91)">原文地址</a>（如侵删）</p>
<div class="htmledit_views prism-atom-one-light" id="content_views">
                                            <div class="blogpost-body"><p><strong>1. 100M以太网</strong></p><p align="center">快速以太网（100M）标准</p><div align="center"><div class="table-box"><table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td valign="top" width="95"><p align="center">名称</p></td><td valign="top" width="81"><p align="center">传输介质</p></td><td valign="top" width="130"><p align="center">网段最大长度</p></td><td valign="top" width="360"><p align="center">特点</p></td></tr><tr><td valign="top" width="95"><p align="center">100BASE-TX</p></td><td valign="top" width="81"><p align="center">铜缆</p></td><td valign="top" width="130"><p align="center">100m</p></td><td valign="top" width="360"><p align="left">两对UTP5类线或屏蔽双绞线</p></td></tr><tr><td valign="top" width="95"><p align="center">100BASE-T4</p></td><td valign="top" width="81"><p align="center">铜缆</p></td><td valign="top" width="130"><p align="center">100m</p></td><td valign="top" width="360"><p align="left">四对UTP3类线或5类线</p></td></tr><tr><td valign="top" width="95"><p align="center">100BASE-FX</p></td><td valign="top" width="81"><p align="center">光纤</p></td><td valign="top" width="130"><p align="center">2000m</p></td><td valign="top" width="360"><p align="left">两根光纤，发送和接收各用一根，全双工，长距离</p></td></tr></tbody></table></div></div><p>（1）100BASE-T是在双绞线上传送100Mb/s基带信号的星型拓扑的以太网，仍使用IEEE802.3的CSMA/CD协议，它又称为快速以太网（FastEthernet）</p><p>（2）使用交换机组建的100BASE-T以太网，可在全双工方式下工作而无冲突发生。因此，<span style="color:#ff00ff;"><strong>CSMA/CD协议对全双工方式工作的快速以太网是不起作用的</strong></span>。<span style="color:#ff0000;"><strong>因为其帧格式和以太网一样</strong></span>，所以依然称<span style="color:#ff0000;"><strong>交换机组成的网络为以太网</strong></span>。</p><p>（3）以太网的最短帧与带宽和链路长度有关。<span style="color:#ff0000;"><strong>100M以太网</strong></span>比10M以太网速率提高10位，要想和10M以太网兼容，就要确保最短帧也是64字节，那就将电缆最大长度由1000m降到<span style="color:#0000ff;"><strong>100m</strong></span>，因此以太网的争用期依然是51.2μs，最短帧依然是64字节。</p><p><strong>2. 吉比特以太网</strong></p><p align="center">吉比特以太网（1000M）标准</p><div align="center"><div class="table-box"><table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td valign="top" width="95"><p align="center">名称</p></td><td valign="top" width="81"><p align="center">传输介质</p></td><td valign="top" width="130"><p align="center">网段最大长度</p></td><td valign="top" width="360"><p align="center">特点</p></td></tr><tr><td valign="top" width="95"><p align="center">1000BASE-SX</p></td><td valign="top" width="81"><p align="center">光缆</p></td><td valign="top" width="130"><p align="center">550m</p></td><td valign="top" width="360"><p align="left">多模光纤（10和62.5μm）</p></td></tr><tr><td valign="top" width="95"><p align="center">1000BASE-LX</p></td><td valign="top" width="81"><p align="center">光缆</p></td><td valign="top" width="130"><p align="center">5000m</p></td><td valign="top" width="360"><p align="left">单模光纤（10μm）、多模光纤（50和62.5μm）</p></td></tr><tr><td valign="top" width="95"><p align="center">1000BASE-CX</p></td><td valign="top" width="81"><p align="center">铜线</p></td><td valign="top" width="130"><p align="center">25m</p></td><td valign="top" width="360"><p align="left">使用两对屏蔽双绞线电缆STP</p></td></tr><tr><td valign="top" width="95"><p align="center">1000BASE-T</p></td><td valign="top" width="81"><p align="center">铜线</p></td><td valign="top" width="130"><p align="center">100m</p></td><td valign="top" width="360"><p align="left">使用四对UTP5类线</p></td></tr></tbody></table></div></div><p>（1）吉比特（1000M）以太网的特点</p><p>　　①允许在1Gb/s下<span style="color:#0000ff;"><strong>全双工和半双工</strong></span>两种方式下工作。</p><p>　　②使用IEEE802.3协议规定的帧格式</p><p>　　③在<span style="color:#ff0000;"><strong>半双工方式下使用CSMA/CD协议</strong>（<strong>全双工方式不需要使用CSMA/CD协议</strong>）</span></p><p>　　④与10BASE-T和100BASE-T技术向后兼容。</p><p>（2）“载波延伸”</p><p align="center"><img src="https://images2015.cnblogs.com/blog/772759/201706/772759-20170610200251293-205136001.png" alt="" height="235" width="658">&nbsp;</p><p>　　①吉比特以太网工作<span style="color:#ff0000;"><strong>在半双工时</strong></span>，就必须进行碰撞检测。数据速率提高了，要想和10M以太网兼容，就要确保最短帧也是64字节，这只能减少最大电缆长度，<span style="color:#0000ff;"><strong>以太网最大电缆就要缩短到10m</strong></span>，短到几乎没有实用价值。</p><p>　　②吉比特以太网<span style="color:#ff0000;"><strong>为了增加最大传输距离</strong>，<strong>将最短帧由64字节增加到512字节</strong></span>。</p><p>　　③如果数据帧不超过512字节，则在<span style="color:#ff00ff;"><strong>FCS域后面添加“载波延伸”域</strong></span>，当主机发送完短数据帧后，继续发送载波延伸信号，冲突信号传回来时，发送端就能感知到了。</p><p>（3）分组突发</p><p align="center"><img src="https://images2015.cnblogs.com/blog/772759/201706/772759-20170610200305403-444680035.png" alt="" height="251" width="756">&nbsp;</p><p>　　①如果发送的数据帧都是小于64字节的<span style="color:#ff0000;"><strong>短报文</strong></span>时，那么<span style="color:#ff00ff;"><strong>链路的利用率就会很低</strong></span>，因为“载波延伸”域占用了大量的带宽。于是，千兆以太网引入了“分组突发”机制来改善这个问题。</p><p>　　②当很多短帧要发送时，<span style="color:#ff0000;"><strong>第一个短帧采用“载波延伸”方法进行填充</strong></span>，<strong><span style="color:#0000ff;">后面的一些短帧可以一个接一个发送</span>，<span style="color:#ff0000;">它们之间只要留必要的帧间最小间隔即可</span></strong>。这样就形成一串分组突发，直到达到1500字节或稍多一些为止。从而提高链路的利用率。</p><p>　　③“载波延伸”和“分组突发”<span style="color:#0000ff;"><strong>仅用于千兆以太网的半双工模式</strong></span>；而全双工模式不需要使用CSMA/CD协议，也就不需要这两个特性。</p><p><strong>3. 10吉比特以太网</strong></p><p align="center">万兆以太网标准</p><div align="center"><div class="table-box"><table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td valign="top" width="101"><p align="center">名称</p></td><td valign="top" width="81"><p align="center">传输介质</p></td><td valign="top" width="129"><p align="center">网段最大长度</p></td><td valign="top" width="220"><p align="center">特点</p></td></tr><tr><td valign="top" width="101"><p align="center">10GBASE-SR</p></td><td valign="top" width="81"><p align="center">光缆</p></td><td valign="top" width="129"><p align="center">300m</p></td><td valign="top" width="220"><p align="left">多模光纤（0.85μm）</p></td></tr><tr><td valign="top" width="101"><p align="center">10GBASE-LR</p></td><td valign="top" width="81"><p align="center">光缆</p></td><td valign="top" width="129"><p align="center">10km</p></td><td valign="top" width="220"><p align="left">单模光纤（1.3μm）</p></td></tr><tr><td valign="top" width="101"><p align="center">10GBASE-ER</p></td><td valign="top" width="81"><p align="center">光缆</p></td><td valign="top" width="129"><p align="center">40m</p></td><td valign="top" width="220"><p align="left">单模光纤（1.3μm）</p></td></tr><tr><td valign="top" width="101"><p>10GBASE-CX4</p></td><td valign="top" width="81"><p align="center">铜线</p></td><td valign="top" width="129"><p align="center">15m</p></td><td valign="top" width="220"><p align="left">使用四对双芯同轴电缆</p></td></tr><tr><td valign="top" width="101"><p align="center">10GBASE-T</p></td><td valign="top" width="81"><p align="center">铜线</p></td><td valign="top" width="129"><p align="center">100m</p></td><td valign="top" width="220"><p align="left">使用4对6A类的UTP双绞线</p></td></tr></tbody></table></div></div><p>（1）10GE的帧格式与10Mb/s、100Mb/s和1Gb/s以太网的帧格式完全相同。10GE还保留了802.3标准规定的了以太网最小和最长帧长。</p><p>（2）由于数据率很高，10GE不再使用铜线而只使用光纤作为传输媒体。它使用长距离（40km）的光收发器与单模光纤接口，以便能够工作在广域网和城域网的范围。</p><p>（3）10GE只工作在全双工模式，因此不存在争用问题，也不使用CSMA/CD协议。这就使用10GE的传输距离不再受碰撞检测的限制而大大提高了</p></div>                                    </div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（二）--  物理层]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">
        </link>
        <updated>2020-06-04T04:31:50.000Z</updated>
        <summary type="html"><![CDATA[<p>😉<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）</a><br>
😉<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san/">计算机网络学习笔记（三）--  数据链路层</a></p>
<p>😉### 物理层特性</p>
<ul>
<li><strong>机械特性</strong></li>
<li><strong>电气特性</strong></li>
<li><strong>功能特性</strong></li>
<li><strong>规程特性</strong></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>😉<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）</a><br>
😉<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san/">计算机网络学习笔记（三）--  数据链路层</a></p>
<p>😉### 物理层特性</p>
<ul>
<li><strong>机械特性</strong></li>
<li><strong>电气特性</strong></li>
<li><strong>功能特性</strong></li>
<li><strong>规程特性</strong></li>
</ul>
<!-- more -->
<h3 id="数据通信基础知识">数据通信基础知识</h3>
<ol>
<li>
<h4 id="数据通信系统模型">数据通信系统模型</h4>
<ul>
<li>
<p>数据通信系统三部分：<strong>源系统(发送端)、传输系统、目的系统(接收端)</strong></p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/04/twjDlq.png" alt="twjDlq.png" loading="lazy"></figure>
</li>
<li>
<p><strong>模拟信号</strong>：连续信号，表示消息的参数取值是连续的。</p>
</li>
<li>
<p><strong>数字信号</strong>：离散信号，表示消息的参数取值是离散的。</p>
</li>
</ul>
</li>
<li>
<h4 id="信道">信道</h4>
<ul>
<li>按照通信双方信息交互的方式分为：<strong>单工通信</strong>、<strong>半双工通信</strong>、<strong>全双工通信</strong>。</li>
<li><strong>曼切斯特编码产生的信号频率比不归零制高。不归零制没有自同步能力，曼切斯特编码具有自同步能力。</strong></li>
<li>基带信号：来自信源的信号.计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。包含有较多低频成分，需要进行调制。<br>
调制分为：
<ul>
<li>基带调制：对基带信号波形进行变换，仍然是基带信号</li>
<li>带通调制：经过载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号。基本的带通调制方法有：</li>
<li>调幅AM：载波的振幅随基带数字信号而变化。</li>
<li>调频FM：载波的频率随基带数字信号而变化。</li>
<li>调相PM：载波的初始相位随基带数字信号而变化。</li>
<li>正交振幅调制QAM：多元制的振幅相位混合调制方法，信息传输速率更高。</li>
</ul>
</li>
<li>调制解调原因</li>
</ul>
<blockquote>
<p>无线电通信系统：通过空间辐射方式传送信号。<br>
电磁波理论可知：天线尺寸为被辐射信号波长的十分之一或更大些，信号才能有效的被辐射。<br>
对于语音信号：天线尺寸需要在几十公里以上，因此需要调制(语音信号的频率范围为300~3400Hz)。<br>
调制过程：将信号频谱搬移到任何所需的较高频率范围，这就容易以电磁波形式辐射出去。<br>
如果不进行调制，而是把被传送的信号直接辐射出去，那么各电台所发出的信号频率就会相同，他们混在一起，收信者将无法选择所要接收的信号。<br>
调制作用的实质：把各种信号的频谱搬移，使它们互不重叠地占据不同的频率范围，即信号分别托付于不同频率的载波上，接收机可以分离出所需要的频率的信号，不致相互干扰。（实现了多路复用）</p>
</blockquote>
</li>
<li>
<h4 id="信道极限容量">信道极限容量</h4>
<ul>
<li>
<p>码元传输的速率越高，或者信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形失真就越严重。</p>
</li>
<li>
<p>限制码元在信道上的传输速率的因素有：</p>
<ol>
<li>信道能够通过的频率范围<br>
奈氏准则：在任何信道中，码元传输的速率是由上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决成为不可能。</li>
<li>信噪比：信号的平均功率和噪声的平均功率之比(S/N)单位dB<br>
信噪比(dB)=10log10(S/N)(dB)<br>
信道的极限信息传输速率C=Wlog2(1+S/N) (b/s)</li>
</ol>
<p>可以看出：<strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</strong></p>
</li>
<li>
<p>提高信息的传输速率：尽可能的让每一个码元携带更多信息量。</p>
</li>
</ul>
</li>
</ol>
<h3 id="物理层下的传输媒体">物理层下的传输媒体</h3>
<ul>
<li>导向传输媒体：固体媒体(铜线或光纤)。双绞线、同轴电缆、光纤。</li>
<li>非导向传输媒体：指利用无线电波在自由空间传播。</li>
</ul>
<h3 id="信道复用技术">信道复用技术</h3>
<ol>
<li>
<h4 id="频分-时分-统计时分复用">频分、时分、统计时分复用</h4>
<ul>
<li>
<p><strong>频分复用</strong>FDM：所有用户在同样的时间占用不同的带宽资源。</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/04/t0FCDA.png" alt="t0FCDA.png" loading="lazy"></figure>
</li>
<li>
<p><strong>时分复用</strong>TDM：所有用户在不同的时间占用同样的频带宽度。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/04/t0Fegg.png" alt="t0Fegg.png" loading="lazy"></figure>
<p>TDM有时会造成信道利用率不高：</p>
  <img src="https://s1.ax1x.com/2020/06/04/t0eoin.png" alt="t0eoin.png" border="0" />
</li>
<li>
<p><strong>统计时分复用</strong>STDM：TDM的改进，提高信道利用率。</p>
  <div align="center"><img src="https://s1.ax1x.com/2020/06/04/t0e2M8.png" alt="t0e2M8.png" border="0" /></div>
</li>
</ul>
</li>
<li>
<h4 id="波分复用">波分复用</h4>
<ul>
<li><strong>波分复用</strong>WDM：即光的频分复用。</li>
</ul>
</li>
</ol>
  <div align="center"><img src="https://s1.ax1x.com/2020/06/04/t0FUKJ.png" alt="t0FUKJ.png" border="0" /></div>
<p>经过复用器合波后，速率达到8 x 2.5Gbit/s = 20Gbit/s。</p>
<ol start="3">
<li>
<h4 id="码分复用">码分复用</h4>
<ul>
<li>
<p><strong>码分复用</strong>CDM：即<strong>码分多址CDMA</strong>，每一个用户可以在同样的时间使用同样的频带进行通信。</p>
<p>为每个用户分配 m bit 的码片，并且所有的码片<strong>正交</strong>，对于任意两个码片 <em>S</em> (S站的码片向量) 和 <em>T</em> (T站的码片向量) 有</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/04/t0k1Ld.png" alt="t0k1Ld.png" loading="lazy"></figure>
<p>为了方便，取 m=8，设码片 <em>S</em> 为 00011011。在拥有该码片的用户<strong>发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码</strong> 11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/04/t0kUW8.png" alt="t0kUW8.png" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/04/t0k0yQ.png" alt="t0k0yQ.png" loading="lazy"></figure>
<p>其中 <em>S</em>' 为 <em>S</em> 的反码。</p>
<p><strong>任何一个码片向量和该码片向量自己的规格化内积都是1。</strong></p>
<p>利用上面的式子我们知道，当接收端使用码片 <em>S</em> 对接收到的数据进行内积运算时，<strong>结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</strong></p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
</li>
</ul>
</li>
</ol>
<h3 id="宽带接入技术">宽带接入技术</h3>
<ol>
<li>
<h4 id="xdsl技术用数字技术对现有的模拟电话用户线进行改造使它能够承载宽带业务">xDSL技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</h4>
<p>其中，0-4kHz低端频谱留给传统电话使用，高端频谱留给用户上网使用。几种类型:ADSL/HDSL/SDSL/VDSL</p>
<ul>
<li>ADSL技术：非对称数字用户线。ADSL把上行和下行带宽做成不对称的。上行指从用户到ISP,下行指从ISP到用户。用户线两端是调制解调器(DMT).<br>
DMT调制技术采用频分复用。40kHz-1.1MHz的高端频谱划分许多子信道，25个用于上行，249个用于下行。每个信道占据4kHz带宽。ADSL不能保证固定的数据率。</li>
<li>基于ADSL的接入网组成：
<ul>
<li>数字用户线接入复用器DSLAM（包含许多ADSL调制解调器，记为ATU-C和ATU-R）</li>
<li>用户线</li>
<li>用户家的设施</li>
<li>总结：ADSL是借助于在用户线两端安装ADSL调制解调器(即ATU-R和ATU-C)对数字信号进行调制，使得调制后的数字信号的频谱适合在原来的用线上传输。</li>
</ul>
</li>
<li>光纤同轴混合网(HFC网)<br>
HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民带宽接入网。
<ul>
<li>功能：传送CATV、电话业务、数据和其他宽带交互型业务。</li>
<li>特点：
<ol>
<li>HFC网的主干线路采用光纤</li>
<li>HFC网采用结点体系结构：从头端到各个光纤结点用模拟光纤连接，构成星型网。</li>
<li>HFC网具有比CATV网更宽的频谱，且具有双向传输功能</li>
<li>每个家庭要安装一个用户接口盒，其提供三种连接：使用同轴电缆连接到机顶盒再连接到用户的电视机；使用双绞线连接到用户的电话机；使用电缆调制解调器连接到用户的计算机。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="fttx技术光纤到">FTTx技术（光纤到…）</h4>
<ul>
<li>光纤到户FTTH：即将光纤一直铺设到用户家庭。</li>
<li>光纤到大楼FTTB：支持大中型企业、大公司高速率宽带业务需求，比FTTH经济。</li>
<li>光纤到路边FTTC：比较流行。</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（一）--  计算机网络概述]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">
        </link>
        <updated>2020-06-04T03:06:42.000Z</updated>
        <summary type="html"><![CDATA[<p>👻<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a><br>
👻<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san/">计算机网络学习笔记（三）--  数据链路层</a><br>
👻### 互联网概述</p>
<ul>
<li>计算机网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。计算机、集线器、交换机、路由器都可以是结点。</li>
<li>网络与网络之间通过<strong>路由器</strong>连接成互联网。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>👻<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a><br>
👻<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san/">计算机网络学习笔记（三）--  数据链路层</a><br>
👻### 互联网概述</p>
<ul>
<li>计算机网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。计算机、集线器、交换机、路由器都可以是结点。</li>
<li>网络与网络之间通过<strong>路由器</strong>连接成互联网。</li>
</ul>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/04/tw57ge.png" alt="tw57ge.png" loading="lazy"></figure>
<h3 id="isp">ISP</h3>
<ul>
<li>互联网服务提供商 <strong>ISP</strong> 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</li>
<li>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。</li>
<li>互联网交换点 <strong>IXP</strong> 允许两个 ISP 直接相连而不用经过第三个 ISP。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/04/tw5qud.png" alt="tw5qud.png" loading="lazy"></figure>
<h3 id="互联网的组成">互联网的组成</h3>
<ol>
<li>
<h4 id="两大块">两大块</h4>
<ul>
<li>边缘部分：所有连接在互联网上的<strong>主机</strong>（又被称为端系统），用户可以直接使用。用来进行通信和资源共享等。</li>
<li>核心部分：由大量的网络和连接这些网络的<strong>路由器</strong>组成，用来为边缘部分的主机提供服务。</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/04/twIkbn.png" alt="twIkbn.png" loading="lazy"></figure>
<ol start="2">
<li>
<h4 id="主机间的通信方式">主机间的通信方式</h4>
<ul>
<li>客户-服务器方式（C/S）：客户即是服务请求方，服务器是服务提供方。</li>
<li>对等连接方式（P2P）：不区分客户和服务器。</li>
</ul>
</li>
<li>
<h4 id="互联网核心部分">互联网核心部分</h4>
<ul>
<li>路由器在核心部分起到特殊作用，任务是转发收到的分组，完成分组交换。</li>
</ul>
<ol>
<li>
<h4 id="电路交换">电路交换</h4>
<ul>
<li>
<p>交换过程必须经过建立连接（占用信道资源）--  通话（一直占用信道资源）--  释放连接（归还通信资源）。</p>
</li>
<li>
<p>在整个通信过程中通话的两个用户始终占用端到端的通信资源。</p>
</li>
</ul>
</li>
<li>
<h4 id="报文交换">报文交换</h4>
<ul>
<li>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</li>
</ul>
</li>
<li>
<h4 id="分组交换">分组交换</h4>
</li>
</ol>
<ul>
<li>分组交换使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了<strong>目的地址</strong>和<strong>源地址</strong>等控制信息。</li>
</ul>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/04/twIn8U.png" alt="twIn8U.png" loading="lazy"></figure>
<h3 id="时延">时延</h3>
<p><strong>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</strong></p>
<ol>
<li>
<h4 id="发送时延">发送时延</h4>
<p>主机或路由器发送数据帧所需要的时间。</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/04/twomdI.png" alt="twomdI.png" loading="lazy"></figure>
<p>其中 l 表示数据帧的长度，v 表示发送速率。</p>
</li>
<li>
<h4 id="传播时延">传播时延</h4>
<p>电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/04/twTkt0.png" alt="twTkt0.png" loading="lazy"></figure>
<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。</p>
</li>
<li>
<h4 id="处理时延">处理时延</h4>
<p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据部分等。</p>
</li>
<li>
<h4 id="排队时延">排队时延</h4>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/04/twT6gS.png" alt="twT6gS.png" loading="lazy"></figure>
</li>
<li>
<h4 id="时延带宽积">时延带宽积</h4>
<p>时延带宽积 = 传播时延 x 带宽</p>
<p>链路的时延带宽积被称为以比特为单位的链路长度。</p>
</li>
</ol>
<h3 id="计算机网络体系结构">计算机网络体系结构</h3>
<p>​															<img src="https://s1.ax1x.com/2020/06/04/tw7hse.png" alt="tw7hse.png" loading="lazy"></p>
<ol>
<li>
<p><strong>应用层</strong>：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。<strong>数据单位为报文</strong>。</p>
</li>
<li>
<p><strong>运输层</strong>：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 <strong>TCP，提供面向连接、可靠的数据传输服务</strong>，<strong>数据单位为报文段</strong>；用户数据报协议 <strong>UDP，提供无连接、尽最大努力的数据传输服务</strong>，<strong>数据单位为用户数据报</strong>。</p>
</li>
<li>
<p><strong>网络层</strong>：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层产生的报文段或者用户数据报封装成**分组(IP数据报)**来进行传输。</p>
</li>
<li>
<p><strong>数据链路层</strong>：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组<strong>封装成帧</strong>。</p>
</li>
<li>
<p><strong>物理层</strong>：考虑的是怎样在传输媒体上传输数据<strong>比特流</strong>，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。</p>
<div align="center"><img src="https://s1.ax1x.com/2020/06/04/twbV9P.png" alt="twbV9P.png" border="0" /></div>
</li>
</ol>
<ul>
<li>
<p>TCP/IP体系结构</p>
<p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
</li>
</ul>
<div align="center"><img src="https://s1.ax1x.com/2020/06/04/twXlrT.png" alt="twXlrT.png" border="0" /></div>
<p>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p>
  <div align="center"><img src="https://s1.ax1x.com/2020/06/04/twqzee.png" alt="twqzee.png" border="0" /></div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/centos76-an-zhuang-docker-bing-zai-docker-zhong-li-yong-tomcat-bu-shu-jing-tai-wang-ye/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/centos76-an-zhuang-docker-bing-zai-docker-zhong-li-yong-tomcat-bu-shu-jing-tai-wang-ye/">
        </link>
        <updated>2020-06-03T06:40:59.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="centos76安装docker并在docker中利用tomcat部署静态网页">CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="centos76安装docker并在docker中利用tomcat部署静态网页">CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页</h3>
<!-- more -->
<h4 id="1-安装docker">1. 安装Docker</h4>
<ul>
<li>
<p>更新yum包</p>
<pre><code>yum update
</code></pre>
</li>
<li>
<p>查看是否安装过docker</p>
<pre><code>whereis docker
</code></pre>
</li>
<li>
<p>如果安装过，则删除之前的版本</p>
<pre><code>yum remove docker docker-common docker-selinux docker-engine
</code></pre>
</li>
<li>
<p>设置yum源</p>
<pre><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
</li>
<li>
<p>查看docker版本</p>
<pre><code>yum list docker-ce --showduplicates | sort -r
</code></pre>
</li>
<li>
<p>安装</p>
<pre><code>yum install docker-ce 
</code></pre>
</li>
<li>
<p>启动Docker</p>
<pre><code>systemctl start docker
</code></pre>
</li>
<li>
<p>开机启动</p>
<pre><code>systemctl enable docker
</code></pre>
</li>
<li>
<p>验证安装是否成功</p>
<pre><code>docker version
</code></pre>
<ul>
<li>
<p>如下存在Client和Server则成功</p>
<figure data-type="image" tabindex="1"><img src="X:%5Cclassworks%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5Cdockerversion.png" alt="dockerversion" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
<p>2.Docker常用命令</p>
<pre><code>docker 运行容器命令
docker ps
 
docker 所有容器命令
docker ps -a
 
docker 删除容器命令
docker rm 容器id
 
docker 镜像查看命令
</code></pre>
<p>3.利用Tomcat部署静态网页</p>
<ul>
<li>
<p>拉取Tomcat</p>
<pre><code>docker pull tomcat
</code></pre>
</li>
<li>
<p>启动容器，验证Tomcat服务</p>
<pre><code>docker run -p 8080:8080 tomcat
</code></pre>
</li>
<li>
<p>访问</p>
<p>服务器外网IP:8080即可</p>
<p>如果不行，看是否能ping通或者是服务器端口是否开放</p>
</li>
<li>
<p>将静态页面拷贝到docker中tomcat的webapps下，建议挂载</p>
<ul>
<li>
<p>将Tomcat启动，进入docker中查看命令：</p>
<pre><code>docker exec -it 容器id /bin/bash //容器ID可通过 docker ps命令查询
</code></pre>
</li>
<li>
<p>挂载静态文件</p>
<p>首先将静态资源文件夹上传至云服务器，例如我的上传至了/root下，即SongMove文件夹。下面这条命令即是将静态资源目录映射到容器的/ROOT下</p>
<pre><code>docker run -d -v /root/SongMove/:/usr/local/tomcat/webapps/ROOT/ -p 8080:8080 tomcat:latest
</code></pre>
</li>
</ul>
</li>
</ul>
<p>4.服务器IP:8080访问即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数（上）]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/han-shu-shang/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/han-shu-shang/">
        </link>
        <updated>2020-06-02T13:31:02.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="函数的概念">函数的概念</h2>
<ul>
<li>
<p>对于 js 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p>
</li>
<li>
<p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="函数的概念">函数的概念</h2>
<ul>
<li>
<p>对于 js 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p>
</li>
<li>
<p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p>
</li>
</ul>
<!-- more -->
<ul>
<li>
<p>先看一段代码</p>
<pre><code class="language-javascript">// 这个是我们以前写的一段代码
for (var i = 0; i &lt; 10; i++) {
  console.log(i)
}

// 函数，这个 {} 就是那个 “盒子”
function fn() {
  // 这个函数我们以前写的代码
  for (var i = 0; i &lt; 10; i++) {
    console.log(i)
  }
}
</code></pre>
</li>
</ul>
<h2 id="函数的两个阶段重点">函数的两个阶段（重点）</h2>
<ul>
<li>按照我们刚才的说法，两个阶段就是 <strong>放在盒子里面</strong> 和 <strong>让盒子里面的代码执行</strong></li>
</ul>
<h3 id="函数定义阶段">函数定义阶段</h3>
<ul>
<li>
<p>定义阶段就是我们把代码 <strong>放在盒子里面</strong></p>
</li>
<li>
<p>我们就要学习怎么 <strong>放进去</strong>，也就是书写一个函数</p>
</li>
<li>
<p>我们有两种定义方式 <strong>声明式</strong> 和 <strong>赋值式</strong></p>
</li>
</ul>
<h4 id="声明式">声明式</h4>
<ul>
<li>
<p>使用 <code>function</code> 这个关键字来声明一个函数</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-javascript">function fn() {
  // 一段代码
}
// function: 声明函数的关键字，表示接下来是一个函数了
// fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）
// (): 必须写，是用来放参数的位置（一会我们再聊）
// {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”）
</code></pre>
</li>
</ul>
<h4 id="赋值式">赋值式</h4>
<ul>
<li>
<p>其实就是和我们使用 <code>var</code> 关键字是一个道理了</p>
</li>
<li>
<p>首先使用 <code>var</code> 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-javascript">var fn = function () {
  // 一段代码
}
// 不需要在 function 后面书写函数的名字了，因为在前面已经有了
</code></pre>
</li>
</ul>
<h3 id="函数调用阶段">函数调用阶段</h3>
<ul>
<li>就是让 <strong>盒子里面</strong> 的代码执行一下</li>
<li>让函数执行</li>
<li>两种定义函数的方式不同，但是调用函数的方式都以一样的</li>
</ul>
<h4 id="调用一个函数">调用一个函数</h4>
<ul>
<li>
<p>函数调用就是直接写 <code>函数名()</code> 就可以了</p>
<pre><code class="language-javascript">// 声明式函数
function fn() {
  console.log('我是 fn 函数')
}

// 调用函数
fn()

// 赋值式函数
var fn2 = function () {
  console.log('我是 fn2 函数')
}

// 调用函数
fn()
</code></pre>
<ul>
<li>注意： <strong>定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行</strong></li>
</ul>
</li>
</ul>
<h4 id="调用上的区别">调用上的区别</h4>
<ul>
<li>
<p>虽然两种定义方式的调用都是一样的，但是还是有一些区别的</p>
</li>
<li>
<p>声明式函数： 调用可以在 <strong>定义之前或者定义之后</strong></p>
<pre><code class="language-javascript">// 可以调用
fn()

// 声明式函数
function fn() {
  console.log('我是 fn 函数')
}

// 可以调用
fn()
</code></pre>
</li>
<li>
<p>赋值式函数： 调用只能在 <strong>定义之前</strong></p>
<pre><code class="language-javascript">// 会报错
fn()

// 赋值式函数
var fn = function () {
  console.log('我是 fn 函数')
}

// 可以调用
fn()
</code></pre>
</li>
</ul>
<h2 id="函数的参数重点">函数的参数（重点）</h2>
<ul>
<li>
<p>我们在定义函数和调用函数的时候都出现过 <code>()</code></p>
</li>
<li>
<p>现在我们就来说一下这个 <code>()</code> 的作用</p>
</li>
<li>
<p>就是用来放参数的位置</p>
</li>
<li>
<p>参数分为两种 <strong>行参</strong> 和 <strong>实参</strong></p>
<pre><code class="language-javascript">// 声明式
function fn(行参写在这里) {
  // 一段代码
}

fn(实参写在这里)

// 赋值式函数
var fn = function (行参写在这里) {
  // 一段代码
}
fn(实参写在这里)
</code></pre>
</li>
</ul>
<h3 id="行参和实参的作用">行参和实参的作用</h3>
<ol>
<li>
<p>行参</p>
<ul>
<li>
<p>就是在函数内部可以使用的变量，在函数外部不能使用</p>
</li>
<li>
<p>每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范）</p>
</li>
<li>
<p>多个单词之间以 <code>,</code> 分隔</p>
<pre><code class="language-javascript">// 书写一个参数
function fn(num) {
  // 在函数内部就可以使用 num 这个变量
}

var fn1 = function (num) {
	// 在函数内部就可以使用 num 这个变量
}

// 书写两个参数
function fun(num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}

var fun1 = function (num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}
</code></pre>
</li>
<li>
<p>如果只有行参的话，那么在函数内部使用的值个变量是没有值的，也就是 <code>undefined</code></p>
</li>
<li>
<p><strong>行参的值是在函数调用的时候由实参决定的</strong></p>
</li>
</ul>
</li>
<li>
<p>实参</p>
<ul>
<li>
<p>在函数调用的时候给行参赋值的</p>
</li>
<li>
<p>也就是说，在调用的时候是给一个实际的内容的</p>
<pre><code class="language-javascript">function fn(num) {
  // 函数内部可以使用 num 
}

// 这个函数的本次调用，书写的实参是 100
// 那么本次调用的时候函数内部的 num 就是 100
fn(100) 

// 这个函数的本次调用，书写的实参是 200
// 那么本次调用的时候函数内部的 num 就是 200
fn(200)
</code></pre>
</li>
<li>
<p><strong>函数内部的行参的值，由函数调用的时候传递的实参决定</strong></p>
</li>
<li>
<p><strong>多个参数的时候，是按照顺序一一对应的</strong></p>
<pre><code class="language-javascript">function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 函数本次调用的时候，书写的参数是 100 和 200
// 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200
fn(100, 200)
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="参数个数的关系">参数个数的关系</h3>
<ol>
<li>
<p>行参比实参少</p>
<ul>
<li>
<p>因为是按照顺序一一对应的</p>
</li>
<li>
<p>行参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值</p>
<pre><code class="language-javascript">function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 本次调用的时候，传递了两个实参，100 200 和 300
// 100 对应了 num1，200 对应了 num2，300 没有对应的变量
// 所以在函数内部就没有办法依靠变量来使用 300 这个值
fn(100, 200, 300)
</code></pre>
</li>
</ul>
</li>
<li>
<p>行参比实参多</p>
<ul>
<li>
<p>因为是按照顺序一一对应的</p>
</li>
<li>
<p>所以多出来的行参就是没有值的，就是 <code>undefined</code></p>
<pre><code class="language-javascript">function fn(num1, num2, num3) {
  // 函数内部可以使用 num1 num2 和 num3
}

// 本次调用的时候，传递了两个实参，100 和 200
// 就分别对应了 num1 和 num2
// 而 num3 没有实参和其对应，那么 num3 的值就是 undefined
fn(100, 200)
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="函数的return重点">函数的return（重点）</h2>
<ul>
<li>return 返回的意思，其实就是给函数一个 <strong>返回值</strong> 和 <strong>终断函数</strong></li>
</ul>
<h3 id="终断函数">终断函数</h3>
<ul>
<li>
<p>当我开始执行函数以后，函数内部的代码就会从上到下的依次执行</p>
</li>
<li>
<p>必须要等到函数内的代码执行完毕</p>
</li>
<li>
<p>而 <code>return</code> 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行</p>
<pre><code class="language-javascript">function fn() {
  console.log(1)
  console.log(2)
  console.log(3)
  
  // 写了 return 以后，后面的 4 和 5 就不会继续执行了
  return
  console.log(4)
  console.log(5)
}

// 函数调用
fn()
</code></pre>
</li>
</ul>
<h3 id="返回值">返回值</h3>
<ul>
<li>
<p>函数调用本身也是一个表达式，表达式就应该有一个值出现</p>
</li>
<li>
<p>现在的函数执行完毕之后，是不会有结果出现的</p>
<pre><code class="language-javascript">// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3
console.log(1 + 2) // 3

function fn() {
  // 执行代码
}

// fn() 也是一个表达式，这个表达式就没有结果出现
console.log(fn()) // undefined
</code></pre>
</li>
<li>
<p><code>return</code> 关键字就是可以给函数执行完毕一个结果</p>
<pre><code class="language-javascript">function fn() {
  // 执行代码
  return 100
}

// 此时，fn() 这个表达式执行完毕之后就有结果出现了
console.log(fn()) // 100
</code></pre>
<ul>
<li>我们可以在函数内部使用 <code>return</code> 关键把任何内容当作这个函数运行后的结果</li>
</ul>
</li>
</ul>
<h2 id="函数的优点">函数的优点</h2>
<ul>
<li>函数就是对一段代码的封装，在我们想调用的时候调用</li>
<li>函数的几个优点
<ol>
<li>封装代码，使代码更加简洁</li>
<li>复用，在重复功能的时候直接调用就好</li>
<li>代码执行时机，随时可以在我们想要执行的时候执行</li>
</ol>
</li>
</ul>
<h2 id="预解析重点">预解析（重点）</h2>
<ul>
<li><strong>预解析</strong> 其实就是聊聊 js 代码的编译和执行</li>
<li>js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码</li>
<li>也就是说，我们的 js 代码在运行的时候，会经历两个环节 <strong>解释代码</strong> 和 <strong>执行代码</strong></li>
</ul>
<h3 id="解释代码">解释代码</h3>
<ul>
<li>
<p>因为是在所有代码执行之前进行解释，所以叫做 <strong>预解析（预解释）</strong></p>
</li>
<li>
<p>需要解释的内容有两个</p>
<ul>
<li>声明式函数
<ul>
<li>在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数</li>
</ul>
</li>
<li><code>var</code> 关键字
<ul>
<li>在内存中先声明有一个变量名</li>
</ul>
</li>
</ul>
</li>
<li>
<p>看下面一段代码</p>
<pre><code class="language-javascript">fn()
console.log(num)

function fn() {
  console.log('我是 fn 函数')
}

var num = 100
</code></pre>
</li>
<li>
<p>经过预解析之后可以变形为</p>
<pre><code class="language-javascript">function fn() {
  console.log('我是 fn 函数')
}
var num

fn()
console.log(num)
num = 100
</code></pre>
</li>
<li>
<p>赋值是函数会按照 <code>var</code> 关键字的规则进行预解析</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/hello-gridea/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>