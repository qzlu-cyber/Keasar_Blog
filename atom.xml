<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://keasar.com.cn</id>
    <title>Keasar`Blog</title>
    <updated>2020-08-22T10:29:30.778Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://keasar.com.cn"/>
    <link rel="self" href="https://keasar.com.cn/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://keasar.com.cn/images/avatar.png</logo>
    <icon>https://keasar.com.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, Keasar`Blog</rights>
    <entry>
        <title type="html"><![CDATA[React 高级 -- Refs and DOM]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-refs-and-dom/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-refs-and-dom/">
        </link>
        <updated>2020-08-22T10:27:06.000Z</updated>
        <summary type="html"><![CDATA[<p>React 数据流是单向的，通过 <code>props</code> 由父组件向子组件传递数据，如果要修改子组件，需要修改 <code>props</code> 来重新渲染子组件。<code>refs</code> 就是另一种方法，它允许我们访问真实的 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p>
]]></summary>
        <content type="html"><![CDATA[<p>React 数据流是单向的，通过 <code>props</code> 由父组件向子组件传递数据，如果要修改子组件，需要修改 <code>props</code> 来重新渲染子组件。<code>refs</code> 就是另一种方法，它允许我们访问真实的 DOM 节点或在 <code>render</code> 方法中创建的 React 元素。</p>
<!-- more -->
<h4 id="何时使用">何时使用</h4>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<p><strong>请勿过度使用 Refs，尽可能少地操作 DOM。</strong></p>
<h4 id="使用-refs">使用 Refs</h4>
<ul>
<li>
<p>利用 <code>React.createRef()</code> 构建：</p>
<pre><code class="language-jsx">export default class App extends Component {
  render() {
    return &lt;Hello /&gt;;
  }
}

class Hello extends Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef(); // 创建 Refs
  }

  render() {
    return (
      &lt;div style={{ margin: &quot;0 auto&quot;, width: &quot;80px&quot; }}&gt;
        &lt;h1 ref={this.myRef}&gt;Hello&lt;/h1&gt; {/*通过 ref 属性附加到 React 元素*/}
      &lt;/div&gt;
    );
  }
}
</code></pre>
</li>
<li>
<p>回调形式的 <code>refs</code></p>
<pre><code class="language-jsx">export default class App extends Component {
  render() {
    return &lt;Hello /&gt;;
  }
}

class Hello extends Component {
  constructor(props) {
    super(props);
    this.myRef = null; // 创建 Refs
  }

  render() {
    return (
      &lt;div style={{ margin: &quot;0 auto&quot;, width: &quot;80px&quot; }}&gt;
        &lt;h1 ref={(element) =&gt; this.myRef = element}&gt;Hello&lt;/h1&gt; {/*通过 ref 属性附加到 React 元素*/}
      &lt;/div&gt;
    );
  }
}	
</code></pre>
</li>
</ul>
<h4 id="访问-refs">访问 Refs</h4>
<pre><code class="language-jsx">const node = this.myRefs.current; // 将会得到 &lt;h1&gt; 标签
</code></pre>
<p>当使用回调形式的 <code>refs</code> 时无 <code>current</code> 属性，<code>this.myRefs</code> 即为 DOM。可通过下面的形式定义出 <code>current</code>，可简单理解为利用 <code>React.createRef()</code> 构建的 <code>refs</code> 即是这种原理（实际上官方还做了密封处理）：</p>
<pre><code class="language-jsx">class Hello extends Component {
  constructor(props) {
    super(props);
    this.myRef = {
      current: null
    }; // 创建 Refs
  }
  
  render() {
    return (
      &lt;div style={{ margin: &quot;0 auto&quot;, width: &quot;80px&quot; }}&gt;
        &lt;h1 ref={this.myRef}&gt;Hello&lt;/h1&gt; {/*通过 ref 属性附加到 React 元素*/}
      &lt;/div&gt;
    );
  }
}	
</code></pre>
<p><code>ref</code> 的值根据节点的类型而有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>
<li>当 <code>ref</code> 属性用于自定义 <code>class</code> 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为它们没有实例。</li>
</ul>
<p>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/08/22/daHKUS.png" alt="何时获取到DOM" loading="lazy"></figure>
<h4 id="操作-dom">操作 DOM</h4>
<pre><code class="language-jsx">class Hello extends Component {
...
  componentDidMount() {
    if (this.myRef &amp;&amp; this.myRef.current) {
    this.myRef.current.innerHTML = &quot;World&quot;; // 原本 &lt;h1&gt; 标签中的 Hello 将被替换为 World
    }
  }
...
}

export default Hello;
</code></pre>
<h4 id="为-dom-元素添加-ref">为 DOM 元素添加 <code>ref</code></h4>
<pre><code class="language-jsx">import React from &quot;react&quot;;

export default class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 textInput 的 DOM 元素
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // 直接使用原生 API 使 text 输入框获得焦点
    // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点
    this.textInput.current.focus();
  }

  render() {
    // 告诉 React 我们想把 &lt;input&gt; ref 关联到
    // 构造器里创建的 `textInput` 上
    return (
      &lt;div&gt;
        &lt;input type='text' ref={this.textInput} /&gt;
        &lt;input
          type='button'
          value='Focus the text input'
          onClick={this.focusTextInput} {/*每当点击按钮输入框将自动获得焦点*/}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h4 id="为类组件添加-ref">为类组件添加 <code>Ref</code></h4>
<pre><code class="language-jsx">class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput(); //挂载后调用 current 内部方法实现输入框自动获取到焦点
  }

  render() {
    return (
      &lt;CustomTextInput ref={this.textInput} /&gt;
    );
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 网络请求 Fetch]]></title>
        <id>https://keasar.com.cn/post/javascript-wang-luo-qing-qiu-fetch/</id>
        <link href="https://keasar.com.cn/post/javascript-wang-luo-qing-qiu-fetch/">
        </link>
        <updated>2020-08-22T03:40:07.000Z</updated>
        <summary type="html"><![CDATA[<p>JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息。例如在表单提交、从服务器加载数据等都需要使用网络请求。对于来自 JavaScript 的网络请求，有一个总称术语 “AJAX”，有很多方式可以向服务端发送网络请求获取到数据。<code>fetch()</code>是目前比较通用的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息。例如在表单提交、从服务器加载数据等都需要使用网络请求。对于来自 JavaScript 的网络请求，有一个总称术语 “AJAX”，有很多方式可以向服务端发送网络请求获取到数据。<code>fetch()</code>是目前比较通用的方法。</p>
<!-- more -->
<h4 id="基本语法">基本语法</h4>
<pre><code class="language-js">let promise = fetch(url, [options])
</code></pre>
<ul>
<li><code>url</code>：要访问的 <code>url</code>地址</li>
<li><code>options</code>：可选参数，<code>method</code>、<code>header</code>等，参数为空则发起 <code>GET</code>请求</li>
<li>返回值为一个 <code>Promise</code> 对象</li>
</ul>
<h4 id="请求阶段">请求阶段</h4>
<p>获取到响应通常要经历两个阶段。</p>
<p>第一阶段：当服务器发送了响应头（response header），<code>fetch</code> 返回的 <code>promise</code> 就使用内建的 <a href="https://fetch.spec.whatwg.org/#response-class">Response</a> class 对象来对响应头进行解析。此时，我们可以通过检查响应头来检查 HTTP 状态来确认网络请求是否成功，这是还没有响应体 <code>response body</code>。</p>
<p>若<code>fetch</code> 无法建立一个 HTTP 请求，如网络问题，或是请求的网址不存在，那么 <code>promise</code> 就会 <code>reject</code>。异常的 HTTP 状态，例如 404 或 500，不会导致出现 <code>error</code>。</p>
<ul>
<li><code>response.status</code> -- HTTP 状态码</li>
<li><code>response.ok</code> -- Boolean，若为 200 - 299 为 <code>true</code></li>
</ul>
<p>第二阶段：获取到 <code>response body</code>，<code>Response</code> 提供了多种基于 <code>promise</code> 的方法，来以不同的格式访问 <code>body</code>：</p>
<ul>
<li><strong><code>response.text()</code></strong> —— 读取 response，并以文本形式返回 response</li>
<li><strong><code>response.json()</code></strong> —— 将 response 解析为 JSON</li>
<li><strong><code>response.formData()</code></strong> —— 以 <code>FormData</code> 对象的形式返回 response</li>
<li><strong><code>response.blob()</code></strong> —— 以 <a href="https://zh.javascript.info/blob">Blob</a>（具有类型的二进制数据）形式返回 response</li>
<li><strong><code>response.arrayBuffer()</code></strong> —— 以 <a href="https://zh.javascript.info/arraybuffer-binary-arrays">ArrayBuffer</a>（低级别的二进制数据）形式返回 response</li>
<li>另外，<code>response.body</code> 是 <a href="https://streams.spec.whatwg.org/#rs-class">ReadableStream</a> 对象，它允许你逐块读取 body，我们稍后会用一个例子解释它。</li>
</ul>
<blockquote>
<p>我们只能选择一种读取 <code>body</code> 的方法。</p>
<p>如果我们已经使用了 <code>response.text()</code> 方法来获取 <code>response</code>，那么如果再用 <code>response.json()</code>，则不会生效，因为 <code>body</code> 内容已经被处理过了。</p>
</blockquote>
<h4 id="post-请求"><code>POST</code> 请求</h4>
<pre><code class="language-js">let response = await fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: requestBody
});
</code></pre>
<ul>
<li><code>body</code> -- 请求体，可以是字符串、<code>FormData</code>对象（以 <code>form/multipart</code> 形式发送）、<code>Blob/BufferSource</code>二进制数据等</li>
</ul>
<blockquote>
<p>如果请求的 <code>body</code> 是字符串，则 <code>Content-Type</code> 会默认设置为 <code>text/plain;charset=UTF-8</code>。但是，当我们要发送 JSON 时，我们会使用 <code>headers</code> 选项来发送 <code>application/json</code>，这是 JSON 编码的数据的正确的 <code>Content-Type</code>。</p>
</blockquote>
<h4 id="用法小结">用法小结</h4>
<p>典型的 <code>fetch</code> 请求由两个 <code>await</code> 调用组成：</p>
<pre><code class="language-js">let response = await fetch(url, [options]); // 解析 response header
let result = await response.json(); // 将 body 读取为 json
</code></pre>
<p>或者以 <code>promise</code> 形式：</p>
<pre><code class="language-js">fetch(url, [options])
  .then(response =&gt; response.json())
  .then(result =&gt; /* 处理结果 */)
</code></pre>
<h4 id="实例">实例</h4>
<p>从 GitHub 获取用户信息：</p>
<pre><code class="language-js">  async function getUsers(names) {
    const response = await fetch(`https://api.github.com/users/${names}`);
    if (response.ok) {
    		const result = await response.json();
    		console.log(result);
    } else {
      return null;
    }
  }
  getUsers('qzlu-cyber');
</code></pre>
<h4 id="fetch-跟踪下载进度"><code>Fetch</code> 跟踪下载进度</h4>
<p><code>fetch()</code> 无法跟踪上传进度，但是可以跟踪下载进度。要跟踪下载进度，可以使用 <code>response.body</code> 属性。它是 <code>ReadableStream</code> —— 一个特殊的对象，它可以逐块（chunk）提供 <code>body</code>。</p>
<pre><code class="language-js">// 代替 response.json() 以及其他方法
const reader = response.body.getReader();

// 在 body 下载时，一直为无限循环
while(true) {
  // 当最后一块下载完成时，done 值为 true，否则为 false
  // value 是块字节的 Uint8Array
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
</code></pre>
<h4 id="fetch-中止"><code>fetch</code> 中止</h4>
<p>JavaScript 有一个特殊的内建对象 <code>AbortController</code>，既可以中止 <code>fetch</code> 也可以中止其他异步任务。</p>
<p>用法：</p>
<pre><code class="language-js">let controller = new AbortController();
</code></pre>
<p><code>controller</code> 对象具有 <code>abort()</code> 方法和 <code>signal</code>属性。当 <code>abort()</code> 被调用时，<code>abort</code> 事件会在 <code>controller.signal</code> 上触发，同时 <code>controller.signal.aborted</code> 属性变为 <code>true</code>。</p>
<pre><code class="language-js">let controller = new AbortController();
fetch(url, {
  signal: controller.signal // 将 signal 属性传递给 fetch 参数
}); // fetch 会监听 signal 上的 abort

controller.abort(); // 调用 controller.abort() 来中止
</code></pre>
<p>当一个 <code>fetch</code> 被中止，它的 <code>promise</code> 就会以一个 error <code>AbortError</code> 被 reject：</p>
<pre><code class="language-js">try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // 处理 abort()
    alert(&quot;Aborted!&quot;);
  } else {
    throw err;
  }
}
</code></pre>
<p><code>AbortController</code> 是可扩展的，它允许一次取消多个 fetch。也可以等待需要完成的 <code>fetch</code> 异步网络请求后中止其他 <code>fetch</code>。</p>
<pre><code class="language-js">let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) =&gt; { // 需要完成的 fetch
  ...
  controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url =&gt; fetch(url, { // 所有 fetch
  signal: controller.signal
}));

// 等待完成我们的任务和所有 fetch
let results = await Promise.all([...fetchJobs, ourJob]);

// 如果 controller.abort() 被从其他地方调用，
// 它将中止所有 fetch 和 ourJob
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 高级 -- Context]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-context/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-context/">
        </link>
        <updated>2020-08-21T10:32:07.000Z</updated>
        <summary type="html"><![CDATA[<p>在 React 中数据总是单向传递的，如果某个属性许多组件都需要就会使该过程变得极其繁琐，Context 提供了在组件间共享此类数据的方式，而不必显式地通过组件树的逐层传递 props。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在 React 中数据总是单向传递的，如果某个属性许多组件都需要就会使该过程变得极其繁琐，Context 提供了在组件间共享此类数据的方式，而不必显式地通过组件树的逐层传递 props。</p>
<!-- more -->
<h3 id="什么情况下使用-context">什么情况下使用 Context</h3>
<ol>
<li>
<p>当某个（些）属性需要传递的层级很深时</p>
<p>考虑下面的例子：</p>
<pre><code class="language-jsx">class App extends Component {
  state = { count: 1 }
  render() {
    return (
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father count={this.state.count} /&gt;
        &lt;/div&gt;
    );
  }
}

class Father extends Component {
  render() {
    return (
      &lt;div className='father'&gt;
        &lt;h1&gt;这是父组件&lt;/h1&gt;
        &lt;Son count={this.props.count} /&gt;
      &lt;/div&gt;
    );
  }
}

class Son extends Component {
  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
      	&lt;h2&gt;{this.props.count}&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>如果 <code>Son</code> 组件需要来自根组件的 count，则需要从 <code>App</code> 组件开始通过props 属性自上而下传递给 <code>Son</code> 组件。使用 context, 我们可以避免通过中间元素传递 props：</p>
<pre><code class="language-jsx">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
// 为当前的 theme 创建一个 context（1为默认值）。
const countContext = React.createContext(1);
class App extends Component {
  state = { count: 1 };
  render() {
    return (
     // 使用一个 Provider 来将当前的 state 传递给以下的组件树。
    // 无论多深，任何组件都能读取这个值。
    // 在这个例子中，我们将 state 作为当前的值传递下去。
      &lt;Provider value={this.state}&gt;
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    );
  }
}

// 中间的组件再也不必指明往下传递了。
class Father extends Component {
  render() {
    return (
      &lt;div className='father'&gt;
        &lt;h1&gt;这是父组件&lt;/h1&gt;
        &lt;Son /&gt;
      &lt;/div&gt;
    );
  }
}

class Son extends Component {
  // 指定 contextType 读取当前的 count context。
  // React 会往上找到最近的 count Provider，然后使用它的值。
  // 在这个例子中，当前的 count 值为 1。
  static contextType = countContext; 
  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
        &lt;h2&gt;{this.context.count}&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
  // 也可使用 Consumer 渲染出 context
  /*
  render() {
    const { Consumer } = globalContext;
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
        &lt;h2&gt;{this.context.count}&lt;/h2&gt;
        &lt;Consumer&gt;{(context) =&gt; &lt;h2&gt;{context.count}&lt;/h2&gt;}&lt;/Consumer&gt;
        &lt;button onClick={this.add}&gt;点我加1&lt;/button&gt;
        &lt;button onClick={this.minus}&gt;点我减1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
  */
}
</code></pre>
<p>如何在 <code>Son</code> 组件中更改 Context 呢？</p>
<pre><code class="language-jsx">// 导出 context 修改函数
const actions = (self) =&gt; ({
  add() {
    self.setState((preState) =&gt; ({ count: preState.count + 1 }));
  },
  minus() {
    self.setState((preState) =&gt; ({ count: preState.count - 1 }));
  },
});

class App extends Component {
  // 扩展 actions 并传入 this
  state = { count: InitialContext.count, ...actions(this) };
  render() {
    return (
      &lt;Provider value={this.state}&gt;
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    );
  }
}

class Son extends Component {
  static contextType = globalContext;

  // 调用在 context 中定义好的加减函数
  add = () =&gt; {
    this.context.add();
  };

  minus = () =&gt; {
    this.context.minus();
  };

  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是子组件&lt;/h1&gt;
        &lt;h2&gt;{this.context.count}&lt;/h2&gt;
        &lt;button onClick={this.add}&gt;点我加1&lt;/button&gt;
        &lt;button onClick={this.minus}&gt;点我减1&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。如果仅仅是为了避免层层传递属性可以使用<strong>组件组合</strong>。</p>
</li>
<li>
<p>无亲属关系的组件需要共用的数据</p>
<p>考虑下面的例子：</p>
<pre><code class="language-jsx">class App extends Component {
  render() {
    return (
      &lt;div className='App'&gt;
        &lt;h1&gt;这是根组件&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

class Test extends Component {
  render() {
    return (
      &lt;div className='son'&gt;
        &lt;h1&gt;这是另一个组件&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p><code>App</code> 组件和 <code>Test</code> 组件既不是父子关系也不是兄弟关系，如果想要将 <code>App</code>组件中的数据传递给 <code>Test</code> 组件可以利用 Context 来实现：</p>
<pre><code class="language-jsx">const countContext = React.createContext(&quot;我是要传递的数据&quot;);
class App extends Component {
  render() {
    return (
      &lt;div className='App'&gt;
        &lt;h1&gt;这是根组件&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

class Test extends Component {
  static contextType = globalContext;

  render() {
    return (
      &lt;div className='test'&gt;
        &lt;h1&gt;这是另一个组件&lt;/h1&gt;
        &lt;h2&gt;{this.context}&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<p>Context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 <code>Provider</code> 的父组件进行重渲染时，可能会在 <code>Consumers</code> 组件中触发意外的渲染。举个例子，当每一次 <code>Provider</code> 重渲染时，以下的代码会重渲染所有下面的 <code>Consumers</code> 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>
<pre><code class="language-jsx">class App extends Component {
  render() {
    return (
      &lt;Provider value={1}&gt;
        &lt;div className='App'&gt;
          &lt;h1&gt;这是根组件&lt;/h1&gt;
          &lt;Father /&gt;
        &lt;/div&gt;
      &lt;/Provider&gt;
    );
  }
}
</code></pre>
<p>因此，将 <code>value</code> 状态提升到父节点的 <code>state</code> 中是更好的做法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 高级 -- 状态提升]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-zhuang-tai-ti-sheng/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-zhuang-tai-ti-sheng/">
        </link>
        <updated>2020-07-13T12:12:03.000Z</updated>
        <summary type="html"><![CDATA[<p>如果多个组件需要反映相同的变化数据，可将它们提升至最近的父组件，由父组件渲染后再分发个子组件。</p>
<p>下面是一个汇率转换示例</p>
]]></summary>
        <content type="html"><![CDATA[<p>如果多个组件需要反映相同的变化数据，可将它们提升至最近的父组件，由父组件渲染后再分发个子组件。</p>
<p>下面是一个汇率转换示例</p>
<!-- more -->
<p><code>Money</code>组件渲染出input标签：</p>
<pre><code class="language-js">import React, { Component } from &quot;react&quot;;

const scaleNames = {
  R: &quot;RMB&quot;,
  D: &quot;dollar&quot;,
};

class Money extends Component {
  handleChange = (e) =&gt; {
    this.props.onValueChange(e.target.value);
  };

  render() {
    const value = this.props.value;
    const scale = this.props.scale;
    return (
      &lt;fieldset&gt;
        &lt;legend&gt;请输入{scaleNames[scale]}:&lt;/legend&gt;
        &lt;input value={value} onChange={this.handleChange} /&gt;
      &lt;/fieldset&gt;
    );
  }
}

export default Money;
</code></pre>
<p><code>Calculator</code>组件我们会把当前输入的 <code>value</code> 和 <code>scale</code> 保存在组件内部的 state 中。这个 state 就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的<strong>共同“数据源”</strong>。这是我们为了渲染两个输入框所需要的所有数据的最小表示。</p>
<pre><code class="language-js">import React, { Component } from &quot;react&quot;;
import Money from &quot;./money&quot;;
import { toRMB, toDollar, tryConvert } from &quot;./transform&quot;;

class Calculator extends Component {
  constructor(props) {
    super(props);
    this.state = { value: 1, scale: &quot;R&quot; };
  }

  handleRMBChange = (value) =&gt; {
    this.setState({ scale: &quot;R&quot;, value });
  };

  handleDollarChange = (value) =&gt; {
    this.setState({ scale: &quot;D&quot;, value });
  };

  onValueChange = () =&gt; {
    this.setState({
      value: &quot;&quot;,
      scale: &quot;&quot;,
    });
  };

  render() {
    const scale = this.state.scale;
    const value = this.state.value;
    const RMB = scale === &quot;D&quot; ? tryConvert(value, toRMB) : value;
    const dollar = scale === &quot;R&quot; ? tryConvert(value, toDollar) : value;
    return (
      &lt;div&gt;
        &lt;Money scale=&quot;R&quot; value={RMB} onValueChange={this.handleRMBChange} /&gt; //人民币
        &lt;Money
          scale=&quot;D&quot;
          value={dollar}
          onValueChange={this.handleDollarChange}
        /&gt; //美元
      &lt;/div&gt;
    );
  }
}

export default Calculator;
</code></pre>
<p><code>transform</code>汇率转换组件：</p>
<pre><code class="language-js">export function toRMB(dollar) {
  return dollar * 7;
}

export function toDollar(RMB) {
  return RMB / 7;
}

export function tryConvert(value, convert) {
  const input = parseFloat(value);
  if (Number.isNaN(input)) {
    return &quot;&quot;;
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}
</code></pre>
<p>当对输入框内容进行编辑时会发生些什么:</p>
<ol>
<li>React 会调用 DOM 中 <code>&lt;input&gt;</code> 的 <code>onChange</code> 方法。在本实例中，它是 <code>Money</code> 组件的 <code>handleChange</code> 方法。</li>
<li><code>Money</code> 组件中的 <code>handleChange</code> 方法会调用 <code>this.props.onValueChange()</code>，并传入新输入的值作为参数。其 props 诸如 <code>onValueChange</code> 之类，均由父组件 <code>Calculator</code> 提供。</li>
<li>起初渲染时，用于人民币输入的子组件 <code>Money</code> 中的 <code>onValueChange</code> 方法与 <code>Calculator</code> 组件中的 <code>handleRMBChange</code> 方法相同，而，用于美元输入的子组件 <code>Money</code> 中的 <code>onValueChange</code> 方法与 <code>Calculator</code> 组件中的 <code>handleDollarChange</code> 方法相同。因此，无论哪个输入框被编辑都会调用 <code>Calculator</code> 组件中对应的方法。</li>
<li>在这些方法内部，<code>Calculator</code> 组件通过使用新的输入值与当前输入框对应的货币类型来调用 <code>this.setState()</code> 进而请求 React 重新渲染自己本身。</li>
<li>React 调用 <code>Calculator</code> 组件的 <code>render</code> 方法得到组件的 UI 呈现。汇率转换在这时进行，两个输入框中的数值通过当前输入值和其货币类型来重新计算获得。</li>
<li>React 使用 <code>Calculator</code> 组件提供的新 props 分别调用两个 <code>Money</code> 子组件的 <code>render</code> 方法来获取子组件的 UI 呈现。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 高级 -- 表单]]></title>
        <id>https://keasar.com.cn/post/react-gao-ji-biao-dan/</id>
        <link href="https://keasar.com.cn/post/react-gao-ji-biao-dan/">
        </link>
        <updated>2020-07-13T12:08:48.000Z</updated>
        <summary type="html"><![CDATA[<ol>
<li>
<p>受控组件</p>
<p>利用 state 管理 input等标签 的输入内容。内容只能通过 <strong>setState</strong> 改变。</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<ol>
<li>
<p>受控组件</p>
<p>利用 state 管理 input等标签 的输入内容。内容只能通过 <strong>setState</strong> 改变。</p>
</li>
</ol>
<!-- more -->
<pre><code class="language-js">class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  //没有onChange事件会触发警告，导致文本框中的内容无法更改和显示
  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          名字:
          &lt;input type=&quot;text&quot; value={this.state.value} onChange={this.handleChange} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
<ol start="2">
<li>
<p>非受控组件</p>
<p>建议采用受控组件，但是当你需要编写很多事件处理函数时可以使用非受控组件，即使用 ref 获取到真实的DOM节点。</p>
<pre><code class="language-js">class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef(); 
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value); //通过current定位到当前DOM节点
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit}&gt;
        &lt;label&gt;
          Name:
          &lt;input type=&quot;text&quot; ref={this.input} /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统（三）--  处理机调度与死锁]]></title>
        <id>https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/</id>
        <link href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">
        </link>
        <updated>2020-06-09T04:21:13.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a></p>
<h3 id="1-处理机调度的层次和调度算法的目标">1. 处理机调度的层次和调度算法的目标</h3>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a></p>
<h3 id="1-处理机调度的层次和调度算法的目标">1. 处理机调度的层次和调度算法的目标</h3>
<!-- more -->
<ol>
<li>
<p>处理机调度的层次</p>
<ul>
<li>高级调度：对象是作业，将处于后备队列的作业调入到内存。</li>
<li>中级调度：即内存调度，旨在提高内存利用率和系统吞吐量，将暂时不能运行/能运行的进程调出/入内存。</li>
<li>低级调度：对象是进程，决定就绪队列中哪个进程获得处理机，运行频率最高。</li>
</ul>
</li>
<li>
<p>调度算法的目标</p>
<ul>
<li>
<p>共同目标</p>
<ul>
<li>
<p>资源利用率，即尽可能使所有资源都处于忙碌状态</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/09/t4UP3T.png" alt="t4UP3T.png" loading="lazy"></figure>
</li>
<li>
<p>公平性</p>
</li>
<li>
<p>平衡性</p>
</li>
<li>
<p>策略强制执行</p>
</li>
</ul>
</li>
<li>
<p>批处理系统目标</p>
<ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
</li>
<li>
<p>分时系统的目标</p>
<ul>
<li>响应时间快</li>
<li>均衡性</li>
</ul>
</li>
<li>
<p>实时系统的目标</p>
<ul>
<li>截止时间的保证</li>
<li>可预测性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-作业与作业调度">2. 作业与作业调度</h3>
<ol>
<li>
<p>批处理系统中的作业</p>
<ul>
<li>作业：包含通常的程序和数据即作业说明书。</li>
<li>作业步：各个作业间相互独立，每个加工步骤成为一个作业步。</li>
<li>作业控制块(JCB)：作业进入系统时建立JCB，保存了对作业进行管理和调度所需的全部信息。</li>
<li>三种状态和三个阶段
<ul>
<li>收容阶段(后备状态)</li>
<li>运行阶段(运行状态)</li>
<li>完成阶段(完成状态)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>作业调度</p>
<ul>
<li>
<p>先来先服务(FCFS)调度算法：可用于作业、进程调度，系统按照作业到达的先后次序进行调度。</p>
</li>
<li>
<p>短作业优先(SJF)调度算法：可用于作业、进程调度，作业越短优先级越高。</p>
<ul>
<li>优点：能有效地降低作业的平均等待时间，提高系统吞吐量。</li>
<li>缺点：需要预知作业运行时间；对长作业不利；无法实现交互；未考虑作业优先性。</li>
</ul>
</li>
<li>
<p>高优先权优先调度算法</p>
<ul>
<li>
<p>优先级调度算法(PSA)的类型</p>
<ul>
<li>非抢占式优先权算法：主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
<li>抢占式优先权调度算法：常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
<li>
<p>优先权的类型<br>
① 静态优先权：静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变<br>
② 动态优先权：动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</p>
</li>
<li>
<p>高响应比优先(HRRN)调度算法：既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。<br>
Rp优先级 =（等待时间 + 要求服务时间）/ 要求服务时间 = 响应时间 / 要求服务时间</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-进程调度">3. 进程调度</h3>
<ol>
<li>
<p>进程调度的任务、机制和方式</p>
<ul>
<li>
<p>任务</p>
<p>① 保存处理及现场信息；</p>
<p>② 按某种算法选取进程；</p>
<p>③ 把处理器分配给进程。</p>
</li>
<li>
<p>机制</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/09/t40Ez6.png" alt="t40Ez6.png" loading="lazy"></figure>
</li>
<li>
<p>方式</p>
<p>① 非抢占方式：进程一旦分配到处理机，就让其一直运行下去，不会因其他条件抢占当前正在运行进程的处理机，直至结束。</p>
<p>② 抢占方式：暂停某个正在运行的进程，将其处理机分配给另一个进程。遵循三个原则：优先权原则、短进程优先原则、时间片原则。</p>
</li>
</ul>
</li>
<li>
<p>轮转调度算法</p>
<p>主要应用于分时系统。</p>
<p>让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有 n 个进程，则每个进程每次大约都可获得 1/n 的处理机时间。</p>
<p>时间片大小的确定：时间片略大于一次典型的交互所需要的时间。</p>
</li>
<li>
<p>多队列调度算法</p>
<p>将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法。</p>
</li>
<li>
<p>多级反馈队列调度算法</p>
<p>设置多个就绪队列，每个就绪队列都采用 <em><strong>FCFS</strong></em> 算法，按队列优先级调度。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/09/t4suct.png" alt="t4suct.png" loading="lazy"></figure>
<p>若进程在本就绪队列的时间片完成则结束该进程，否则进入下一优先级就绪队列末尾等待执行，以此类推；若进程从阻塞队列被唤醒，则插入到比其本身高一优先级队列的末尾执行。</p>
</li>
</ol>
<h3 id="4-实时调度">4. 实时调度</h3>
<ol>
<li>
<p>实现条件</p>
<p>① 提供必要的信息<br>
② 系统处理能力强<br>
③ 采用抢占式调度机制<br>
④ 具有快速切换机制</p>
</li>
<li>
<p>分类<br>
① 非抢占式调度算法</p>
<ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ul>
<p>② 抢占式调度算法</p>
<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/09/t4ck7T.png" alt="t4ck7T.png" loading="lazy"></figure>
</li>
<li>
<p>最早截止时间优先(EDF)算法：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。具有最早截止时间的任务排在队列的最前面。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。</p>
</li>
<li>
<p>最低松弛度优先(LLF)算法：根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。</p>
</li>
</ol>
<h3 id="5-死锁概述">5. 死锁概述</h3>
<ol>
<li>
<p>资源</p>
<ul>
<li>可重用性资源：可供用户重复使用多次的资源；此类资源中的单元只能分配给一个进程使用，不允许多个进程共享；遵循请求资源 -&gt; 使用资源 -&gt; 释放资源的顺序；数目固定，进程既不能创建也不能删除。</li>
<li>可消耗性资源：临时性资源，由进程在运行期间动态地创建和删除。</li>
<li>可抢占性资源：某进程得到该资源后，该资源仍可被其他进程或系统抢占，如CPU、主存等。</li>
<li>不可抢占性资源：某进程得到该资源后，不能将此类资源强制回收，只能等待其主动释放，如打印机等。</li>
</ul>
</li>
<li>
<p>计算机系统中的死锁</p>
<ul>
<li>
<p>竞争不可抢占性资源引起死锁</p>
<img src="https://s1.ax1x.com/2020/06/09/t420k8.png" alt="t420k8.png" style="zoom:80%;" />
</li>
<li>
<p>竞争可消耗资源引起死锁</p>
</li>
<li>
<p>进程推进顺序不当引起死锁</p>
<img src="https://s1.ax1x.com/2020/06/09/t4RS9e.png" alt="t4RS9e.png" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>死锁</p>
<ul>
<li>
<p>定义：在多道程序系统中，一组进程中的每一个进程都在无限期地等待另一组进程所占有且永远不会释放的资源。</p>
</li>
<li>
<p>产生的必要条件</p>
<p>① 互斥条件</p>
<p>② 请求和保持条件</p>
<p>③ 不可抢占条件</p>
<p>④ 循环等待条件</p>
</li>
<li>
<p>处理死锁的方法</p>
<p>① 预防死锁</p>
<p>② 避免死锁</p>
<p>③ 检测死锁</p>
<p>④ 解除死锁</p>
</li>
</ul>
</li>
</ol>
<h3 id="6-预防死锁">6. 预防死锁</h3>
<ol>
<li>
<p>破坏“请求和保持”条件</p>
<ul>
<li>
<p>第一种协议：进程在运行前，必须一次性地申请运行过程中的全部资源。</p>
<ul>
<li>优点：简单、易行、安全。</li>
<li>缺点：资源被严重浪费，严重恶化了资源利用率；使进程经常会发生饥饿现象(某进程所需某资源可能被其他进程长期占用)。</li>
</ul>
</li>
<li>
<p>第二种协议：获得运行必不可少的资源后立即开始运行，在运行过程中逐步释放已分配的且已用毕的资源再申请所需新资源。</p>
<ul>
<li>使进程更快完成任务，提高设备利用率，减少进程发生饥饿的几率。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>破坏“不可抢占”条件</p>
<p>进程已占有的资源会被暂时地释放，待以后需要时再重新申请。</p>
<ul>
<li>代价较高，延长了进程周转时间，增加了系统开销，降低了系统吞吐量。</li>
</ul>
</li>
<li>
<p>破坏“循环等待”条件</p>
<p>对系统所有资源类型线性排序，规定每个进程必须按序号递增的顺序请求资源</p>
<ul>
<li>优缺点：限制了新类型设备的增加，造成资源浪费，限制用户简单、自主编程。</li>
</ul>
</li>
</ol>
<h3 id="7-避免死锁">7. 避免死锁</h3>
<p><strong>避免死锁的实质在于,系统在进行资源分配时,应使系统不进入不安全状态。</strong></p>
<ol>
<li>
<p>安全状态：在系统进行资源分配前计算此次资源分配是否安全，安全则分配，否则令进程等待。</p>
</li>
<li>
<p>利用银行家算法避免死锁</p>
<ul>
<li>
<p>数据结构</p>
<p>可用 <em>Available</em><br>
最大需求 <em>Max</em><br>
已分配 <em>Allocation</em><br>
还需要 <em>Need</em></p>
<p><em>Need = Max - Allocation</em></p>
</li>
<li>
<p>银行家算法</p>
<p>设 Requesti 是进程 Pi 的请求向量，如果 Requesti[ j ] == K，表示进程 Pi 需要 K 个 Rj 类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査</p>
<p>(1) 如果 Requesti[ j ] ≤ Need[ i, j ]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。<br>
(2) 如果 Requesti[ j ] ≤ Available[ i ]，便转向步骤(3)；否则，表示尚无足够资源，Pi 须等待。<br>
(3) 系统试探把资源分配给进程 Pi 并修改下面数据结构中的数值</p>
<blockquote>
<p>Available[ j ] = Available[ j ] - Requesti[ j ]</p>
<p>Allocation[ i, j ] = Allocation[ i, j ] + Requesti[ j ]</p>
<p>Need[ i, j ] = Need[ i, j ] - Requesti[ j ]</p>
</blockquote>
<p>(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程P，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程P等待。</p>
</li>
<li>
<p>安全性算法</p>
<p>(1) 设置两个向量：①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全性算法开始时，</p>
<p>Wok = Available；② Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[ i ] = false；当有足够资源分配给进程时，再令 Finish[ i ] = true。<br>
(2) 从进程集合中找到一个能满足下述条件的进程 ① Finish[ i ] = false；② Needl[ i, j ] ≤ Work[ j ]；若找到，执行步骤(3)，否则，执行步骤(4)。<br>
(3) 当进程 P 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行</p>
<blockquote>
<p>Work[ j ] = Work[ j ] + Allocation[ i, j ]</p>
<p>Finish[ i ] = true</p>
<p>go to step 2；</p>
</blockquote>
<p>(4) 如果所有进程的 Finish[ⅰ] = true 都满足,则表示系统处于安全状态，否则，系统处于不安全状态。</p>
</li>
</ul>
</li>
</ol>
<h3 id="8-死锁的检测与解除">8. 死锁的检测与解除</h3>
<ol>
<li>
<p>检测</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/09/t44dJK.png" alt="t44dJK.png" loading="lazy"></figure>
<p>若能消去图中所有的边，使所有的进程结点都成为孤立结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。</p>
</li>
<li>
<p>死锁的解除</p>
<ul>
<li>抢占资源。从一个或多个进程中抢占足够数量的资源,分配给死锁进程,以解除死锁状态。</li>
<li>终止(或撇消)进程。终止(或撤消)系统中的一个或多个死锁进程,直至打破循环环路,使系统从死锁状态解脱出来。
<ul>
<li>终止所有死锁进程</li>
<li>逐个终止进程</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统学习笔记（二）--  进程的描述与控制]]></title>
        <id>https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/</id>
        <link href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">
        </link>
        <updated>2020-06-08T07:29:37.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
<a href="https://imgchr.com/i/tRv9l6"><img src="https://s1.ax1x.com/2020/06/08/tRv9l6.md.png" alt="tRv9l6.md.png" style="zoom:80%;" /></a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">操作系统学习笔记（一）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
<a href="https://imgchr.com/i/tRv9l6"><img src="https://s1.ax1x.com/2020/06/08/tRv9l6.md.png" alt="tRv9l6.md.png" style="zoom:80%;" /></a></p>
<!-- more -->
<h3 id="1-前趋图和程序执行">1. 前趋图和程序执行</h3>
<ol>
<li>
<p>前驱图</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/08/tRv4BD.png" alt="tRv4BD.png" loading="lazy"></figure>
</li>
<li>
<p>程序的顺序执行</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/08/tRv74A.png" alt="tRv74A.png" loading="lazy"></figure>
<p>特征：</p>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
</li>
<li>
<p>程序的井发执行</p>
<p>特征：</p>
<ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
</li>
</ol>
<h3 id="2-进程的描述">2. 进程的描述</h3>
<ol>
<li>
<p>进程的定义和特征</p>
<ol>
<li>
<p>定义</p>
<ul>
<li>由程序段、相关的数据段和 <strong>PCB</strong> 三部分便构成了进程实体(又称进程映像)。</li>
</ul>
</li>
<li>
<p>特征</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>进程的基本状态及转换</strong></p>
<ol>
<li>
<p>三种基本状态</p>
<ul>
<li>就绪 Ready</li>
<li>执行 Running</li>
<li>阻塞 Block</li>
</ul>
</li>
<li>
<p>三种基本状态的转换</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/08/tRzKeS.png" alt="tRzKeS.png" loading="lazy"></figure>
<ul>
<li>就绪状态→执行状态：为就绪队列队首的程序分配处理器。</li>
<li>执行状态→就绪状态：时间片用完</li>
<li>执行状态→阻塞状态：I/O请求</li>
<li>阻塞状态→就绪状态：I/O完成</li>
</ul>
</li>
<li>
<p>加入创建和终止的五状态转换</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/08/tWSVk4.png" alt="tWSVk4.png" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>挂起操作和进程状态的转换</p>
<p>​		当该操作作用千某个进程时，该进程将被<strong>挂起</strong>，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。 若原本处千就绪状态， 则该进程此时暂不接受调度。与挂起操作对应的操作是激活操作。</p>
<ol>
<li>
<p>挂起操作的引入</p>
<ul>
<li>终端用户的需要</li>
<li>父进程请求</li>
<li>负荷调节的需要</li>
<li>操作系统的需要</li>
</ul>
</li>
<li>
<p>引入挂起原语操作后三个进程状态的转换</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/08/tWPNa8.png" alt="tWPNa8.png" loading="lazy"></figure>
<ul>
<li>活动就绪(Readya) → 静止就绪(Readys)：未被挂起可以接受调度为Readya，挂起原语 Suspend 将该进程挂起后，变为Readys，不能接受调度。</li>
<li>活动阻塞(Blockeda) → 静止阻塞(Blockeds)：未被挂起的阻塞为Blockeda，经 Suspend 挂起后，为 Blockeds；处于该状态的进程在其所期待的事件出现后，它将从 Blockeds 变为 Readys 状态。</li>
<li>静止就绪(Readys) → 活动就绪(Readya)：处于 Readys 的进程被激活原语 Active 激活。</li>
<li>静止阻塞(Blockeds) → 活动阻塞(Blockeda)：。处于 Blockeds 的进程被激活原语 Active 激活。</li>
</ul>
</li>
<li>
<p>引入挂起操作后五个进程状态的转换</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/08/tWPdPg.png" alt="tWPdPg.png" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>进程管理中的数据结构</p>
<ol>
<li>
<p>进程控制块 PCB 的作用</p>
<p>PCB 的作用是使 在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位一个能与其他进程并发执行的进程。</p>
<ul>
<li>作为独立运行基本单位的标志</li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其它进程的同步与通信</li>
</ul>
</li>
<li>
<p>PCB 中的信息</p>
<ol>
<li>
<p>进程标识符</p>
<ul>
<li>外部 ~ 用户</li>
<li>内部 ~ OS</li>
</ul>
</li>
<li>
<p>处理机状态</p>
<p>即处理机的上下文，由下面的寄存器组成</p>
<ul>
<li>通用寄存器：用户程序可访问，用于暂存信息。</li>
<li>指令计数器：存放要访问的下一条指令的地址。</li>
<li>程序状态字 PSW：含有状态信息，如条件码、执行方式、中断屏蔽标志。</li>
<li>用户栈指针：用于存放过程和系统调用参数及调用地址。</li>
</ul>
</li>
<li>
<p>进程调度信息</p>
<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>进程调度其他信息</li>
<li>事件</li>
</ul>
</li>
<li>
<p>进程控制信息</p>
<ul>
<li>程序和数据的地址</li>
<li>程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
</li>
</ol>
</li>
<li>
<p>进程控制块的组织方式</p>
<ul>
<li>
<p>线性方式</p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/08/tWktVx.png" alt="tWktVx.png" loading="lazy"></figure>
</li>
<li>
<p>链接方式</p>
<figure data-type="image" tabindex="8"><img src="https://s1.ax1x.com/2020/06/08/tWkrMd.png" alt="tWkrMd.png" loading="lazy"></figure>
</li>
<li>
<p>索引方式</p>
<figure data-type="image" tabindex="9"><img src="https://s1.ax1x.com/2020/06/08/tWkhRg.png" alt="tWkhRg.png" loading="lazy"></figure>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="3-进程控制">3. 进程控制</h3>
<ol>
<li>
<p>操作系统内核</p>
<p>分类：</p>
<ul>
<li>系统态（管态）：高权限，能执行一切指令，传统 OS 运行在此。</li>
<li>应用态（目态）：低权限，只能运行一部分指令，应用程序运行在此。</li>
</ul>
<p>功能：</p>
<ol>
<li>
<p>支撑功能</p>
<ul>
<li>中断处理</li>
<li>时钟管理</li>
<li>原语操作</li>
</ul>
</li>
<li>
<p>资源管理功能</p>
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ol>
</li>
<li>
<p>进程的创建与撤销</p>
<ol>
<li>
<p>创建</p>
<ul>
<li>方式：由系统程序创建、由父进程创建</li>
<li>引起创建的事件：用户登录、作业调度、提供服务、应用请求</li>
<li>过程：<br>
① 申请空白PCB<br>
② 为新进程分配资源<br>
③ 初始化进程控制块<br>
④ 将新进程插入就绪队列</li>
</ul>
</li>
<li>
<p>撤销</p>
<ul>
<li>
<p>方式：由操作系统终止、有进程发出请求</p>
</li>
<li>
<p>引起撤销的事件：正常结束、异常结束（越界错误、运行超时）、外界干预（父进程请求、父进程终止）</p>
</li>
<li>
<p>过程：</p>
<p>① 根据标识符找到该进程，读取状态</p>
<p>② 若正处于执行状态，立即终止该，并置调度标志为真，用于指示该进程被终止后应重新进行调度</p>
<p>③ 若该进程还有子孙进程，一并终止</p>
<p>④ 将该进程所有资源还给父进程或 OS</p>
<p>⑤ 将该进程 PCB 移出PCB表</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>进程的阻塞与唤醒</p>
<ol>
<li>
<p>引起阻塞或唤醒的主要事件：</p>
<ul>
<li>请求系统服务</li>
<li>启动某些操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ul>
</li>
<li>
<p>进程阻塞过程</p>
<p>​		正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语 block 将自己阻塞(主动行为)。立即停止执行，把进程控制块中的现行状态由“执行“改为阻塞，并将 PCB 插入阻塞队列。</p>
</li>
<li>
<p>进程唤醒过程</p>
<p>​		调用唤醒原语 wakeup， 首先把被阻塞的进程从等待该事件的阻塞队列中移出， 将其 PCB 的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。</p>
</li>
</ol>
</li>
<li>
<p>程序的挂起与激活</p>
<p>激活过程：（挂起为其逆过程）</p>
<ul>
<li>将进程从外存调入内存</li>
<li>检查该进程现行状态</li>
<li>若是静止就绪，改为活动就绪；若是静止阻塞，改为活动阻塞</li>
</ul>
</li>
</ol>
<h3 id="4-进程同步">4. 进程同步</h3>
<p>为保证多个进程能有条不紊地运行，在多道程序系统中，必须引入进程同步机制。</p>
<ol>
<li>
<p>进程同步的基本概念</p>
<ol>
<li>
<p>两种形式的制约关系</p>
<ul>
<li>间接相互制约关系</li>
<li>直接相互制约关系</li>
</ul>
</li>
<li>
<p>临界资源</p>
<p>​		虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p>
</li>
<li>
<p>临界区</p>
<p>在每个进程中访问临界资源的那段代码称为临界区。</p>
<p>访问临界资源的循环进程描述如下：</p>
<pre><code class="language-c">while (TRUE) 
{
	进入区
	临界区
	退出区
	剩余区
}
</code></pre>
</li>
<li>
<p>同步机制应遵循的规则</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
</ol>
</li>
<li>
<p>硬件同步机制</p>
<ol>
<li>
<p>关中断</p>
</li>
<li>
<p>利用 <em><strong>Test-and-Set</strong></em> 指令实现互斥</p>
<pre><code class="language-C">//lock=FALSE 时，表示该资源空闲； lock=TRUE 时， 表示该资源正在被使用。
boolean TS(boolean *lock) 
{
	Boolean old;
	old = *lock;
	*lock = TRUE;
	return old;
}
</code></pre>
<pre><code class="language-C">//为每个临界资源设置一个布尔变量lock, 初值为FALSE, 表示该临界资源空闲。进程在进入临界区之前，首先用TS测试lock, 若为FALSE则表示没有进程在临界区可以进入，并将TRUE值赋予lock，即关闭临界资源，使任何进程都不能进入临界区，否则必须循环测试直到TS(s)为TRUE。
do {
	while TS(&amp;lock);
	critical section;
	lock := FALSE;
	remainder section;
} while(TRUE) ; 
//不符合让权等待原则
</code></pre>
</li>
<li>
<p>利用 <em><strong>Swap</strong></em> 指令实现进程互斥</p>
<pre><code class="language-C">void swap(boolean *a, booJean *b)
{
	boolean temp ;
	temp = *a;
	*a = *b;
	*b = temp; 
}
</code></pre>
<pre><code class="language-c">//为每个临界资源设置一个全局的布尔变lock，其初值为false，在每个进程中再利用一个局部布尔变量key
do {
	key=TRUE;
	do {
	swap(&amp;lock , &amp;key);
} while (key!=FALSE );
	/*临界区操作*/
	lock = FALSE;
} while (TRUE); 
//不符合让权等待原则
</code></pre>
</li>
</ol>
</li>
<li>
<p>信号量机制</p>
<ol>
<li>
<p>整型信号量</p>
<pre><code class="language-C">//S表示资源数目；P-V操作
wait(S)
{
	while (S&lt;=O);
	S--;
}
signal(S)
{
	S++; 
}
//不符合让权等待原则
</code></pre>
</li>
<li>
<p>记录型信号量</p>
<pre><code class="language-C">typedef struct {
	int value; //表示资源数目
	struct process_control_block *list; //用于链接所有等待进程
} semaphore ; 
</code></pre>
<pre><code class="language-C">//每次wait操作代表有一个进程试图访问临界资源
wait(semap hore *S) 
{ 
	S-&gt;value--; //临界资源减1之后，≥0代表还有资源可以访问
	if (S-&gt;value &lt; 0) block (S-&gt;list); //小于0随即进入等待队列
}

//每次signal操作代表有一个进程试图释放临界资源
signal(semaphore *S) 
{
	S-&gt;value++; //临界资源加1后，小于0代表还没有临界资源可以访问
	if (S-&gt;value &lt;= O) wakeup(S-&gt;list); //≤0代表还有进程试图访问临界资源，随即唤醒等待队列中的第一个进程
}
</code></pre>
</li>
<li>
<p>AND 型信号量</p>
<p>适用于一个进程需要访问两个及以上的临界资源。</p>
<pre><code class="language-C">Swait(Sl , S2,..., Sn)
{
	while (TRUE)
	{
		if (Si&gt;=1 &amp;&amp;... &amp;&amp; Sn&gt;=1)
        {
			for (i=1; i&lt;=n; i++) Si--;
			break; 
        }
        else 
        {
			place the process in the waiting queue associated with the frrst Si found with
			Si&lt;1 , and set the program count of this process to the beginning of Swait operation 
        }
	}
}

Ssignal(Sl , S2, .. ., Sn)
{
	while (TRUE) 
    {
		for(i=1; i&lt;=n; i++) 
        {
			Si++;
			Remove all the process waiting in the queue associated with Si into the ready queue 
        }
    }
}
</code></pre>
</li>
<li>
<p>信号量集</p>
<p>对 AND 信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量在一次 P、V 原语操作中完成申请或释放。</p>
<pre><code class="language-c">//资源分配下限值ti,即要求Si≥ti,否则不予分配。一旦允许分配，进程对该资源的需求值为di,即表示资源占用量,进行Si = Si - di操作。
Swait(S1 t1, d1, ..., Sn, tn, dn);

Ssignal(S1, d1,.. ., Sn, dn);
</code></pre>
<pre><code class="language-C">Swait(S, d, d) //此时在信号量集中只有一个信号量S, 但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
Swait(S, 1, 1) //此时的信号量集已蜕化为一般的记录型信号量(S &gt; 1时）或 互斥信号量(S = 1时）。
Swait(S, 1, 0) //当 S≥1 时，允许多个进程进入某特定区;当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。
</code></pre>
</li>
</ol>
</li>
<li>
<p>信号量的应用</p>
<ol>
<li>
<p>利用信号量实现进程互斥</p>
<pre><code class="language-c">//mutex 互斥信号量其初值为1, 当mutex = 1时，表示两个进程皆未进入需要互斥的临界区; mutex = 0，表示有一个进程进入临界区运行，另外一个必须等待，挂入阻塞队列; 当mutex = -1 时，表示有一个进程正在临界区运行，另个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。
semaphore mutex= 1;
P(A)
{
    while(1) 
    {
		wait(mutex);
    	/*临界区*/
		signal(mutex);
		/*剩余区*/
	}
}

P(B)
{
    while(1)
    {
		wait(mutex);
		/*临界区*/
		signal(mutex);
		/*剩余区*/
    }
}
//wait(mutex) signal(mutex) 必须成对地出现，缺少wait(mutex)将会导致系统混乱，不能保证对临界资源的互斥访问; 缺少signal(mutex)将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程不能被唤醒。
</code></pre>
</li>
<li>
<p>利用信号量实现前趋关系</p>
<figure data-type="image" tabindex="10"><img src="https://s1.ax1x.com/2020/06/08/tW88Q1.png" alt="tW88Q1.png" loading="lazy"></figure>
<pre><code class="language-C">p1() { S1; signal(a); signal(b);}
p2() { wait(a); S2; signal(c); signal(d);}
p3() { wait(b); S3; signal(e);}
p4() { wait(c); S4; signal(t);}
p5() { wait(d); Ss; signal(g);}
p6() { wait(e); wait(f); wait(g); S6;}
main() 
{
    semaphore a, b, c, d, e, f, g;
    a.value = b.value = c.value = 0；
    d.value = e.value = 0;
    f.value = g.value = 0;
    cobegin
        pl(); p2(); p3(); p4(); p5(); p6(); 
    coend
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="5-经典进程的同步问题">5. 经典进程的同步问题</h3>
<ol>
<li>
<p>生产者－消费者问题</p>
<ul>
<li>
<p>问题描述</p>
<p>​		一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p>
</li>
<li>
<p>问题分析</p>
<ol>
<li>
<p>关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</p>
</li>
<li>
<p>整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。</p>
</li>
<li>
<p>信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-C">int in=0, out=0; //指向生产、消费的指针
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
void producer() //生产者进程
{ 
    do{
        produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元 /*wait(empty);wait(mutex); 或 Swait(empty, mutex );*/
        P(mutex);  //进入临界区
        add nextp to buffer;  //将数据放入缓冲区
        in=(in+ 1) % n; //指针后移
        V(mutex);  //离开临界区,释放互斥信号量 /*signal(mutex);signal(full); 或 Ssignal(mutex, full);*/
        V(full);  //满缓冲区数加1
    }while(TRUE)
}
void consumer() //消费者进程
{  
    do{
        P(full);  //获取满缓冲区单元 /*wait(full);wait(mutex); 或 Swait(full, mutex );*/
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        out=(out+l) % n; //指针后移
        V (mutex);  //离开临界区，释放互斥信号量 /*signal(mutex);signal(empty); 或 Ssignal(mutex, empty);*/
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    }while(TRUE)
}
</code></pre>
<p>该类问题要注意对缓冲区大小为 <em>n</em> 的处理，当缓冲区中有空时便可对empty变量执行 P操作，一旦取走一个产品便要执行 V操作 以释放空闲区。对empty和full变量的 P操作 必须放在对 <em>mutex</em> 的 P操作 之前。</p>
<blockquote>
<p>如果生产者进程先执行P(mutex)，然后执行P(empty)，消费者执行P(mutex),然后执行P(fall),这样可不可以？</p>
<p>答案是否定的。设想生产者进程已经将缓冲区放满，消费者进程并没有取产品，即 empty = 0，当下次仍然是生产者进程运行时，它先执行P(mutex)封锁信号量，再执行P(empty)时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行P(mutex)，然而由于生产者进程已经封锁mutex信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，陷入了无休止的等待。同理，如果消费者进程已经将缓冲区取空，即 full = 0,下次如果还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex、full先释放哪一个无所谓，消费者先释放mutex还是empty都可以。</p>
</blockquote>
</li>
<li>
<p>哲学家进餐问题</p>
<ul>
<li>
<p>问题描述</p>
<p>​		一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
</li>
<li>
<p>问题分析</p>
<ol>
<li>
<p>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li>
<p>整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。</p>
</li>
<li>
<p>信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {1, 1, 1, 1, 1}用于对5个筷子的互斥访问。</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-c">//对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
void Pi() //i号哲学家的进程
{  
    do{
        P(chopstick[i]); //取左边筷子 /*wait(chopstick[i]);wait(chopstick[(i+l)%5]); 或 Sswait(chopstick[(i+1)%5], chopstick[i]);*/
        P(chopstick[(i+1)%5]); //取右边篌子
        eat; //进餐
        V(chopstick[i]); //放回左边筷子 /*signal(chopstick[i]);signal(chopstick[(i+l)%5]); 或 Ssignal(chopstick[(i+1)%5], chopstick[i]);*/
        V(chopstick[(i+l)%5]); //放回右边筷子
        think; //思考
    } while(1);
}
</code></pre>
<p>该算法存在以下问题：<br>
当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完<em>wait(chopstick[i]</em>);)筷子已经被拿光了，等到他们再想拿右边的筷子的时候（执行 <em>wait(chopstick[(i+l)%5]</em>);)就全被阻塞了，这就出现了死锁。</p>
<p>​		为了防止死锁的发生，可以对哲学家进程施加一些限制条件：</p>
<ul>
<li>至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有 1 位哲学家能 够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐</li>
<li>仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐</li>
<li>规定奇数号哲学家先拿左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定将是 1、2号哲学家竞争 1号筷子，3、4号哲学家竞争 3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有 1位哲学家 能获得两只筷子而进餐.</li>
</ul>
</li>
<li>
<p>读者-写者问题</p>
<ul>
<li>
<p>问题描述</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：<br>
① 允许多个读者可以同时对文件执行读操作；<br>
② 只允许一个写者往文件中写信息；<br>
③ 任一写者在完成写操作之前不允许其他读者或写者工作；<br>
④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>
</li>
<li>
<p>问题分析</p>
<ol>
<li>
<p>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
</li>
<li>
<p>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。</p>
</li>
<li>
<p>信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-C">int count=0;  //用于记录当前的读者数量
semaphore mutex=1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
void writer() //写者进程
{  
    do{
        P(rw); // 互斥访问共享文件
        Writing;  //写入
        V(rw) ;  //释放共享文件
    }while(TRUE)
}
void reader () //读者进程
{  
    do{
        P (mutex) ;  //互斥访问count变量
        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写
        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        reading;  //读取
        P (mutex) ;  //互斥访问count变量
        count--; //读者计数器减1
        if (count==0)  //当最后一个读进程读完共享文件
            V(rw) ;  //允许写进程写
        V (mutex) ;  //释放互斥变量 count
    }while(TRUE)
}
void main() 
{
	cobegin
	reader(); writer();
	coend 
}
</code></pre>
</li>
</ol>
<h3 id="6-进程通信">6. 进程通信</h3>
<ol>
<li>
<p>类型</p>
<p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。</p>
<ol>
<li>
<p>共享存储器系统</p>
<ul>
<li>基于共享数据结构的通信方式：通信效率低下，属于低级通信。</li>
<li>基于共享存储区的通信方式：属于高级通信。</li>
</ul>
</li>
<li>
<p>管道(pipe)通信系统</p>
<p>​		一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p>
</li>
<li>
<p>消息传递系统</p>
<p>​		以格式化的消息(Message)为单位。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>
<ul>
<li>直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li>
<li>间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。</li>
</ul>
</li>
<li>
<p>客户机－服务器系统</p>
<ul>
<li>套接字Socket
<ul>
<li>基于文件型</li>
<li>基于网络型</li>
</ul>
</li>
<li>远程过程调用和远程方法调用</li>
</ul>
</li>
</ol>
</li>
<li>
<p>消息传递通信的实现方式</p>
<ol>
<li>
<p>直接消息传递系统</p>
<ul>
<li>
<p>直接通信原语</p>
<ul>
<li>
<p>对称寻址方式</p>
<p>send(recei ver, message); 发送一个消息给接收进程</p>
<p>receive(sender, message); 接收 Sender 发来的消息</p>
<p>缺点：进程一旦改变名字，则要找到其所有历史名字以便修改。</p>
</li>
<li>
<p>非对称寻址方式</p>
<p>send(P , message); 发送一个消息给进程</p>
<p>receive (id, message); 接收来自任何进程的消息， id变量可设置为进行通信的发送方进程 id 或名字。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信箱通信</p>
<ul>
<li>
<p>信箱结构</p>
<ul>
<li>信箱头，用以存放有关信箱的描述信息，如信箱标识符、信箱的拥有者、信箱口令、信箱的空格数等；</li>
<li>信箱体，由若干个可以存放消息（或消息头）的信箱格组成，信箱格的数目以及每格的大小是在创建信箱时确定的。</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://s1.ax1x.com/2020/06/08/tWo39S.png" alt="tWo39S.png" loading="lazy"></figure>
</li>
<li>
<p>信箱通信原语</p>
<ul>
<li>
<p>邮箱的创建和撤消</p>
</li>
<li>
<p>消息的发送和接收</p>
<p>进程之间要利用邮箱进行通信时，必须使用共享邮箱。</p>
<p>Send(mailbox, message); 个消息发送到指定邮箱</p>
<p>Receive(mailbox, message); 从指定邮箱中接收一个消息</p>
</li>
</ul>
</li>
<li>
<p>信箱的类型</p>
<ul>
<li>私用邮箱：进程自己创建，所有者可以读取消息，其他进程只能发送。进程结束时，邮箱也随之消失。</li>
<li>公用邮箱：OS 创建，经核准的进程可向其发送消息也可读取给自己的消息。在系统运行期间始终存在。</li>
<li>共享邮箱：进程创建，创建时指明为共享邮箱并指出共享进程的名字，所有者和共享者可以读取给自己的消息。进程结束时，邮箱也随之消失。</li>
</ul>
</li>
<li>
<p>发送进程和接收进程的四种关系</p>
<ul>
<li>一对一关系</li>
<li>多对一关系</li>
<li>一对多关系</li>
<li>多对多关系</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="7-线程threads的基本概念">7. 线程（Threads）的基本概念</h3>
<p>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<ol>
<li>
<p>线程的引入</p>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是<strong>程序执行的最小单元</strong>，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p>
<p>引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。</p>
</li>
<li>
<p>线程与进程的比较</p>
<ul>
<li>
<p>调度的基本单位</p>
<p>进程较重，在被调度时执行上下文开销较大。将线程作为调度和分派的基本单位，切换代价较低。</p>
<p>在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一进程中的线程时，必然会引起进程的切换。</p>
</li>
<li>
<p>并发性</p>
<p>进程间，一个进程中的多个/全部线程，不同进程中的线程。</p>
</li>
<li>
<p>拥有资源</p>
<p>线程仅拥有必不可少的保证独立运行的资源，共享该进程的所有资源。</p>
</li>
<li>
<p>独立性</p>
<p>线程间的独立性远远低于进程间的独立性。</p>
</li>
<li>
<p>系统开销</p>
<p>创建和撤销进程的开销远大于线程的开销。</p>
</li>
<li>
<p>支持多处理机系统</p>
<p>单线程进程，该进程只能运行在一个处理机上；多线程进程，可将进程中的多个线程分配到多个处理机上，并行执行。</p>
</li>
</ul>
</li>
<li>
<p>线程的状态和线程控制块</p>
<ol>
<li>
<p>三个状态</p>
<ul>
<li>执行状态，表示线程已获得处理机而正在运行；</li>
<li>就绪状态，指线程已具备了各种执行条件，只须再获得 CPU 便可立即执行；</li>
<li>阻塞状态，指线程在执行中因某事件受阻而处于暂停状态</li>
</ul>
<p>线程间的状态转换与进程间的状态转换相同。</p>
</li>
<li>
<p>线程控制块 TCB</p>
<p>① 线程标识符，为每个线程赋予一个唯一的线程标识符。</p>
<p>② 一组寄存器，程序寄存器等。</p>
<p>③ 线程运行状态，线程此时运行状态。</p>
<p>④ 优先级，描述线程执行的优先程度。</p>
<p>⑤ 线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。</p>
<p>⑥ 信号屏蔽，对某些信号加以屏蔽。</p>
<p>⑦ 堆栈指针，保存局部变量和返回地址。</p>
</li>
<li>
<p>多线程 OS 中的进程属性</p>
<p>① 进程是一个可拥有资源的基本单位。</p>
<p>② 多个线程可并发执行。</p>
<p>③ 进程已不是可执行的实体 。</p>
</li>
</ol>
</li>
</ol>
<h3 id="8-线程的实现">8. 线程的实现</h3>
<p>实现方式</p>
<ol>
<li><strong>以线程为基本调度单位的内核支持线程[与内核紧密相关]</strong></li>
<li><strong>以进程为基本调度单位的用户级线程[与内核无关]</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统学习笔记（一）--  引论]]></title>
        <id>https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/</id>
        <link href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">
        </link>
        <updated>2020-06-08T02:00:09.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
​		操作系统(OS)，是配置在计算机硬件的笫 一层软件，其主要作用是管理这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口便于用户使用。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">操作系统学习笔记（二）--  引论</a><br>
<a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">操作系统学习笔记（三）--  处理机调度与死锁</a><br>
​		操作系统(OS)，是配置在计算机硬件的笫 一层软件，其主要作用是管理这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口便于用户使用。</p>
<!-- more -->
<h3 id="1-操作系统的目标和作用">1. 操作系统的目标和作用</h3>
<ol>
<li>
<p>目标</p>
<ul>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>
<p>OS 作为用户与计算机硬件系统之间的接口</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/08/tRbpSU.png" alt="tRbpSU.png" loading="lazy"></figure>
</li>
<li>
<p>OS 作为计算机系统资源的管理者</p>
</li>
<li>
<p>OS 实现了对计算机资源的抽象</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-操作系统的发展过程">2. 操作系统的发展过程</h3>
<ol>
<li>
<p>未配置操作系统的计算机系统</p>
<ul>
<li>
<p>人工操作方式：手工操作、速度慢、CPU浪费严重。</p>
</li>
<li>
<p>脱机输入/输出方式((Off-Line I/O)：该技术是事先将有用户程序和数据的纸袋装入纸袋输入机，在一台外围机的控制下，把纸带上的数据（程序）输入到磁带上。减少了 CPU 的空闲时间；提高了 I/O 速度。</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/08/tRqP9f.png" alt="tRqP9f.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>单道批处理系统：为实现对作业的连续处理，先把一批作业输入到磁带上，一个接一个的连续处理。注意<strong>在内存中始终只有一道作业</strong>。</p>
<ul>
<li>
<p>特征： 自动性、顺序性、单道性。</p>
</li>
<li>
<p>缺点：系统中的资源得不到充分的利用。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/08/tRqcVA.png" alt="tRqcVA.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>多道批处理系统：用户提交的作业先放在外存上，排成“<strong>后备队列</strong>”。由作业调度程序选择作业进入内存。</p>
<ul>
<li>
<p>特征：多道性、无序性、调度性。</p>
</li>
<li>
<p>优缺点：提高CPU利用率、提高内存和IO利用率、增加系统吞吐量；平均周转时间长、无交互能力。</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/08/tRqq5q.png" alt="tRqq5q.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>分时系统：在一台主机上链接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
<ul>
<li>关键问题：及时接受、及时处理(时间片轮转)。</li>
<li>特征：多路性、独占性、及时性、交互性。</li>
</ul>
</li>
<li>
<p>实时系统：系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<ul>
<li>分类：硬实时任务（对截止时间的要求十分严格）、软实时任务（对截止时间没那么严格）</li>
<li>特征：多路性、独占性、及时性、交互性、可靠性。</li>
</ul>
</li>
<li>
<p>微机操作系统：主要动力来源有不断提高计算机资源的利用率、方便用户、器件的不断更新换代、计算机体系结构的不断发展。每一代计算机几乎都是为了改进上一代计算机的缺点进而产生的，也促进了操作系统的不断发展。<br>
分类可以根据发展历程进行分类。</p>
<ul>
<li>单用户单任务：MS-DOS</li>
<li>单用户多任务：windows95</li>
<li>多用户多任务：UNIX OS</li>
</ul>
</li>
</ol>
<h3 id="3-操作系统的基本特性">3.  操作系统的基本特性</h3>
<ol>
<li><strong>并发性</strong>
<ul>
<li>并行性是指多个时间在同一时刻发生。</li>
<li>并发性是指多个事件在同一时间间隔内发生。<br>
并发性是指一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每个时刻只有一个程序在执行，微观上也是分时交替执行。若有多个处理机，则可以实现并行执行。</li>
<li>并发性是四大特征中，最基础的。</li>
</ul>
</li>
<li>共享性
<ul>
<li>共享是指系统中的资源可供内存中多个并发执行的进程共同使用。</li>
<li>互斥共享：指一段时间内只允许一个进程访问某种资源，也成为临界资源或独占资源。如打印机、磁带机。</li>
<li>同步共享：宏观上允许一段时间内多个进程同时对某资源进行访问。</li>
</ul>
</li>
<li>虚拟性<br>
虚拟是指利用某种技术，把一个物理实体变为若干个逻辑上的对应物。前者物理实体是实际存在的，而后者是用户感觉上的东西。如虚拟内存、虚拟处理机大等。
<ul>
<li>时分复用技术</li>
<li>空分复用技术</li>
</ul>
</li>
<li>异步性<br>
进程是以人们不可预知的速度向前推进的。</li>
</ol>
<h3 id="4-操作系统的主要功能">4. 操作系统的主要功能</h3>
<ol>
<li>
<p>处理机管理功能</p>
<ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度（作业调度、进程调度）</li>
</ul>
</li>
<li>
<p>存储器管理功能</p>
<ul>
<li>内存分配（静态分配方式，动态分配方式）</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充（请求调入、置换）</li>
</ul>
</li>
<li>
<p>设备管理功能</p>
<p>设备管理的主要任务如下： (1) 完成用户进程提出的 I/O 请求，为用户进程分配所需的 I/O 设备，并完成指定的 I/O 操作</p>
<p>(2) 提高 CPU I/O 设备的利用率 提高 I/O 速度，方便用户使用 I/O 设备</p>
<ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
</li>
<li>
<p>文件管理功能</p>
<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读 写管理和保护</li>
</ul>
</li>
<li>
<p>操作系统与用户之间的接口</p>
<ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
</ol>
<h3 id="5-os-结构设计">5. OS 结构设计</h3>
<ol>
<li>
<p>传统操作系统结构</p>
<ul>
<li>无结构操作系统</li>
<li>模块化结构 OS</li>
<li>分层式结构 OS</li>
</ul>
</li>
<li>
<p>现代操作系统的结构</p>
<ul>
<li>微内核结构：足够小的内核、基于客户-服务器模式、应用机制与策略分离原理、采用面向对象技术</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（五）--  运输层]]></title>
        <id>https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/</id>
        <link href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/">
        </link>
        <updated>2020-06-07T01:34:01.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）--  计算机网络概述</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/">计算机网络学习笔记（三）--  数据链路层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/">计算机网络学习笔记（四）--  网络层</a></p>
<h3 id="1-运输层协议概述">1. 运输层协议概述</h3>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）--  计算机网络概述</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/">计算机网络学习笔记（三）--  数据链路层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/">计算机网络学习笔记（四）--  网络层</a></p>
<h3 id="1-运输层协议概述">1. 运输层协议概述</h3>
<!-- more -->
<ol>
<li>
<p>进程之间的通信</p>
<ul>
<li>向它上面的应用层提供通信服务。</li>
<li>面向通信部分的最高层。</li>
<li>用户功能中的最低层。</li>
</ul>
<p>通信的真正端点井不是主机而是主机中的进程。</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/07/tgtV54.png" alt="tgtV54.png" loading="lazy"></figure>
</li>
<li>
<p>运输层的两个主要协议</p>
<ul>
<li>
<p><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)</p>
</li>
<li>
<p><strong>传输控制协议 TCP</strong> (Transmission Control Protocol)</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/07/tgN9Fe.png" alt="tgN9Fe.png" loading="lazy"></figure>
</li>
<li>
<p>运输层的端口</p>
<ul>
<li>
<p>识别各应用层进程；</p>
</li>
<li>
<p>只具有本地意义；</p>
</li>
</ul>
<p><strong>端口范围：（0 - 65535）</strong></p>
<p><strong>①熟知端口号（0~1023）</strong></p>
<p><strong>②登记（或注册）端口号（1024~49151）</strong></p>
<p><strong>③客户（或动态、短暂）端口号（49152~65535）</strong></p>
</li>
<li>
<p>套接字socket</p>
<p><strong>套接字 socket = (IP 地址：端口号）</strong></p>
</li>
</ol>
<h3 id="2-用户数据报协议-udp">2. 用户数据报协议 UDP</h3>
<ul>
<li>
<p>特点</p>
<p>① 无连接；（减少开销和发送时延）</p>
<p>③ 尽最大努力交付；</p>
<p>④ 面向报文；（对报文不分拆，不合并）</p>
<p>⑤ 没有拥塞控制；</p>
<p>⑥ 支持一对一，一对多，多对一，多对多的交互通信；</p>
<p>⑦ 首部开销小。（8个字节）</p>
<p>⑧无编号；</p>
</li>
<li>
<p>UDP首部格式</p>
<p>有 8 个字节 ，由 4 个字段组成，每个字段的长度都是 2 个字节。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/07/tgNLtg.png" alt="tgNLtg.png" loading="lazy"></figure>
<p>(1) <strong>源端口</strong>：源端口号。在需要对方回信时选用。不需要时可用全 0。</p>
<p>(2) <strong>目的端口</strong>：目的端口号。这在终点交付报文时必须使用。</p>
<p>(3) <strong>长度</strong>：UDP用户数据报的长度，其最小值是 8 （仅有首部）。</p>
<p>(4) <strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/07/tgUE9J.png" alt="tgUE9J.png" loading="lazy"></figure>
<p>如果接收方 UDP 发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网 ICMP 发送“端口不可达”差错报文给发送方。</p>
<p>UDP 的通信是无连接的，虽然使用了端口号但不需要使用套接字。</p>
</li>
<li>
<p>UDP 计算检验和</p>
<p>把首部和数据部分一起都检验，IP数据报是只检验首部</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/07/tgUhUU.png" alt="tgUhUU.png" loading="lazy"></figure>
<p>16 位的字视为 1 字节。若数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。</p>
</li>
</ul>
<h3 id="3-传输控制协议-tcp-概述">3. 传输控制协议 TCP 概述</h3>
<ul>
<li>
<p>特点</p>
<p>① 面向连接的服务；</p>
<p>② 面向字节流；（无结构的字节流）</p>
<p>③ 全双工通信；（发送、接收缓存）</p>
<p>④ 复用和分用；（发送—复用，接收—分用）</p>
<p>⑤ 进程到进程的通信；（点对点，每个进程都需要一个连接）</p>
<p>⑥ 可靠的服务。（无差错，不丢失，不重复，按序到达）</p>
</li>
<li>
<p>TCP 连接</p>
<p>TCP 之间的通信必须要在两个套接字之间建立连接。</p>
<p><strong>TCP 连接：：＝ {socket, socket2} = { (IP1: port,), (IP2: port2) }</strong></p>
</li>
</ul>
<h3 id="4-可靠传输的工作原理">4. 可靠传输的工作原理</h3>
<ol>
<li>
<p>停止等待协议</p>
<ol>
<li>
<p>无差错情况和出现差错</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/07/tga0qx.png" alt="tga0qx.png" loading="lazy"></figure>
<p>A 向 B 发送，B 收到后向 A 发送确认报文，A 发送下一条报文。若超过一段时间 A 没有收到确认报文就重传该报文。</p>
<p>A 在发送完一个分组后，必须暂时保留已发送的分组的副本，收到确认后才能销毁。</p>
<p>分组和确认分组都必须进行编号。</p>
<p>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</p>
</li>
<li>
<p>确认丢失和确认迟到</p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/07/tgdZex.png" alt="tgdZex.png" loading="lazy"></figure>
</li>
<li>
<p>信道利用率</p>
<figure data-type="image" tabindex="8"><img src="https://s1.ax1x.com/2020/06/07/tgdMfe.png" alt="tgdMfe.png" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://s1.ax1x.com/2020/06/07/tgd1ld.png" alt="tgd1ld.png" loading="lazy"></figure>
<p>当使用流水线传输时，就要使用<strong>连续 ARQ 协议</strong>和<strong>滑动窗口协议</strong>。</p>
</li>
</ol>
</li>
<li>
<p>连续 ARQ 协议</p>
<p>发送窗口，累积确认（对按序到达的最后一个分组发送确认）。</p>
<figure data-type="image" tabindex="10"><img src="https://s1.ax1x.com/2020/06/07/tg0jOA.png" alt="tg0jOA.png" loading="lazy"></figure>
<p><strong>对按序到达的最后一个分组发送确认</strong>，这就表示：到这个分组为止的所有分组都已正确收到了。</p>
<p>优点：简单易实现；缺点：Go-back-N，即首尾收到，中间报文段丢失，则要重传丢失报文后的所有报文。</p>
</li>
</ol>
<h3 id="5-tcp-报文段的首部格式">5. TCP 报文段的首部格式</h3>
<img src="https://s1.ax1x.com/2020/06/07/tgBmT0.png" alt="tgBmT0.png" style="zoom:80%;" />
<p>​	最小长度是 20 字节，后面有 4n 字节是根据需要而增加的选项 (n 是整数)，最大长度 60 字节。</p>
<ul>
<li>
<p>源端口和目的端口：各占 2 个字节，分别写入源端口号和目的端口号。</p>
</li>
<li>
<p>序号：4 字节，使用 mod 2^32 运算。</p>
</li>
<li>
<p>确认号：4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。</p>
<blockquote>
<p>若确认号＝ N, 则表明：到序号 N-1 为止的所有数据都已正确收到。</p>
</blockquote>
</li>
<li>
<p>数据偏移：占 4 位，即首部长度。</p>
</li>
<li>
<p>保留：占 6 位，保留为今后使用，目前置为 0。</p>
</li>
<li>
<p>紧急 URG：URG = 1 时，表明紧急指针字段有效，相当于优先级高的数据，要尽快传送。</p>
</li>
<li>
<p>确认 ACK：仅当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。在TCP连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p>推送 PSH：PSH = 1 时，立即收到响应，不必等缓存满了之后再向上交付。</p>
</li>
<li>
<p>复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
</li>
<li>
<p>同步 SYN：在连接建立时用来同步序号，连接请求和连接接受。当 SYN = 1 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 ACK = 1 。</p>
</li>
<li>
<p>终止 FIN：用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p>
</li>
<li>
<p>窗口：2 字节，指的是发送本报文段的一方的<strong>接收窗口</strong>（而不是自己的发送窗口)，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
<blockquote>
<p>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。</p>
</blockquote>
</li>
<li>
<p>检验和：2 字节。检验和字段检验的范围包括首部和数据这两部分，与UDP检验方法相同。</p>
</li>
<li>
<p>紧急指针：2 字节。紧急指针仅在 URG = 1 时才有意义，它指向最后一字节的紧急数据。即使窗口为零时也可发送紧急数据。</p>
</li>
<li>
<p>选项：长度可变，最长可达 40 字节。</p>
<blockquote>
<ol>
<li>最大报文段长度 MSS 选项: TCP数据报数据部分长度。</li>
<li>时间戳选项：10 字节，其中最主要的字段是时间戳值字段 (4 字节）和时间戳回送回答字段 (4 字节): 用来计算往返时间 RTT，用于处理 TCP 序号超过 2^32 的情况。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="6-tcp-可靠传输的实现">6. TCP 可靠传输的实现</h3>
<ol>
<li>
<p>以字节为单位的滑动窗口</p>
<figure data-type="image" tabindex="11"><img src="https://s1.ax1x.com/2020/06/07/tgsukt.png" alt="tgsukt.png" loading="lazy"></figure>
<p>小于 P1 的是已发送并已收到确认的部分，而大于 P3 的是不允许发送的部分。</p>
<p>P3 - P1 = A 的发送窗口</p>
<p>P2 - P1 ＝已发送但尚未收到确认的字节数</p>
<p>P3 - P2 = 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）</p>
<p>B 未按序收到，A 从31号重传，B收到后把接收窗口向前移动 3 个序号。A 在继续发送完序号 42 ~ 53 的数据后，指针 P2 向前移动和 P3 重合。</p>
<figure data-type="image" tabindex="12"><img src="https://s1.ax1x.com/2020/06/07/tgsv38.png" alt="tgsv38.png" loading="lazy"></figure>
</li>
<li>
<p>超时重传时间的选择</p>
<p>每当第一次测量到 RTT 样本时，  RTTs 值就取为所测量到的 RTT 样本 值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次  RTTs</p>
<blockquote>
<p>新的 RTTs = (1 - α) x (旧的 RTTs) + α x (新的 RTT 样本)</p>
</blockquote>
<p>RTO (超时重传时间) = RTTs + 4 x RTTD (RTT 的偏差的加权平均值)</p>
<blockquote>
<p>新的 RTT0 = (1- β) x (旧的 RTTD)＋ β x | RTTs－新的 RTT 样本 |</p>
</blockquote>
</li>
<li>
<p>选择确认 SACK</p>
<p>首部选项加上允许 SACK 选项。</p>
<figure data-type="image" tabindex="13"><img src="https://s1.ax1x.com/2020/06/07/tg66F1.png" alt="tg66F1.png" loading="lazy"></figure>
</li>
</ol>
<h3 id="7-tcp-的流量控制">7. TCP 的流量控制</h3>
<p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<ol>
<li>
<p>利用滑动窗口实现流量控制</p>
<figure data-type="image" tabindex="14"><img src="https://s1.ax1x.com/2020/06/07/tg6bfP.png" alt="tg6bfP.png" loading="lazy"></figure>
<p>发送方的发送窗口不能超过接收方给出的接受窗口的数值；</p>
<p>设置持续计时器来防止窗口由零变为非零导致的僵局。</p>
</li>
<li>
<p>传输的效率（三种机制）</p>
<p>① 维持一个等于MSS的变量来控制缓存。</p>
<p>② 发送方的推送push操作。</p>
<p>③ 计时器期限到了就将缓存数据装入报文段。</p>
</li>
</ol>
<h3 id="8-tcp-的拥塞控制">8. TCP 的拥塞控制</h3>
<p>​	拥塞控制是全局的控制，以网络能够承受现有的网络负荷为前提；流量控制是端口的控制。</p>
<ol>
<li>
<p>TCP 的拥塞控制方法</p>
<ul>
<li>
<p>慢开始和拥塞避免</p>
<p><strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p>
<p><strong>判断网络拥塞的依据就是出现了超时。</strong></p>
<p>慢开始：以 MSS 作为发送窗口大小的初始值（拥塞窗口)，每经过一个传输轮次（从发送到确认)，cwnd就加倍；慢开始门限作为慢开始和拥塞避免的转换点；</p>
<p>拥塞避免：每一个RTT，cwnd只加 1, (线性增长，加法增大)；</p>
<p>出现拥塞时，慢开始门限设置为当前窗口值的一半(乘法减小)，cwnd设为1；</p>
<figure data-type="image" tabindex="15"><img src="https://s1.ax1x.com/2020/06/07/tg2pR0.png" alt="tg2pR0.png" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://s1.ax1x.com/2020/06/07/tg2nRx.png" alt="tg2nRx.png" loading="lazy"></figure>
</li>
<li>
<p>快重传和快恢复</p>
<p>快重传：收到三个重复确认立即发送未被确认的报文段；</p>
<p>快恢复：乘法减小后执行加法增大；</p>
<figure data-type="image" tabindex="17"><img src="https://s1.ax1x.com/2020/06/07/tgRxg0.png" alt="tgRxg0.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>TCP 拥塞控制流程图</p>
<figure data-type="image" tabindex="18"><img src="https://s1.ax1x.com/2020/06/07/tgWCbF.png" alt="tgWCbF.png" loading="lazy"></figure>
</li>
</ol>
<h3 id="9-tcp-的运输连接管理">9. TCP 的运输连接管理</h3>
<p><strong>运输连接有三个阶段，即：连接建立、数据传送和连接释放。</strong></p>
<p>TCP 连接的建立采用客户服务器方式。</p>
<ol>
<li>
<p>TCP 的连接建立</p>
<figure data-type="image" tabindex="19"><img src="https://s1.ax1x.com/2020/06/07/tgWwVg.png" alt="tgWwVg.png" loading="lazy"></figure>
<ul>
<li>
<p>第一次握手</p>
<p>客户端向服务端发送连接请求报文段。该报文段的头部中 SYN = 1，ACK = 0，seq = x。请求发送后，客户端便进入***SYN-SENT*** 状态。</p>
<ul>
<li>
<p>SYN = 1，ACK = 0 表示该报文段为连接请求报文。</p>
</li>
<li>
<p>x 为本次TCP通信的字节流的初始序号。TCP规定：SYN = 1 的报文段不能有数据部分，但要消耗掉一个序号。</p>
</li>
</ul>
</li>
<li>
<p>第二次握手</p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN = 1，ACK = 1，seq=y，ack=x+1。该应答发送完成后便进入***SYN-RCVD*** 状态。</p>
<ul>
<li>SYN = 1，ACK = 1 表示该报文段为连接同意的应答报文。</li>
<li>seq = y 表示服务端作为发送者时，发送字节流的初始序号。</li>
<li>ack = x + 1 表示服务端希望下一个数据报发送序号从x+1开始的字节。</li>
</ul>
</li>
<li>
<p>第三次握手</p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：<em><strong>ACK=1，seq=x+1，ack=y+1</strong></em>。</p>
<ul>
<li>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>为什么连接建立需要三次握手，而不是两次握手？</strong></p>
<p>背景：A首先发送一个连接请求，但是该请求在网络节点上滞留了，没有收到确认。于是A重传了一次请求，并且收到了B的确认，于是连接建立，数据传输完成后，释放连接。</p>
<p>① 假定A发出的第一个请求报文段并没有丢失，而是在某些网络节点上滞留，本来是一个失效的请求，但B收到后误认为是A再次发出一个新请求，于是向A发送确认，同意建立连接。</p>
<p>② 假定采用两次握手，那么只要B发出确认，则新的连接就建立了。由于A并没有发出请求，因此不理会B的确认，也不会向B发送数据，但B却以为新的连接已经建立，并一直等待A的数据，B的许多资源就这样白白浪费了。</p>
<p>③ 假定采用三次握手，则B发出确认，但A因为并没有发请求，所以不理会B的确认，B没有收到A的确认，则连接建立失败，B知道连接建立失败。会回收资源。</p>
<p>④ 极端的情况可能由于Client用户端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要。</p>
</blockquote>
<ol start="2">
<li>
<p>TCP 的连接释放</p>
<figure data-type="image" tabindex="20"><img src="https://s1.ax1x.com/2020/06/07/tg5isx.png" alt="tg5isx.png" loading="lazy"></figure>
<ul>
<li>
<p>第一次挥手<br>
若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN = 1，seq = u。此时，A将进入FIN-WAIT-1状态。</p>
<ul>
<li>FIN = 1 表示该报文段是一个连接释放请求。</li>
<li>seq = u，u - 1 是A向B发送的最后一个字节的序号。</li>
</ul>
</li>
<li>
<p>第二次挥手<br>
B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入 CLOSE-WAIT 状态，并向A发送连接释放的应答，其报文头包含：ACK = 1，seq = v，ack = u + 1。A收到该应答，进入 FIN-WAIT-2 状态，等待B发送连接释放请求。</p>
<ul>
<li>ACK = 1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的 ACK 都为1，表示应答。</li>
<li>seq = v，v - 1 是B向A发送的最后一个字节的序号。</li>
<li>ack = u + 1 表示希望收到从第 u+1 个字节开始的报文段，并且已经成功接收了前 u 个字节。</li>
</ul>
<p>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p>
</li>
<li>
<p>第三次挥手<br>
当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN = 1，ACK = 1，seq = w，ack = u+1。B便进入 LAST-ACK 状态。</p>
</li>
<li>
<p>第四次挥手<br>
A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT 状态。该状态会持续 2MSL 时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>为什么挥手是四次，而握手时三次？</strong></p>
<p>握手时 ACK 和 SYN 可以放在一个报文里发送，但是关闭连接时，当收到对方的 FIN 报文，你未必完成所有数据，所以可能发送 ACK 确认收到 FIN，然后发送 FIN 表示关闭连接。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络学习笔记（四）--  网络层]]></title>
        <id>https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/</id>
        <link href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/">
        </link>
        <updated>2020-06-05T10:20:48.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）--  计算机网络概述</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/">计算机网络学习笔记（三）--  数据链路层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/">计算机网络学习笔记（五）--  运输层</a></p>
<h3 id="1-网络层提供的两种服务">1. 网络层提供的两种服务</h3>
<ol>
<li><strong>虚电路服务</strong></li>
<li><strong>数据报服务</strong></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">计算机网络学习笔记（一）--  计算机网络概述</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">计算机网络学习笔记（二）--  物理层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/">计算机网络学习笔记（三）--  数据链路层</a><br>
<a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/">计算机网络学习笔记（五）--  运输层</a></p>
<h3 id="1-网络层提供的两种服务">1. 网络层提供的两种服务</h3>
<ol>
<li><strong>虚电路服务</strong></li>
<li><strong>数据报服务</strong></li>
</ol>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/05/trd2DO.png" alt="trd2DO.png" loading="lazy"></figure>
<h3 id="2-网际协议-ip">2. 网际协议 IP</h3>
<p>网际协议 IP 是 TCP/IP 体系中两个最重要的协议之一，也是最重要的因特网标准协议之一。与 IP 协议配套是用的四个协议：</p>
<ul>
<li><strong>地址解析协议 ARP</strong>：是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</li>
<li><strong>网际控制报文协议 ICMP</strong>：提供差错报告和询问报文，以提高 IP 数据交付成功的机会</li>
<li><strong>网际组管理协议 IGMP</strong>：用于探寻、转发本局域网内的组成员关系。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/05/trwlqO.png" alt="trwlqO.png" loading="lazy"></figure>
<p>​		ARP 画在最下面，因为 IP 经常要使用这个协议。 ICMP、IGMP 画在这一层的上部，因为它们要使用 IP 协议。</p>
<ol>
<li>
<p>虚拟互连网络</p>
<p>因为没有一种单一的网络能够适应所有的用户需求，所以网络互连也变得困难，所以需要一些中间设备：</p>
<ul>
<li>物理层中间设备：<strong>转发器</strong>(repeater)</li>
<li>数据链路层中间设备：<strong>网桥或桥接器</strong>(bridge)</li>
<li>网络层中间设备：<strong>路由器</strong>(router)</li>
<li>网络层以上的中间设备：<strong>网关</strong>(gateway)</li>
</ul>
</li>
<li>
<p>分类的 IP 地址</p>
<p><strong>IP 地址</strong>就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。由因特网名字与号码指派公司 ICANN 进行分配。</p>
<p>IP地址编制方法的三个阶段：</p>
<ol>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网</li>
</ol>
<blockquote>
<p><strong>IP 地址：：＝｛＜网络号＞，＜主机号＞｝</strong></p>
</blockquote>
<p>一个网络号在整个互联网范围内必须是唯一的，主机号在它前面的网络号所指明的网络范围内必须是唯一的。一个 IP 地址在整个互联网范围内是<strong>唯一的</strong>。</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/05/trDisP.png" alt="trDisP.png" loading="lazy"></figure>
<ul>
<li>A类
<ul>
<li>由1字节的网络地址和3字节主机地址组成。</li>
<li>网络地址的最高位必须是“0“，可指派的网络数为2^7 - 2，减2的原因是<strong>0.0.0.0对应“本网络”</strong>，另外一个是<strong>127.0.0.1是本地软件的回环地址</strong>，用于测试自己电脑IP地址是否可用。</li>
<li><strong>地址范围 1.0.0.0 到 126.255.255.255</strong>。</li>
<li>最大主机数为 2^24 - 2 = 16777214 台，减2的原因是<strong>全0的主机号字段代表该IP地址是&quot;本主机“</strong>，<strong>全1表示”所有的“</strong>，表示该网络上的所有主机。</li>
</ul>
</li>
<li>B类
<ul>
<li>由2字节的网络地址和2字节主机地址组成。</li>
<li>网络地址的最高位必须是“10”，可指派的网络数为 2^14 -1，因为最高位为10，所以不存在全0全1的情况，但是B类网络地址<strong>128.0.0.0是不指派的</strong>，可指派<strong>最小网络地址是128.1.0.0</strong>。</li>
<li><strong>地址范围 128.0.0.0 - 191.255.255.255。</strong></li>
<li>最大主机数为2^16 - 2 = 65534台，减2同样是全0全1情况。</li>
</ul>
</li>
<li>C类
<ul>
<li>由3字节的网络地址和1字节主机地址组成</li>
<li>网络地址的最高位必须是“110”，可指派的网络数为2^21 - 1，192.0.0.0不指派，<strong>最小可指派网络地址是192.0.1.0</strong></li>
<li><strong>地址范围192.0.0.0 - 223.255.255.255</strong></li>
<li>最大主机数为2^8 - 2 = 254台，减2同样是全0全1情况。</li>
</ul>
</li>
<li>D类是多播地址，“1110”开始</li>
<li>E类地址保留为今后使用，“11110”开头</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/05/trsECQ.png" alt="trsECQ.png" loading="lazy"></figure>
</li>
<li>
<p>IP 地址与硬件地址</p>
<p>物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/05/tryeiD.png" alt="tryeiD.png" loading="lazy"></figure>
<p>IP 地址放在 IP数据报 的首部，而硬件地址放在 MAC帧 的首部。当数据报放入数据链路层的 MAC帧 中后，整个 IP数据报 就成为 MAC帧 的数据，因而在数据链路层看不见数据报的 IP 地址。</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/05/tryfyR.png" alt="tryfyR.png" loading="lazy"></figure>
</li>
<li>
<p>地址解析协议 ARP</p>
<p>ARP是解决<strong>同一个局域网上</strong>的主机或路由器的 <strong>IP 地址和硬件地址的映射问题</strong>。</p>
<figure data-type="image" tabindex="7"><img src="https://s1.ax1x.com/2020/06/05/tr6STf.png" alt="tr6STf.png" loading="lazy"></figure>
<p>每个主机都有一个 <strong>ARP 高速缓存</strong>，存放映射表。如果一个 IP 地址 到 MAC 地址的映射不在该表中，主机通过广播的方式发送 ARP 请求分组，匹配 IP 地址的主机会发送 <strong>ARP 响应分组</strong>告知 MAC 地址。</p>
<figure data-type="image" tabindex="8"><img src="https://s1.ax1x.com/2020/06/05/tr68XR.png" alt="tr68XR.png" loading="lazy"></figure>
<p>A 收到 B 的 ARP响应分组后就在其 ARP 高速缓存中写入 B 主机 IP 地址到硬件地址的映射。同时 B 也会将 A的映射写入到自己的ARP 高速缓存。</p>
<p>ARP 对保存在高速缓存中的每一个映射地址项目都设置生存时间。凡超过生存时间的项目就从高速缓存中删除掉。</p>
</li>
<li>
<p>IP 数据报的格式</p>
<figure data-type="image" tabindex="9"><img src="https://s1.ax1x.com/2020/06/05/trgpRg.png" alt="trgpRg.png" loading="lazy"></figure>
<ul>
<li>
<p>版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。</p>
</li>
<li>
<p>首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是<strong>最长可为15*4=60字节</strong>，除去固定部分的长度20字节，可变部分的长度最大为40字节。</p>
</li>
<li>
<p>区分服务(服务类型)：占8位，未使用。</p>
</li>
<li>
<p>总长度：IP报文的总长度。报头的长度和数据部分的长度之和。占16位，因此数据报的最大长度为2^16-1=65535字节（实际极少遇到）。</p>
<p>在IP层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段最大长度，这称为最大传送单元MTU。当一个IP数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层规定的MTU值。如：最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行<strong>分片</strong>处理。</p>
<p>IP协议规定，在因特网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报。即：假定上层交下来的数据长度有512字节，加上最长的IP首部60字节，再加上4字节的富裕量。否则就要进行分片。</p>
</li>
<li>
<p>标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容<em>重新组成原先的数据</em>。</p>
</li>
<li>
<p>标志：共3位。R、DF、MF三位。目前只有后两位有效，DF(don’t fragment)位：为1表示不分片，为0表示分片。MF(more fragment)：为1表示“更多的片”，为0表示这是最后一片。</p>
</li>
<li>
<p>片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）</p>
<p>IP数据报分片举例1：一数据报总长度3820字节，其数据部分3800字节长，需要分片为长度不超过1420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1400字节。于是分为3个数据报片，其数据部分的长度分别为1400，1400，1000字节。原始数据报首部被复制为各数据片的首部，但必须修改有关字段的值。分片结果如下：</p>
<figure data-type="image" tabindex="10"><img src="https://s1.ax1x.com/2020/06/05/tr2FpD.png" alt="tr2FpD.png" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://s1.ax1x.com/2020/06/05/tr2UA0.png" alt="tr2UA0.png" loading="lazy"></figure>
</li>
<li>
<p>生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。</p>
</li>
<li>
<p>协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.</p>
</li>
<li>
<p>首部校验和：<strong>只检验数据报的首部，但不包括数据部分。</strong></p>
<figure data-type="image" tabindex="12"><img src="https://s1.ax1x.com/2020/06/05/tr2O4f.png" alt="tr2O4f.png" loading="lazy"></figure>
</li>
<li>
<p>源IP地址：标识IP数据报的源端设备。32位</p>
</li>
<li>
<p>目的IP地址：标识IP数据报的目的地址。32位</p>
</li>
</ul>
</li>
<li>
<p>IP 层转发分组的流程</p>
<p>每一条路由最主要的两个信息：<strong>（目的网络地址，下一跳地址）</strong></p>
<figure data-type="image" tabindex="13"><img src="https://s1.ax1x.com/2020/06/05/trRUrd.png" alt="trRUrd.png" loading="lazy"></figure>
<ul>
<li>特定主机路由：可使网络管理人员更方便地控制网络和测试网络。</li>
<li>默认路由：在一个网络只有很少的对外连接时很有用，可以以减小路由表所占用的空间和搜索路由表所用的时间。</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://s1.ax1x.com/2020/06/05/trRXZR.png" alt="trRXZR.png" loading="lazy"></figure>
<p><strong>分组转发算法：</strong></p>
<p>(1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。<br>
(2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<br>
(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<br>
(4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<br>
(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)<br>
(6) 报告转发分组出错。</p>
</li>
</ol>
<h3 id="3-划分子网和构造超网">3. 划分子网和构造超网</h3>
<ol>
<li>
<p>两级IP地址缺陷</p>
<ul>
<li>IP 地址空间的利用率有时很低。</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级的 IP 地址不够灵活</li>
</ul>
</li>
<li>
<p>子网划分的基本思路</p>
<ul>
<li>
<p>划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</p>
</li>
<li>
<p>原来的两级 IP 地址在本单位内部就变为三级 IP 地址：<strong>网络号、 子网号和主机号</strong>。</p>
<blockquote>
<p>IP 地址：：＝｛＜网络号＞，＜子网号＞，＜主机号＞｝</p>
</blockquote>
</li>
<li>
<p>路由器在收到IP数据报后，按目标网络号和子网号定位目标子网。</p>
</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://s1.ax1x.com/2020/06/05/trW7kt.png" alt="trW7kt.png" loading="lazy"></figure>
</li>
<li>
<p>子网掩码</p>
<p>从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。</p>
<figure data-type="image" tabindex="16"><img src="https://s1.ax1x.com/2020/06/05/trfEX4.png" alt="trfEX4.png" loading="lazy"></figure>
<p>把 IP 地址的子网掩码和收到的数据报的目的 IP 地址<strong>逐位相与</strong> (AND) ，得出了所要找的子网的网络地址。</p>
<p>如果一个网络不划分子网， 那么该网络的子网掩码就使用默认子网掩码。</p>
<figure data-type="image" tabindex="17"><img src="https://s1.ax1x.com/2020/06/05/trfyuQ.png" alt="trfyuQ.png" loading="lazy"></figure>
<p>子网数是根据子网号(subnet-id) 计算出来的。若 subnet-id  <em>n</em> 位，则共有 <em>2^n 种</em>可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数*(2^ n - 2)*。</p>
<figure data-type="image" tabindex="18"><img src="https://s1.ax1x.com/2020/06/05/trhJ2T.png" alt="trhJ2T.png" loading="lazy"></figure>
<p>同样的 IP 地址和不同的子网掩码可以得出相同的网络地址。但是，不同的掩码的效果是不同的。</p>
</li>
<li>
<p>使用子网时分组的转发</p>
<p>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址、 子网掩码和下一跳地址。</strong></p>
<p>在划分子网的情况下，路由器转发分组的算法如下：</p>
<p>(1) 从收到的数据报的首部提取目的 IP 地址 D。</p>
<p>(2) 先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相”与 “(AND 操作），若匹配，则进行直接交付；否则就是间接交付，执行(3) 。</p>
<p>(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4) 。</p>
<p>(4) 对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相”与 “(AND 操作），其结果为 N 。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行(5) 。</p>
<p>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否 则，执行(6)</p>
<p>(6) 报告转发分组出错。</p>
</li>
<li>
<p>无分类编址 CIDR （构造超网）</p>
<ol>
<li>
<p>网络前缀</p>
<p>CIDR 的记法是无分类的两级编址。</p>
<blockquote>
<p>IP 地址：：＝｛＜网络前缀＞，＜主机号＞｝</p>
</blockquote>
<p>前面部分是“网络前缀&quot;（简称 “前缀＂），用来指明网络，后面部分则用来指明主机。</p>
<p>“斜线记法 ”(slash notation) ，或称为 CIDR 记法，即在 IP 地址后面加上 斜线 &quot;/&quot;，然后写上网络前缀所占的位数。</p>
<figure data-type="image" tabindex="19"><img src="https://s1.ax1x.com/2020/06/05/trIvod.png" alt="trIvod.png" loading="lazy"></figure>
<p>CIDR 使用的地址掩码也可继续称为子网掩码。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数。</strong></p>
<p>网络前缀越短，其地址块所包含的地址数就越多。</p>
<p><strong>最长前缀匹配</strong>，即选择两个匹配的地址中更具体的一个。使用二叉线索查找路由表。</p>
</li>
</ol>
</li>
</ol>
<h3 id="4-网际控制报文协议-icmp">4. 网际控制报文协议 ICMP</h3>
<h5 id="为了更有效地转发ip数据报和提高交付成功的机会在网际层使用了icmpicmp允许主机或路由器报告差错情况和提供有关异常情况的报告">为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</h5>
<figure data-type="image" tabindex="20"><img src="https://s1.ax1x.com/2020/06/05/trqsJJ.png" alt="trqsJJ.png" loading="lazy"></figure>
<ol>
<li>
<p>ICMP报文的种类</p>
<ul>
<li>ICMP差错报告报文</li>
<li>ICMP询问报文</li>
</ul>
<figure data-type="image" tabindex="21"><img src="https://s1.ax1x.com/2020/06/05/trqIFe.png" alt="trqIFe.png" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://s1.ax1x.com/2020/06/05/trqvTS.png" alt="trqvTS.png" loading="lazy"></figure>
</li>
<li>
<p>ICMP 询问报文有两种：</p>
<ul>
<li>回送请求和回答报文：用来测试目的站是否可达以及了解其有关状态。由主机或路由器向一个特定的目的主机发出的询问。</li>
<li>时间戳请求和回答报文：用于时钟同步和时间测量。</li>
</ul>
</li>
</ol>
<h3 id="5-互联网的路由选择协议">5. 互联网的路由选择协议</h3>
<p>**静态路由选择策略（非自适应路由选择）**与  <strong>动态路由选择策略（自适应路由选择）</strong>。</p>
<ol>
<li>
<p>分层次的路由选择协议</p>
<p>把整个互联网划分为许多较小的自治系统，记做 <strong>AS</strong>。</p>
<p>分类：</p>
<ul>
<li><strong>内部网关协议 IGP</strong>：RIP 、OSPF 协议。</li>
<li><strong>外部网关协议 EGP</strong>：BGP协议。</li>
</ul>
<figure data-type="image" tabindex="23"><img src="https://s1.ax1x.com/2020/06/05/trXvTK.png" alt="trXvTK.png" loading="lazy"></figure>
</li>
<li>
<p>内部网关协议 RIP</p>
<p>​		RIP 是一种分布式的基于距离（也叫<strong>跳数</strong>）向量的路由选择协议。RIP 允许一条路径最多只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型 互联网。</p>
<ol>
<li>
<p>特点</p>
<ul>
<li>仅和相邻路由器交换信息。</li>
<li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。</li>
<li>按固定的时间间隔交换路由信息。</li>
</ul>
</li>
<li>
<p>距离向量算法</p>
<p>(1) 对相邻地址 X 发来的 RIP 报文，先将报文中的所有下一跳字段更改为 X，并把跳数都加一。</p>
<p>(2) 对修改后的每条路由信息做下面的操作：</p>
<p>​	①若原来的路由表中没有目的网络 N, 则把该项目添加到路由表中；否则执行②；</p>
<p>​	②若下一跳路由器地址是 X, 则把收到的项目替换原路由表中的项；否则执行③；</p>
<p>​	③若收到的项目中的距离小于路由表中的距离，则进行更新，否则什么也不做。</p>
<p>(3) 若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为 16。</p>
<p>(4) 返回。</p>
</li>
<li>
<p>RIP 协议的报文格式</p>
<figure data-type="image" tabindex="24"><img src="https://s1.ax1x.com/2020/06/05/ts9P1S.png" alt="ts9P1S.png" loading="lazy"></figure>
<p>一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4 + 20 X 25 = 504 字节。如超过，必须再用一个 RIP 报文来传送。</p>
<p>优点：</p>
<ul>
<li>实现简单，开销较小。</li>
</ul>
<p>缺点：</p>
<ul>
<li>好消息传得快，坏消息传的慢。</li>
</ul>
<figure data-type="image" tabindex="25"><img src="https://s1.ax1x.com/2020/06/05/ts9W38.png" alt="ts9W38.png" loading="lazy"></figure>
</li>
<li>
<p>内部网关协议 OSPF（开放最短路径优先）</p>
<p>OSPF最主要的特征就是使用分布式的链路状态协议。</p>
<ol>
<li>
<p>特点：</p>
<ul>
<li>使用<strong>洪泛法</strong>向本自治系统中所有路由器发送信息。</li>
<li>发送的信息是与本路由器相邻的所有路由器的链路状态。</li>
<li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li>
</ul>
</li>
<li>
<p>OSPF 协议报文格式</p>
<p>OSPF 不用 UDP 而是直接用 IP 数据报传送。</p>
<figure data-type="image" tabindex="26"><img src="https://s1.ax1x.com/2020/06/05/tsiljS.png" alt="tsiljS.png" loading="lazy"></figure>
<p>​	(1) 版本当前的版本号是 2。</p>
<p>​	(2) 类型可以是五种类型分组中的一种。</p>
<p>​	(3) 分组长度 包括 OSPF 首部在内的分组长度，以字节为单位。</p>
<p>​	(4) 路由器标识符 标志发送该分组的路由器的接口的 IP 地址。</p>
</li>
<li>
<p>OSPF 的五种分组类型</p>
<ol>
<li><strong>问候(Hello) 分组</strong>，用来发现和维待邻站的可达性。</li>
<li><strong>数据库描述(Database Description)分组</strong>，向邻站给出自己的链路状态数据库 中的所有链路状态项目的摘要信息。</li>
<li><strong>链路状态请求(Link State Request)分组</strong>，向对方请求发送某些链路状态项目的详细信息。</li>
<li><strong>链路状态更新(Link State Update)分组</strong>，用洪泛法对全网更新链路状态。</li>
<li><strong>链路状态确认(Link State Acknowledgment)分组</strong>，对链路更新分组的确认。</li>
</ol>
<p>每两个相邻路由器每隔 10 秒钟要交换一次问候分组。</p>
<figure data-type="image" tabindex="27"><img src="https://s1.ax1x.com/2020/06/05/tsF326.png" alt="tsF326.png" loading="lazy"></figure>
<figure data-type="image" tabindex="28"><img src="https://s1.ax1x.com/2020/06/05/tsFdIA.png" alt="tsFdIA.png" loading="lazy"></figure>
<p>OSPF 还规定每隔一段时间，要刷新一次数据库中的链路状态。</p>
</li>
</ol>
</li>
<li>
<p>外部网关协议 BGP</p>
<p>​		边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。 BGP 采用了路径向量路由选择协议，它与距离向量协议（如 RIP) 和链路状态协议（如 OSPF) 都有很大的区别。</p>
<figure data-type="image" tabindex="29"><img src="https://s1.ax1x.com/2020/06/05/tskUyT.png" alt="tskUyT.png" loading="lazy"></figure>
<p>​		BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。BGP 发言人与其他 AS BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP <strong>会话</strong>。</p>
<ol>
<li>
<p>BGP 的四种报文类型</p>
<p>(1) OPEN （打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。</p>
<ul>
<li>共有 6 个字段，即<em>版本</em> (1 字节，现在的值是 4) 、<em>本自治系统号</em> (2 字节， 使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配）、<em>保持时间</em> (2 字节，以 秒计算的保持为邻站关系的时间）、 <em>BGP 标识符</em> (4 字节，通常就是该路由器的 IP 地址）、 <em>可选参数长度</em> (1 字节）和<em>可选参数</em>。</li>
</ul>
<p>(2) UPDATE （更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。</p>
<ul>
<li>共有 5 个字段，即<em>不可行路由长度</em> (2 字节，指明下一个字段的长度）、 <em>撤销的路由</em>（列出所有要撤销的路由）、<em>路径属性总长度</em> (2 字节，指明下一个字段的长 度）、<em>路径属性</em>（定义在这个报文中增加的路径的属性）和<em>网络层可达性信息 NLRI</em> (Network Layer Reachability Information) 。最后这个字段定义发出此报文的网络，包括网络前缀的位数、 IP 地址前缀。</li>
</ul>
<p>(3) KEEPALIVE （保活）报文，用来周期性地证实邻站的连通性。</p>
<ul>
<li>只有 BGP 19 字节长的通用首部。</li>
</ul>
<p>(4) NOTIFICATION （通知）报文，用来发送检测到的差错。</p>
<ul>
<li>有 3 个字段，即<em>差错代码</em> (1 字节）、<em>差错子代码</em> (1 字节）和<em>差错数据</em>（给出有关差错的诊断信息）。</li>
</ul>
<figure data-type="image" tabindex="30"><img src="https://s1.ax1x.com/2020/06/05/tsAIDU.png" alt="tsAIDU.png" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>路由器的构成</p>
<h5 id="路由器是一种具有多个输入端口和多个输出端口的专用计算机其任务是转发分组">路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。</h5>
<ol>
<li>
<p>路由器的结构</p>
<p>由**路由选择部分（控制部分）**和  <strong>分组转发部分</strong>组成。</p>
</li>
</ol>
<figure data-type="image" tabindex="31"><img src="https://s1.ax1x.com/2020/06/06/tyG1Og.png" alt="tyG1Og.png" loading="lazy"></figure>
<ol start="2">
<li>
<p>分组转发部分</p>
<ul>
<li>
<p>输入端口</p>
<p>为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中，路由选择处理机负责对各转发表的副本(影子副本)进行更新。</p>
<figure data-type="image" tabindex="32"><img src="https://s1.ax1x.com/2020/06/06/tyJKE9.png" alt="tyJKE9.png" loading="lazy"></figure>
</li>
<li>
<p>输出端口</p>
<figure data-type="image" tabindex="33"><img src="https://s1.ax1x.com/2020/06/06/tyJ336.png" alt="tyJ336.png" loading="lazy"></figure>
</li>
<li>
<p>交换结构</p>
<p><strong>交换结构把分组从一个输入端口转移到某个合适的输出端口。</strong></p>
<img src="https://s1.ax1x.com/2020/06/06/tyJw4I.png" alt="tyJw4I.png" style="zoom: 67%;" />
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="6-ipv6">6. IPv6</h3>
<p>IPv6 数据报由两大部分组成，即<strong>基本首部</strong>和<strong>有效载荷(净负荷)</strong>。有效载荷允许有零个或多个<strong>扩展首部</strong>，但扩展首部不属于首部。</p>
<ol>
<li>
<p>IPv6的基本首部</p>
<figure data-type="image" tabindex="34"><img src="https://s1.ax1x.com/2020/06/06/tyJOa9.png" alt="tyJOa9.png" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://s1.ax1x.com/2020/06/06/tyJx8x.png" alt="tyJx8x.png" loading="lazy"></figure>
<ul>
<li>
<p><strong>版本</strong>：占4位，IPv6 该字段是6.</p>
</li>
<li>
<p><strong>通信量类</strong>：8位，区分不同的 IPv6 数据报的类别或优先级。</p>
</li>
<li>
<p><strong>流标号</strong>：20位，对实时数据有用，对非实时数据无用。</p>
</li>
<li>
<p><strong>有效载荷长度</strong>：16位，表示除基本首部（包括扩展首部）以外的字节数，最大值是 64 KB。</p>
</li>
<li>
<p><strong>下一个首部</strong>：8位，相当千 IPv4 的协议字段或可选字段。</p>
<ul>
<li>无扩展首部时，作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（6代表TCP，17代表UDP）。</li>
<li>有扩展首部时，值标识后面第一个扩展首部的类型。</li>
</ul>
</li>
<li>
<p><strong>跳数限制</strong>：8位，防止数据报在网络中无限期地存在。路由器在转发数据报时，要先把跳数限制字段中的值减1。为零时，就要把这个数据报丢弃。</p>
</li>
<li>
<p><strong>源地址</strong>：128 位。发送端的 IP 地址。</p>
</li>
<li>
<p><strong>目的地址</strong>：128 位。接收端的 IP 地址。</p>
</li>
</ul>
</li>
<li>
<p>IPv6 的地址</p>
<ul>
<li>
<p>三种目的地址类型：<strong>单播</strong>，<strong>多播</strong>，<strong>任播</strong>。</p>
</li>
<li>
<p>每个IPv6地址<strong>128位</strong>，采用<strong>冒号十六进制记法</strong>。把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。允许把数字前面的 0 省略，</p>
<blockquote>
<p>68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF  把 0000 中的前三个 0 省略了</p>
</blockquote>
<p>一连串连续的零可以为一对冒号所取代(零压缩法)，但在一个地址中只能使用一次。</p>
<blockquote>
<p>FF05:0:0:0:0:0:0:B3  可记为  FF05: :B3</p>
</blockquote>
<p>CIDR 的斜线表示法仍然可用。60 位的前缀 12AB00000000CD3(16进制表示，每个字符代表 4 位二进制数字)</p>
<blockquote>
<p>可记为12AB:0000:0000:CD30:0000:0000:0000:0000/60</p>
<p>​	或12AB::CD30:0:0:0:0/60</p>
<p>​	或12AB:0:0:CD30::/60</p>
<p>不可记为12AB:0:0:CD3/60  (最后的0不能省略)</p>
<p>​	或12AB::CD30/60 （这是地址 12AB:0:0:0:0:0:0:CD30 的前 60 位二进制）</p>
<p>​	或12AB: :CD3/60 （这是地址 12AB:0:0:0:0:0:0:0CD3 的前 60 位二进制）</p>
</blockquote>
<figure data-type="image" tabindex="36"><img src="https://s1.ax1x.com/2020/06/06/tyanYj.png" alt="tyanYj.png" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://s1.ax1x.com/2020/06/06/tyal60.png" alt="tyal60.png" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>IPv4 IPv6 过渡</p>
<ul>
<li>
<p>双协议栈</p>
<img src="https://s1.ax1x.com/2020/06/06/tyas0O.png" alt="tyas0O.png" style="zoom:67%;" />
</li>
<li>
<p>隧道技术</p>
<img src="https://s1.ax1x.com/2020/06/06/tyagtH.png" alt="tyagtH.png" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p>ICMPv6</p>
<p>地址解析协议 ARP 和网际组管理协议 IGMP 的功能都被合并到 ICMPv6。</p>
<figure data-type="image" tabindex="38"><img src="https://s1.ax1x.com/2020/06/06/tyaoB8.png" alt="tyaoB8.png" loading="lazy"></figure>
<img src="https://s1.ax1x.com/2020/06/06/tyazuV.png" alt="tyazuV.png" style="zoom:80%;" />
</li>
</ol>
<h3 id="7-ip多播">7. IP多播</h3>
<ol>
<li>
<p>概念</p>
<img src="https://s1.ax1x.com/2020/06/06/tydaVS.png" alt="tydaVS.png" style="zoom: 67%;" />
<p>多播数据报和一般的 IP 数据报的区别就是它使用 <strong>D类</strong> IP 地址作为目的地址，<strong>地址范围是 224.0.0.0 到 239.255.255.255</strong>，并且首部中的协议字段值是 2, 表明使用网际组管理协议 IGMP。<strong>多播地址只能用于目的地址，而不能用于源地址</strong>。多播数据报不产生 ICMP 差错报文。</p>
<img src="https://s1.ax1x.com/2020/06/06/tywKs0.png" alt="tywKs0.png" style="zoom:80%;" />
</li>
<li>
<p>IP 多播需要两种协议</p>
<p><strong>网际组管理协议 IGMP</strong> 和 <strong>多播路由选择协议</strong>。</p>
<ul>
<li>
<p>IGMP</p>
<p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组。</p>
</li>
<li>
<p>多播路由选择协议</p>
<p>把多播数据报用最小代价传送给所有的组成员。</p>
<p>三种方法：</p>
<ol>
<li>洪泛与剪除。</li>
<li>隧道技术。</li>
<li>基于核心的发现技术。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="8-虚拟专用网-vpn-和网络地址转换-nat">8. 虚拟专用网 VPN 和网络地址转换 NAT</h3>
<ol>
<li>
<p>虚拟专用网 VPN</p>
<p>仅在本机构有效的 IP 地址称为本地地址，全球唯一的 IP 地址称为全球地址。<strong>专用地址</strong>(<strong>可重用地址</strong>)只能用做本地地址不能用作全球地址。<strong>在互联网中的所有路由器，对目的地址是专用地址的数据报一 律不进行转发。</strong></p>
<img src="https://s1.ax1x.com/2020/06/06/tyBOaT.png" alt="tyBOaT.png" style="zoom:80%;" />
<p>A、B内部的通信量都不经过互联网，X 和 Y 通信时，X将报文交付给R1，经R1加密后，重新加上数据报首部，此时源地址变为R1，目的地址变为R2。R2收到后进行解密，发现目的地址是Y，将报文交付给Y。</p>
</li>
<li>
<p>网络地址转换 NAT</p>
<p>解决的问题就是专用网内部的一些主机本来已经分配到了本地 IP 地址 （即仅在本专用网内使用的专用地址），但现在又想和互联网上的主机通信。</p>
<p>方法：安装NET路由器，它至少有一个有效的外部全球 IP 地址，NAT 路由器上将其本地地址转换成全球 IP 地址就能实现本地地址和全球地址通信了。</p>
<figure data-type="image" tabindex="39"><img src="https://s1.ax1x.com/2020/06/06/tyrUhD.png" alt="tyrUhD.png" loading="lazy"></figure>
<p>通过 NAT 地址转换表将旧的目的 IP 地址, 转换为新的目的 IP 地址。</p>
<figure data-type="image" tabindex="40"><img src="https://s1.ax1x.com/2020/06/06/tyssxJ.png" alt="tyssxJ.png" loading="lazy"></figure>
</li>
</ol>
]]></content>
    </entry>
</feed>