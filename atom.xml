<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qzlu-cyber.github.io/Keasar_Blog</id>
    <title>Keasar`Blog</title>
    <updated>2020-06-02T13:43:18.252Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qzlu-cyber.github.io/Keasar_Blog"/>
    <link rel="self" href="https://qzlu-cyber.github.io/Keasar_Blog/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://qzlu-cyber.github.io/Keasar_Blog/images/avatar.png</logo>
    <icon>https://qzlu-cyber.github.io/Keasar_Blog/favicon.ico</icon>
    <rights>All rights reserved 2020, Keasar`Blog</rights>
    <entry>
        <title type="html"><![CDATA[函数（上）]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/han-shu-shang/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/han-shu-shang/">
        </link>
        <updated>2020-06-02T13:31:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="函数的概念">函数的概念</h2>
<ul>
<li>
<p>对于 js 来说，函数就是把任意一段代码放在一个 <strong>盒子</strong> 里面</p>
</li>
<li>
<p>在我想要让这段代码执行的时候，直接执行这个 <strong>盒子</strong> 里面的代码就行</p>
</li>
<li>
<p>先看一段代码</p>
<pre><code class="language-javascript">// 这个是我们以前写的一段代码
for (var i = 0; i &lt; 10; i++) {
  console.log(i)
}

// 函数，这个 {} 就是那个 “盒子”
function fn() {
  // 这个函数我们以前写的代码
  for (var i = 0; i &lt; 10; i++) {
    console.log(i)
  }
}
</code></pre>
</li>
</ul>
<h2 id="函数的两个阶段重点">函数的两个阶段（重点）</h2>
<ul>
<li>按照我们刚才的说法，两个阶段就是 <strong>放在盒子里面</strong> 和 <strong>让盒子里面的代码执行</strong></li>
</ul>
<h3 id="函数定义阶段">函数定义阶段</h3>
<ul>
<li>
<p>定义阶段就是我们把代码 <strong>放在盒子里面</strong></p>
</li>
<li>
<p>我们就要学习怎么 <strong>放进去</strong>，也就是书写一个函数</p>
</li>
<li>
<p>我们有两种定义方式 <strong>声明式</strong> 和 <strong>赋值式</strong></p>
</li>
</ul>
<h4 id="声明式">声明式</h4>
<ul>
<li>
<p>使用 <code>function</code> 这个关键字来声明一个函数</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-javascript">function fn() {
  // 一段代码
}
// function: 声明函数的关键字，表示接下来是一个函数了
// fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）
// (): 必须写，是用来放参数的位置（一会我们再聊）
// {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”）
</code></pre>
</li>
</ul>
<h4 id="赋值式">赋值式</h4>
<ul>
<li>
<p>其实就是和我们使用 <code>var</code> 关键字是一个道理了</p>
</li>
<li>
<p>首先使用 <code>var</code> 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-javascript">var fn = function () {
  // 一段代码
}
// 不需要在 function 后面书写函数的名字了，因为在前面已经有了
</code></pre>
</li>
</ul>
<h3 id="函数调用阶段">函数调用阶段</h3>
<ul>
<li>就是让 <strong>盒子里面</strong> 的代码执行一下</li>
<li>让函数执行</li>
<li>两种定义函数的方式不同，但是调用函数的方式都以一样的</li>
</ul>
<h4 id="调用一个函数">调用一个函数</h4>
<ul>
<li>
<p>函数调用就是直接写 <code>函数名()</code> 就可以了</p>
<pre><code class="language-javascript">// 声明式函数
function fn() {
  console.log('我是 fn 函数')
}

// 调用函数
fn()

// 赋值式函数
var fn2 = function () {
  console.log('我是 fn2 函数')
}

// 调用函数
fn()
</code></pre>
<ul>
<li>注意： <strong>定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行</strong></li>
</ul>
</li>
</ul>
<h4 id="调用上的区别">调用上的区别</h4>
<ul>
<li>
<p>虽然两种定义方式的调用都是一样的，但是还是有一些区别的</p>
</li>
<li>
<p>声明式函数： 调用可以在 <strong>定义之前或者定义之后</strong></p>
<pre><code class="language-javascript">// 可以调用
fn()

// 声明式函数
function fn() {
  console.log('我是 fn 函数')
}

// 可以调用
fn()
</code></pre>
</li>
<li>
<p>赋值式函数： 调用只能在 <strong>定义之前</strong></p>
<pre><code class="language-javascript">// 会报错
fn()

// 赋值式函数
var fn = function () {
  console.log('我是 fn 函数')
}

// 可以调用
fn()
</code></pre>
</li>
</ul>
<h2 id="函数的参数重点">函数的参数（重点）</h2>
<ul>
<li>
<p>我们在定义函数和调用函数的时候都出现过 <code>()</code></p>
</li>
<li>
<p>现在我们就来说一下这个 <code>()</code> 的作用</p>
</li>
<li>
<p>就是用来放参数的位置</p>
</li>
<li>
<p>参数分为两种 <strong>行参</strong> 和 <strong>实参</strong></p>
<pre><code class="language-javascript">// 声明式
function fn(行参写在这里) {
  // 一段代码
}

fn(实参写在这里)

// 赋值式函数
var fn = function (行参写在这里) {
  // 一段代码
}
fn(实参写在这里)
</code></pre>
</li>
</ul>
<h3 id="行参和实参的作用">行参和实参的作用</h3>
<ol>
<li>
<p>行参</p>
<ul>
<li>
<p>就是在函数内部可以使用的变量，在函数外部不能使用</p>
</li>
<li>
<p>每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范）</p>
</li>
<li>
<p>多个单词之间以 <code>,</code> 分隔</p>
<pre><code class="language-javascript">// 书写一个参数
function fn(num) {
  // 在函数内部就可以使用 num 这个变量
}

var fn1 = function (num) {
	// 在函数内部就可以使用 num 这个变量
}

// 书写两个参数
function fun(num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}

var fun1 = function (num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}
</code></pre>
</li>
<li>
<p>如果只有行参的话，那么在函数内部使用的值个变量是没有值的，也就是 <code>undefined</code></p>
</li>
<li>
<p><strong>行参的值是在函数调用的时候由实参决定的</strong></p>
</li>
</ul>
</li>
<li>
<p>实参</p>
<ul>
<li>
<p>在函数调用的时候给行参赋值的</p>
</li>
<li>
<p>也就是说，在调用的时候是给一个实际的内容的</p>
<pre><code class="language-javascript">function fn(num) {
  // 函数内部可以使用 num 
}

// 这个函数的本次调用，书写的实参是 100
// 那么本次调用的时候函数内部的 num 就是 100
fn(100) 

// 这个函数的本次调用，书写的实参是 200
// 那么本次调用的时候函数内部的 num 就是 200
fn(200)
</code></pre>
</li>
<li>
<p><strong>函数内部的行参的值，由函数调用的时候传递的实参决定</strong></p>
</li>
<li>
<p><strong>多个参数的时候，是按照顺序一一对应的</strong></p>
<pre><code class="language-javascript">function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 函数本次调用的时候，书写的参数是 100 和 200
// 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200
fn(100, 200)
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="参数个数的关系">参数个数的关系</h3>
<ol>
<li>
<p>行参比实参少</p>
<ul>
<li>
<p>因为是按照顺序一一对应的</p>
</li>
<li>
<p>行参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值</p>
<pre><code class="language-javascript">function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 本次调用的时候，传递了两个实参，100 200 和 300
// 100 对应了 num1，200 对应了 num2，300 没有对应的变量
// 所以在函数内部就没有办法依靠变量来使用 300 这个值
fn(100, 200, 300)
</code></pre>
</li>
</ul>
</li>
<li>
<p>行参比实参多</p>
<ul>
<li>
<p>因为是按照顺序一一对应的</p>
</li>
<li>
<p>所以多出来的行参就是没有值的，就是 <code>undefined</code></p>
<pre><code class="language-javascript">function fn(num1, num2, num3) {
  // 函数内部可以使用 num1 num2 和 num3
}

// 本次调用的时候，传递了两个实参，100 和 200
// 就分别对应了 num1 和 num2
// 而 num3 没有实参和其对应，那么 num3 的值就是 undefined
fn(100, 200)
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="函数的return重点">函数的return（重点）</h2>
<ul>
<li>return 返回的意思，其实就是给函数一个 <strong>返回值</strong> 和 <strong>终断函数</strong></li>
</ul>
<h3 id="终断函数">终断函数</h3>
<ul>
<li>
<p>当我开始执行函数以后，函数内部的代码就会从上到下的依次执行</p>
</li>
<li>
<p>必须要等到函数内的代码执行完毕</p>
</li>
<li>
<p>而 <code>return</code> 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行</p>
<pre><code class="language-javascript">function fn() {
  console.log(1)
  console.log(2)
  console.log(3)
  
  // 写了 return 以后，后面的 4 和 5 就不会继续执行了
  return
  console.log(4)
  console.log(5)
}

// 函数调用
fn()
</code></pre>
</li>
</ul>
<h3 id="返回值">返回值</h3>
<ul>
<li>
<p>函数调用本身也是一个表达式，表达式就应该有一个值出现</p>
</li>
<li>
<p>现在的函数执行完毕之后，是不会有结果出现的</p>
<pre><code class="language-javascript">// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3
console.log(1 + 2) // 3

function fn() {
  // 执行代码
}

// fn() 也是一个表达式，这个表达式就没有结果出现
console.log(fn()) // undefined
</code></pre>
</li>
<li>
<p><code>return</code> 关键字就是可以给函数执行完毕一个结果</p>
<pre><code class="language-javascript">function fn() {
  // 执行代码
  return 100
}

// 此时，fn() 这个表达式执行完毕之后就有结果出现了
console.log(fn()) // 100
</code></pre>
<ul>
<li>我们可以在函数内部使用 <code>return</code> 关键把任何内容当作这个函数运行后的结果</li>
</ul>
</li>
</ul>
<h2 id="函数的优点">函数的优点</h2>
<ul>
<li>函数就是对一段代码的封装，在我们想调用的时候调用</li>
<li>函数的几个优点
<ol>
<li>封装代码，使代码更加简洁</li>
<li>复用，在重复功能的时候直接调用就好</li>
<li>代码执行时机，随时可以在我们想要执行的时候执行</li>
</ol>
</li>
</ul>
<h2 id="预解析重点">预解析（重点）</h2>
<ul>
<li><strong>预解析</strong> 其实就是聊聊 js 代码的编译和执行</li>
<li>js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码</li>
<li>也就是说，我们的 js 代码在运行的时候，会经历两个环节 <strong>解释代码</strong> 和 <strong>执行代码</strong></li>
</ul>
<h3 id="解释代码">解释代码</h3>
<ul>
<li>
<p>因为是在所有代码执行之前进行解释，所以叫做 <strong>预解析（预解释）</strong></p>
</li>
<li>
<p>需要解释的内容有两个</p>
<ul>
<li>声明式函数
<ul>
<li>在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数</li>
</ul>
</li>
<li><code>var</code> 关键字
<ul>
<li>在内存中先声明有一个变量名</li>
</ul>
</li>
</ul>
</li>
<li>
<p>看下面一段代码</p>
<pre><code class="language-javascript">fn()
console.log(num)

function fn() {
  console.log('我是 fn 函数')
}

var num = 100
</code></pre>
</li>
<li>
<p>经过预解析之后可以变形为</p>
<pre><code class="language-javascript">function fn() {
  console.log('我是 fn 函数')
}
var num

fn()
console.log(num)
num = 100
</code></pre>
</li>
<li>
<p>赋值是函数会按照 <code>var</code> 关键字的规则进行预解析</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://qzlu-cyber.github.io/Keasar_Blog/post/hello-gridea/</id>
        <link href="https://qzlu-cyber.github.io/Keasar_Blog/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>