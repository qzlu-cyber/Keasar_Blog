<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>Keasar`Blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1598075390223">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/shades of purple.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e43c360916ad26cabd1462bbf7f59f1e";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  <meta name="description" content="温故而知新">
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Keasar`Blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">👨🏻‍💻 好好学习，天天敲代码 👨🏻‍💻</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Keasar</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">14</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">6</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://keasar.com.cn/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/qzlu-cyber">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="/media/images/custom-array-imgSocials-1598074327832-socialImg.png" />
              <i class="fa fa-wechat" title="微信" ></i>
            </a>
          
        
      </div>
    </div>
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box box-shadow-wrapper">
          <section class="section archives-section bg-color posts-expand">
            

<div class="bg-color">
  <div class="archive-timeline-box">
    <div class="archive-timeline-title">
      
        <h2 class="language" data-lan="archives" data-count="14">非常好！目前共计14篇日志，继续努力！</h2>
      
    </div>
    
      
      
        <div class="node-title">
          <h2 class="tag-year">2020</h2>
        </div>    
        
      
      <a href="https://keasar.com.cn/post/javascript-wang-luo-qing-qiu-fetch/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              08-22
              <small>JavaScript 网络请求 Fetch</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/react-gao-ji-context/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              08-21
              <small>React 高级 -- Context</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/react-gao-ji-zhuang-tai-ti-sheng/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              07-13
              <small>React 高级 -- 状态提升</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/react-gao-ji-biao-dan/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              07-13
              <small>React 高级 -- 表单</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-09
              <small>操作系统（三）--  处理机调度与死锁</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-08
              <small>操作系统学习笔记（二）--  进程的描述与控制</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-08
              <small>操作系统学习笔记（一）--  引论</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-07
              <small>计算机网络学习笔记（五）--  运输层</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-05
              <small>计算机网络学习笔记（四）--  网络层</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-04
              <small>计算机网络学习笔记（三）--  数据链路层</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-04
              <small>计算机网络学习笔记（二）--  物理层</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-04
              <small>计算机网络学习笔记（一）--  计算机网络概述</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/centos76-an-zhuang-docker-bing-zai-docker-zhong-li-yong-tomcat-bu-shu-jing-tai-wang-ye/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-03
              <small>CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://keasar.com.cn/post/han-shu-shang/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              06-02
              <small>函数（上）</small>
            </h1>
          </div>  
      </div>
      </a>
    
  </div>
  
<div class="page bg-color">
  <ul class="pagination-ul">
    
    
      
        <li class="pagination-li pagination-active">
            <a href="/archives/page/../">
              1
            </a>
        </li>
      
    
    
  </ul>
</div>
</div>

          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <img src="https://s1.ax1x.com/2020/06/09/t51LE6.png" alt="t51LE6.png" border="0" style="width: 20px; height: 20px; vertical-align: middle;"/>
<span id="span"></span>
<script type="text/javascript">
    function runtime(){
        // 初始时间，月/日/年 时:分:秒
        X = new Date("06/01/2020 12:00:00");
        Y = new Date();
        T = (Y.getTime()-X.getTime());
        M = 24*60*60*1000;
        a = T/M;
        A = Math.floor(a);
        b = (a-A)*24;
        B = Math.floor(b);
        c = (b-B)*60;
        C = Math.floor((b-B)*60);
        D = Math.floor((c-C)*60);
        //信息写入到DIV中
        span.innerHTML = "本站已存活 "+A+" 天 "+B+" 小时 "+C+" 分 "+D+" 秒"
    }
    setInterval(runtime, 1000);
</script>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'tororo'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/javascript-wang-luo-qing-qiu-fetch/"" data-c="
          &lt;p&gt;JavaScript 可以将网络请求发送到服务器，并在需要时加载新信息。例如在表单提交、从服务器加载数据等都需要使用网络请求。对于来自 JavaScript 的网络请求，有一个总称术语 “AJAX”，有很多方式可以向服务端发送网络请求获取到数据。&lt;code&gt;fetch()&lt;/code&gt;是目前比较通用的方法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;基本语法&#34;&gt;基本语法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let promise = fetch(url, [options])
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;：要访问的 &lt;code&gt;url&lt;/code&gt;地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;：可选参数，&lt;code&gt;method&lt;/code&gt;、&lt;code&gt;header&lt;/code&gt;等，参数为空则发起 &lt;code&gt;GET&lt;/code&gt;请求&lt;/li&gt;
&lt;li&gt;返回值为一个 &lt;code&gt;Promise&lt;/code&gt; 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;请求阶段&#34;&gt;请求阶段&lt;/h4&gt;
&lt;p&gt;获取到响应通常要经历两个阶段。&lt;/p&gt;
&lt;p&gt;第一阶段：当服务器发送了响应头（response header），&lt;code&gt;fetch&lt;/code&gt; 返回的 &lt;code&gt;promise&lt;/code&gt; 就使用内建的 &lt;a href=&#34;https://fetch.spec.whatwg.org/#response-class&#34;&gt;Response&lt;/a&gt; class 对象来对响应头进行解析。此时，我们可以通过检查响应头来检查 HTTP 状态来确认网络请求是否成功，这是还没有响应体 &lt;code&gt;response body&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若&lt;code&gt;fetch&lt;/code&gt; 无法建立一个 HTTP 请求，如网络问题，或是请求的网址不存在，那么 &lt;code&gt;promise&lt;/code&gt; 就会 &lt;code&gt;reject&lt;/code&gt;。异常的 HTTP 状态，例如 404 或 500，不会导致出现 &lt;code&gt;error&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;response.status&lt;/code&gt; -- HTTP 状态码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;response.ok&lt;/code&gt; -- Boolean，若为 200 - 299 为 &lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二阶段：获取到 &lt;code&gt;response body&lt;/code&gt;，&lt;code&gt;Response&lt;/code&gt; 提供了多种基于 &lt;code&gt;promise&lt;/code&gt; 的方法，来以不同的格式访问 &lt;code&gt;body&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;response.text()&lt;/code&gt;&lt;/strong&gt; —— 读取 response，并以文本形式返回 response&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;response.json()&lt;/code&gt;&lt;/strong&gt; —— 将 response 解析为 JSON&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;response.formData()&lt;/code&gt;&lt;/strong&gt; —— 以 &lt;code&gt;FormData&lt;/code&gt; 对象的形式返回 response&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;response.blob()&lt;/code&gt;&lt;/strong&gt; —— 以 &lt;a href=&#34;https://zh.javascript.info/blob&#34;&gt;Blob&lt;/a&gt;（具有类型的二进制数据）形式返回 response&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;response.arrayBuffer()&lt;/code&gt;&lt;/strong&gt; —— 以 &lt;a href=&#34;https://zh.javascript.info/arraybuffer-binary-arrays&#34;&gt;ArrayBuffer&lt;/a&gt;（低级别的二进制数据）形式返回 response&lt;/li&gt;
&lt;li&gt;另外，&lt;code&gt;response.body&lt;/code&gt; 是 &lt;a href=&#34;https://streams.spec.whatwg.org/#rs-class&#34;&gt;ReadableStream&lt;/a&gt; 对象，它允许你逐块读取 body，我们稍后会用一个例子解释它。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们只能选择一种读取 &lt;code&gt;body&lt;/code&gt; 的方法。&lt;/p&gt;
&lt;p&gt;如果我们已经使用了 &lt;code&gt;response.text()&lt;/code&gt; 方法来获取 &lt;code&gt;response&lt;/code&gt;，那么如果再用 &lt;code&gt;response.json()&lt;/code&gt;，则不会生效，因为 &lt;code&gt;body&lt;/code&gt; 内容已经被处理过了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;post-请求&#34;&gt;&lt;code&gt;POST&lt;/code&gt; 请求&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let response = await fetch(url, {
  method: &#39;POST&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;
  },
  body: requestBody
});
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;body&lt;/code&gt; -- 请求体，可以是字符串、&lt;code&gt;FormData&lt;/code&gt;对象（以 &lt;code&gt;form/multipart&lt;/code&gt; 形式发送）、&lt;code&gt;Blob/BufferSource&lt;/code&gt;二进制数据等&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果请求的 &lt;code&gt;body&lt;/code&gt; 是字符串，则 &lt;code&gt;Content-Type&lt;/code&gt; 会默认设置为 &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt;。但是，当我们要发送 JSON 时，我们会使用 &lt;code&gt;headers&lt;/code&gt; 选项来发送 &lt;code&gt;application/json&lt;/code&gt;，这是 JSON 编码的数据的正确的 &lt;code&gt;Content-Type&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;用法小结&#34;&gt;用法小结&lt;/h4&gt;
&lt;p&gt;典型的 &lt;code&gt;fetch&lt;/code&gt; 请求由两个 &lt;code&gt;await&lt;/code&gt; 调用组成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let response = await fetch(url, [options]); // 解析 response header
let result = await response.json(); // 将 body 读取为 json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者以 &lt;code&gt;promise&lt;/code&gt; 形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fetch(url, [options])
  .then(response =&amp;gt; response.json())
  .then(result =&amp;gt; /* 处理结果 */)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;
&lt;p&gt;从 GitHub 获取用户信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  async function getUsers(names) {
    const response = await fetch(`https://api.github.com/users/${names}`);
    if (response.ok) {
    		const result = await response.json();
    		console.log(result);
    } else {
      return null;
    }
  }
  getUsers(&#39;qzlu-cyber&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;fetch-跟踪下载进度&#34;&gt;&lt;code&gt;Fetch&lt;/code&gt; 跟踪下载进度&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;fetch()&lt;/code&gt; 无法跟踪上传进度，但是可以跟踪下载进度。要跟踪下载进度，可以使用 &lt;code&gt;response.body&lt;/code&gt; 属性。它是 &lt;code&gt;ReadableStream&lt;/code&gt; —— 一个特殊的对象，它可以逐块（chunk）提供 &lt;code&gt;body&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 代替 response.json() 以及其他方法
const reader = response.body.getReader();

// 在 body 下载时，一直为无限循环
while(true) {
  // 当最后一块下载完成时，done 值为 true，否则为 false
  // value 是块字节的 Uint8Array
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Received ${value.length} bytes`)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;fetch-中止&#34;&gt;&lt;code&gt;fetch&lt;/code&gt; 中止&lt;/h4&gt;
&lt;p&gt;JavaScript 有一个特殊的内建对象 &lt;code&gt;AbortController&lt;/code&gt;，既可以中止 &lt;code&gt;fetch&lt;/code&gt; 也可以中止其他异步任务。&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let controller = new AbortController();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;controller&lt;/code&gt; 对象具有 &lt;code&gt;abort()&lt;/code&gt; 方法和 &lt;code&gt;signal&lt;/code&gt;属性。当 &lt;code&gt;abort()&lt;/code&gt; 被调用时，&lt;code&gt;abort&lt;/code&gt; 事件会在 &lt;code&gt;controller.signal&lt;/code&gt; 上触发，同时 &lt;code&gt;controller.signal.aborted&lt;/code&gt; 属性变为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let controller = new AbortController();
fetch(url, {
  signal: controller.signal // 将 signal 属性传递给 fetch 参数
}); // fetch 会监听 signal 上的 abort

controller.abort(); // 调用 controller.abort() 来中止
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个 &lt;code&gt;fetch&lt;/code&gt; 被中止，它的 &lt;code&gt;promise&lt;/code&gt; 就会以一个 error &lt;code&gt;AbortError&lt;/code&gt; 被 reject：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;try {
  let response = await fetch(&#39;/article/fetch-abort/demo/hang&#39;, {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == &#39;AbortError&#39;) { // 处理 abort()
    alert(&amp;quot;Aborted!&amp;quot;);
  } else {
    throw err;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AbortController&lt;/code&gt; 是可扩展的，它允许一次取消多个 fetch。也可以等待需要完成的 &lt;code&gt;fetch&lt;/code&gt; 异步网络请求后中止其他 &lt;code&gt;fetch&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) =&amp;gt; { // 需要完成的 fetch
  ...
  controller.signal.addEventListener(&#39;abort&#39;, reject);
});

let fetchJobs = urls.map(url =&amp;gt; fetch(url, { // 所有 fetch
  signal: controller.signal
}));

// 等待完成我们的任务和所有 fetch
let results = await Promise.all([...fetchJobs, ourJob]);

// 如果 controller.abort() 被从其他地方调用，
// 它将中止所有 fetch 和 ourJob
&lt;/code&gt;&lt;/pre&gt;
">JavaScript 网络请求 Fetch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/react-gao-ji-context/"" data-c="
          &lt;p&gt;在 React 中数据总是单向传递的，如果某个属性许多组件都需要就会使该过程变得极其繁琐，Context 提供了在组件间共享此类数据的方式，而不必显式地通过组件树的逐层传递 props。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;什么情况下使用-context&#34;&gt;什么情况下使用 Context&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当某个（些）属性需要传递的层级很深时&lt;/p&gt;
&lt;p&gt;考虑下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;class App extends Component {
  state = { count: 1 }
  render() {
    return (
        &amp;lt;div className=&#39;App&#39;&amp;gt;
          &amp;lt;h1&amp;gt;这是根组件&amp;lt;/h1&amp;gt;
          &amp;lt;Father count={this.state.count} /&amp;gt;
        &amp;lt;/div&amp;gt;
    );
  }
}

class Father extends Component {
  render() {
    return (
      &amp;lt;div className=&#39;father&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是父组件&amp;lt;/h1&amp;gt;
        &amp;lt;Son count={this.props.count} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

class Son extends Component {
  render() {
    return (
      &amp;lt;div className=&#39;son&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是子组件&amp;lt;/h1&amp;gt;
      	&amp;lt;h2&amp;gt;{this.props.count}&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;Son&lt;/code&gt; 组件需要来自根组件的 count，则需要从 &lt;code&gt;App&lt;/code&gt; 组件开始通过props 属性自上而下传递给 &lt;code&gt;Son&lt;/code&gt; 组件。使用 context, 我们可以避免通过中间元素传递 props：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
// 为当前的 theme 创建一个 context（1为默认值）。
const countContext = React.createContext(1);
class App extends Component {
  state = { count: 1 };
  render() {
    return (
     // 使用一个 Provider 来将当前的 state 传递给以下的组件树。
    // 无论多深，任何组件都能读取这个值。
    // 在这个例子中，我们将 state 作为当前的值传递下去。
      &amp;lt;Provider value={this.state}&amp;gt;
        &amp;lt;div className=&#39;App&#39;&amp;gt;
          &amp;lt;h1&amp;gt;这是根组件&amp;lt;/h1&amp;gt;
          &amp;lt;Father /&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/Provider&amp;gt;
    );
  }
}

// 中间的组件再也不必指明往下传递了。
class Father extends Component {
  render() {
    return (
      &amp;lt;div className=&#39;father&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是父组件&amp;lt;/h1&amp;gt;
        &amp;lt;Son /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

class Son extends Component {
  // 指定 contextType 读取当前的 count context。
  // React 会往上找到最近的 count Provider，然后使用它的值。
  // 在这个例子中，当前的 count 值为 1。
  static contextType = countContext; 
  render() {
    return (
      &amp;lt;div className=&#39;son&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是子组件&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;{this.context.count}&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
  // 也可使用 Consumer 渲染出 context
  /*
  render() {
    const { Consumer } = globalContext;
    return (
      &amp;lt;div className=&#39;son&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是子组件&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;{this.context.count}&amp;lt;/h2&amp;gt;
        &amp;lt;Consumer&amp;gt;{(context) =&amp;gt; &amp;lt;h2&amp;gt;{context.count}&amp;lt;/h2&amp;gt;}&amp;lt;/Consumer&amp;gt;
        &amp;lt;button onClick={this.add}&amp;gt;点我加1&amp;lt;/button&amp;gt;
        &amp;lt;button onClick={this.minus}&amp;gt;点我减1&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
  */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何在 &lt;code&gt;Son&lt;/code&gt; 组件中更改 Context 呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// 导出 context 修改函数
const actions = (self) =&amp;gt; ({
  add() {
    self.setState((preState) =&amp;gt; ({ count: preState.count + 1 }));
  },
  minus() {
    self.setState((preState) =&amp;gt; ({ count: preState.count - 1 }));
  },
});

class App extends Component {
  // 扩展 actions 并传入 this
  state = { count: InitialContext.count, ...actions(this) };
  render() {
    return (
      &amp;lt;Provider value={this.state}&amp;gt;
        &amp;lt;div className=&#39;App&#39;&amp;gt;
          &amp;lt;h1&amp;gt;这是根组件&amp;lt;/h1&amp;gt;
          &amp;lt;Father /&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/Provider&amp;gt;
    );
  }
}

class Son extends Component {
  static contextType = globalContext;

  // 调用在 context 中定义好的加减函数
  add = () =&amp;gt; {
    this.context.add();
  };

  minus = () =&amp;gt; {
    this.context.minus();
  };

  render() {
    return (
      &amp;lt;div className=&#39;son&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是子组件&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;{this.context.count}&amp;lt;/h2&amp;gt;
        &amp;lt;button onClick={this.add}&amp;gt;点我加1&amp;lt;/button&amp;gt;
        &amp;lt;button onClick={this.minus}&amp;gt;点我减1&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。如果仅仅是为了避免层层传递属性可以使用&lt;strong&gt;组件组合&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无亲属关系的组件需要共用的数据&lt;/p&gt;
&lt;p&gt;考虑下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;class App extends Component {
  render() {
    return (
      &amp;lt;div className=&#39;App&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是根组件&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

class Test extends Component {
  render() {
    return (
      &amp;lt;div className=&#39;son&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是另一个组件&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;App&lt;/code&gt; 组件和 &lt;code&gt;Test&lt;/code&gt; 组件既不是父子关系也不是兄弟关系，如果想要将 &lt;code&gt;App&lt;/code&gt;组件中的数据传递给 &lt;code&gt;Test&lt;/code&gt; 组件可以利用 Context 来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const countContext = React.createContext(&amp;quot;我是要传递的数据&amp;quot;);
class App extends Component {
  render() {
    return (
      &amp;lt;div className=&#39;App&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是根组件&amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

class Test extends Component {
  static contextType = globalContext;

  render() {
    return (
      &amp;lt;div className=&#39;test&#39;&amp;gt;
        &amp;lt;h1&amp;gt;这是另一个组件&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;{this.context}&amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;注意事项&lt;/h3&gt;
&lt;p&gt;Context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 &lt;code&gt;Provider&lt;/code&gt; 的父组件进行重渲染时，可能会在 &lt;code&gt;Consumers&lt;/code&gt; 组件中触发意外的渲染。举个例子，当每一次 &lt;code&gt;Provider&lt;/code&gt; 重渲染时，以下的代码会重渲染所有下面的 &lt;code&gt;Consumers&lt;/code&gt; 组件，因为 &lt;code&gt;value&lt;/code&gt; 属性总是被赋值为新的对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;class App extends Component {
  render() {
    return (
      &amp;lt;Provider value={1}&amp;gt;
        &amp;lt;div className=&#39;App&#39;&amp;gt;
          &amp;lt;h1&amp;gt;这是根组件&amp;lt;/h1&amp;gt;
          &amp;lt;Father /&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/Provider&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，将 &lt;code&gt;value&lt;/code&gt; 状态提升到父节点的 &lt;code&gt;state&lt;/code&gt; 中是更好的做法&lt;/p&gt;
">React 高级 -- Context</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/react-gao-ji-zhuang-tai-ti-sheng/"" data-c="
          &lt;p&gt;如果多个组件需要反映相同的变化数据，可将它们提升至最近的父组件，由父组件渲染后再分发个子组件。&lt;/p&gt;
&lt;p&gt;下面是一个汇率转换示例&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;code&gt;Money&lt;/code&gt;组件渲染出input标签：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;

const scaleNames = {
  R: &amp;quot;RMB&amp;quot;,
  D: &amp;quot;dollar&amp;quot;,
};

class Money extends Component {
  handleChange = (e) =&amp;gt; {
    this.props.onValueChange(e.target.value);
  };

  render() {
    const value = this.props.value;
    const scale = this.props.scale;
    return (
      &amp;lt;fieldset&amp;gt;
        &amp;lt;legend&amp;gt;请输入{scaleNames[scale]}:&amp;lt;/legend&amp;gt;
        &amp;lt;input value={value} onChange={this.handleChange} /&amp;gt;
      &amp;lt;/fieldset&amp;gt;
    );
  }
}

export default Money;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Calculator&lt;/code&gt;组件我们会把当前输入的 &lt;code&gt;value&lt;/code&gt; 和 &lt;code&gt;scale&lt;/code&gt; 保存在组件内部的 state 中。这个 state 就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的&lt;strong&gt;共同“数据源”&lt;/strong&gt;。这是我们为了渲染两个输入框所需要的所有数据的最小表示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { Component } from &amp;quot;react&amp;quot;;
import Money from &amp;quot;./money&amp;quot;;
import { toRMB, toDollar, tryConvert } from &amp;quot;./transform&amp;quot;;

class Calculator extends Component {
  constructor(props) {
    super(props);
    this.state = { value: 1, scale: &amp;quot;R&amp;quot; };
  }

  handleRMBChange = (value) =&amp;gt; {
    this.setState({ scale: &amp;quot;R&amp;quot;, value });
  };

  handleDollarChange = (value) =&amp;gt; {
    this.setState({ scale: &amp;quot;D&amp;quot;, value });
  };

  onValueChange = () =&amp;gt; {
    this.setState({
      value: &amp;quot;&amp;quot;,
      scale: &amp;quot;&amp;quot;,
    });
  };

  render() {
    const scale = this.state.scale;
    const value = this.state.value;
    const RMB = scale === &amp;quot;D&amp;quot; ? tryConvert(value, toRMB) : value;
    const dollar = scale === &amp;quot;R&amp;quot; ? tryConvert(value, toDollar) : value;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;Money scale=&amp;quot;R&amp;quot; value={RMB} onValueChange={this.handleRMBChange} /&amp;gt; //人民币
        &amp;lt;Money
          scale=&amp;quot;D&amp;quot;
          value={dollar}
          onValueChange={this.handleDollarChange}
        /&amp;gt; //美元
      &amp;lt;/div&amp;gt;
    );
  }
}

export default Calculator;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;transform&lt;/code&gt;汇率转换组件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;export function toRMB(dollar) {
  return dollar * 7;
}

export function toDollar(RMB) {
  return RMB / 7;
}

export function tryConvert(value, convert) {
  const input = parseFloat(value);
  if (Number.isNaN(input)) {
    return &amp;quot;&amp;quot;;
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当对输入框内容进行编辑时会发生些什么:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;React 会调用 DOM 中 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 的 &lt;code&gt;onChange&lt;/code&gt; 方法。在本实例中，它是 &lt;code&gt;Money&lt;/code&gt; 组件的 &lt;code&gt;handleChange&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Money&lt;/code&gt; 组件中的 &lt;code&gt;handleChange&lt;/code&gt; 方法会调用 &lt;code&gt;this.props.onValueChange()&lt;/code&gt;，并传入新输入的值作为参数。其 props 诸如 &lt;code&gt;onValueChange&lt;/code&gt; 之类，均由父组件 &lt;code&gt;Calculator&lt;/code&gt; 提供。&lt;/li&gt;
&lt;li&gt;起初渲染时，用于人民币输入的子组件 &lt;code&gt;Money&lt;/code&gt; 中的 &lt;code&gt;onValueChange&lt;/code&gt; 方法与 &lt;code&gt;Calculator&lt;/code&gt; 组件中的 &lt;code&gt;handleRMBChange&lt;/code&gt; 方法相同，而，用于美元输入的子组件 &lt;code&gt;Money&lt;/code&gt; 中的 &lt;code&gt;onValueChange&lt;/code&gt; 方法与 &lt;code&gt;Calculator&lt;/code&gt; 组件中的 &lt;code&gt;handleDollarChange&lt;/code&gt; 方法相同。因此，无论哪个输入框被编辑都会调用 &lt;code&gt;Calculator&lt;/code&gt; 组件中对应的方法。&lt;/li&gt;
&lt;li&gt;在这些方法内部，&lt;code&gt;Calculator&lt;/code&gt; 组件通过使用新的输入值与当前输入框对应的货币类型来调用 &lt;code&gt;this.setState()&lt;/code&gt; 进而请求 React 重新渲染自己本身。&lt;/li&gt;
&lt;li&gt;React 调用 &lt;code&gt;Calculator&lt;/code&gt; 组件的 &lt;code&gt;render&lt;/code&gt; 方法得到组件的 UI 呈现。汇率转换在这时进行，两个输入框中的数值通过当前输入值和其货币类型来重新计算获得。&lt;/li&gt;
&lt;li&gt;React 使用 &lt;code&gt;Calculator&lt;/code&gt; 组件提供的新 props 分别调用两个 &lt;code&gt;Money&lt;/code&gt; 子组件的 &lt;code&gt;render&lt;/code&gt; 方法来获取子组件的 UI 呈现。&lt;/li&gt;
&lt;/ol&gt;
">React 高级 -- 状态提升</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/react-gao-ji-biao-dan/"" data-c="
          &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;受控组件&lt;/p&gt;
&lt;p&gt;利用 state 管理 input等标签 的输入内容。内容只能通过 &lt;strong&gt;setState&lt;/strong&gt; 改变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: &#39;&#39;};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  //没有onChange事件会触发警告，导致文本框中的内容无法更改和显示
  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert(&#39;提交的名字: &#39; + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &amp;lt;form onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;label&amp;gt;
          名字:
          &amp;lt;input type=&amp;quot;text&amp;quot; value={this.state.value} onChange={this.handleChange} /&amp;gt;
        &amp;lt;/label&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;非受控组件&lt;/p&gt;
&lt;p&gt;建议采用受控组件，但是当你需要编写很多事件处理函数时可以使用非受控组件，即使用 ref 获取到真实的DOM节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef(); 
  }

  handleSubmit(event) {
    alert(&#39;A name was submitted: &#39; + this.input.current.value); //通过current定位到当前DOM节点
    event.preventDefault();
  }

  render() {
    return (
      &amp;lt;form onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;label&amp;gt;
          Name:
          &amp;lt;input type=&amp;quot;text&amp;quot; ref={this.input} /&amp;gt;
        &amp;lt;/label&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">React 高级 -- 表单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/&#34;&gt;操作系统学习笔记（一）--  引论&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/&#34;&gt;操作系统学习笔记（二）--  引论&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-处理机调度的层次和调度算法的目标&#34;&gt;1. 处理机调度的层次和调度算法的目标&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;处理机调度的层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高级调度：对象是作业，将处于后备队列的作业调入到内存。&lt;/li&gt;
&lt;li&gt;中级调度：即内存调度，旨在提高内存利用率和系统吞吐量，将暂时不能运行/能运行的进程调出/入内存。&lt;/li&gt;
&lt;li&gt;低级调度：对象是进程，决定就绪队列中哪个进程获得处理机，运行频率最高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调度算法的目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;共同目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;资源利用率，即尽可能使所有资源都处于忙碌状态&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t4UP3T.png&#34; alt=&#34;t4UP3T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公平性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平衡性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略强制执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批处理系统目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均周转时间短&lt;/li&gt;
&lt;li&gt;系统吞吐量高&lt;/li&gt;
&lt;li&gt;处理机利用率高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分时系统的目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间快&lt;/li&gt;
&lt;li&gt;均衡性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时系统的目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截止时间的保证&lt;/li&gt;
&lt;li&gt;可预测性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-作业与作业调度&#34;&gt;2. 作业与作业调度&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;批处理系统中的作业&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作业：包含通常的程序和数据即作业说明书。&lt;/li&gt;
&lt;li&gt;作业步：各个作业间相互独立，每个加工步骤成为一个作业步。&lt;/li&gt;
&lt;li&gt;作业控制块(JCB)：作业进入系统时建立JCB，保存了对作业进行管理和调度所需的全部信息。&lt;/li&gt;
&lt;li&gt;三种状态和三个阶段
&lt;ul&gt;
&lt;li&gt;收容阶段(后备状态)&lt;/li&gt;
&lt;li&gt;运行阶段(运行状态)&lt;/li&gt;
&lt;li&gt;完成阶段(完成状态)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作业调度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先来先服务(FCFS)调度算法：可用于作业、进程调度，系统按照作业到达的先后次序进行调度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;短作业优先(SJF)调度算法：可用于作业、进程调度，作业越短优先级越高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：能有效地降低作业的平均等待时间，提高系统吞吐量。&lt;/li&gt;
&lt;li&gt;缺点：需要预知作业运行时间；对长作业不利；无法实现交互；未考虑作业优先性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高优先权优先调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优先级调度算法(PSA)的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式优先权算法：主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。&lt;/li&gt;
&lt;li&gt;抢占式优先权调度算法：常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先权的类型&lt;br&gt;
① 静态优先权：静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变&lt;br&gt;
② 动态优先权：动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高响应比优先(HRRN)调度算法：既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。&lt;br&gt;
Rp优先级 =（等待时间 + 要求服务时间）/ 要求服务时间 = 响应时间 / 要求服务时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-进程调度&#34;&gt;3. 进程调度&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程调度的任务、机制和方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任务&lt;/p&gt;
&lt;p&gt;① 保存处理及现场信息；&lt;/p&gt;
&lt;p&gt;② 按某种算法选取进程；&lt;/p&gt;
&lt;p&gt;③ 把处理器分配给进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机制&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t40Ez6.png&#34; alt=&#34;t40Ez6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式&lt;/p&gt;
&lt;p&gt;① 非抢占方式：进程一旦分配到处理机，就让其一直运行下去，不会因其他条件抢占当前正在运行进程的处理机，直至结束。&lt;/p&gt;
&lt;p&gt;② 抢占方式：暂停某个正在运行的进程，将其处理机分配给另一个进程。遵循三个原则：优先权原则、短进程优先原则、时间片原则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轮转调度算法&lt;/p&gt;
&lt;p&gt;主要应用于分时系统。&lt;/p&gt;
&lt;p&gt;让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有 n 个进程，则每个进程每次大约都可获得 1/n 的处理机时间。&lt;/p&gt;
&lt;p&gt;时间片大小的确定：时间片略大于一次典型的交互所需要的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多队列调度算法&lt;/p&gt;
&lt;p&gt;将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级反馈队列调度算法&lt;/p&gt;
&lt;p&gt;设置多个就绪队列，每个就绪队列都采用 &lt;em&gt;&lt;strong&gt;FCFS&lt;/strong&gt;&lt;/em&gt; 算法，按队列优先级调度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t4suct.png&#34; alt=&#34;t4suct.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;若进程在本就绪队列的时间片完成则结束该进程，否则进入下一优先级就绪队列末尾等待执行，以此类推；若进程从阻塞队列被唤醒，则插入到比其本身高一优先级队列的末尾执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-实时调度&#34;&gt;4. 实时调度&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;实现条件&lt;/p&gt;
&lt;p&gt;① 提供必要的信息&lt;br&gt;
② 系统处理能力强&lt;br&gt;
③ 采用抢占式调度机制&lt;br&gt;
④ 具有快速切换机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类&lt;br&gt;
① 非抢占式调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式轮转调度算法&lt;/li&gt;
&lt;li&gt;非抢占式优先调度算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;② 抢占式调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于时钟中断的抢占式优先级调度算法&lt;/li&gt;
&lt;li&gt;立即抢占的优先级调度算法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t4ck7T.png&#34; alt=&#34;t4ck7T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最早截止时间优先(EDF)算法：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。具有最早截止时间的任务排在队列的最前面。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最低松弛度优先(LLF)算法：根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-死锁概述&#34;&gt;5. 死锁概述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重用性资源：可供用户重复使用多次的资源；此类资源中的单元只能分配给一个进程使用，不允许多个进程共享；遵循请求资源 -&amp;gt; 使用资源 -&amp;gt; 释放资源的顺序；数目固定，进程既不能创建也不能删除。&lt;/li&gt;
&lt;li&gt;可消耗性资源：临时性资源，由进程在运行期间动态地创建和删除。&lt;/li&gt;
&lt;li&gt;可抢占性资源：某进程得到该资源后，该资源仍可被其他进程或系统抢占，如CPU、主存等。&lt;/li&gt;
&lt;li&gt;不可抢占性资源：某进程得到该资源后，不能将此类资源强制回收，只能等待其主动释放，如打印机等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机系统中的死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;竞争不可抢占性资源引起死锁&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t420k8.png&#34; alt=&#34;t420k8.png&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;竞争可消耗资源引起死锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程推进顺序不当引起死锁&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t4RS9e.png&#34; alt=&#34;t4RS9e.png&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义：在多道程序系统中，一组进程中的每一个进程都在无限期地等待另一组进程所占有且永远不会释放的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产生的必要条件&lt;/p&gt;
&lt;p&gt;① 互斥条件&lt;/p&gt;
&lt;p&gt;② 请求和保持条件&lt;/p&gt;
&lt;p&gt;③ 不可抢占条件&lt;/p&gt;
&lt;p&gt;④ 循环等待条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理死锁的方法&lt;/p&gt;
&lt;p&gt;① 预防死锁&lt;/p&gt;
&lt;p&gt;② 避免死锁&lt;/p&gt;
&lt;p&gt;③ 检测死锁&lt;/p&gt;
&lt;p&gt;④ 解除死锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-预防死锁&#34;&gt;6. 预防死锁&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;破坏“请求和保持”条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种协议：进程在运行前，必须一次性地申请运行过程中的全部资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：简单、易行、安全。&lt;/li&gt;
&lt;li&gt;缺点：资源被严重浪费，严重恶化了资源利用率；使进程经常会发生饥饿现象(某进程所需某资源可能被其他进程长期占用)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种协议：获得运行必不可少的资源后立即开始运行，在运行过程中逐步释放已分配的且已用毕的资源再申请所需新资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使进程更快完成任务，提高设备利用率，减少进程发生饥饿的几率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏“不可抢占”条件&lt;/p&gt;
&lt;p&gt;进程已占有的资源会被暂时地释放，待以后需要时再重新申请。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代价较高，延长了进程周转时间，增加了系统开销，降低了系统吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏“循环等待”条件&lt;/p&gt;
&lt;p&gt;对系统所有资源类型线性排序，规定每个进程必须按序号递增的顺序请求资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优缺点：限制了新类型设备的增加，造成资源浪费，限制用户简单、自主编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-避免死锁&#34;&gt;7. 避免死锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;避免死锁的实质在于,系统在进行资源分配时,应使系统不进入不安全状态。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安全状态：在系统进行资源分配前计算此次资源分配是否安全，安全则分配，否则令进程等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用银行家算法避免死锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;p&gt;可用 &lt;em&gt;Available&lt;/em&gt;&lt;br&gt;
最大需求 &lt;em&gt;Max&lt;/em&gt;&lt;br&gt;
已分配 &lt;em&gt;Allocation&lt;/em&gt;&lt;br&gt;
还需要 &lt;em&gt;Need&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Need = Max - Allocation&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;银行家算法&lt;/p&gt;
&lt;p&gt;设 Requesti 是进程 Pi 的请求向量，如果 Requesti[ j ] == K，表示进程 Pi 需要 K 个 Rj 类型的资源。当Pi发出资源请求后，系统按下述步骤进行检査&lt;/p&gt;
&lt;p&gt;(1) 如果 Requesti[ j ] ≤ Need[ i, j ]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。&lt;br&gt;
(2) 如果 Requesti[ j ] ≤ Available[ i ]，便转向步骤(3)；否则，表示尚无足够资源，Pi 须等待。&lt;br&gt;
(3) 系统试探把资源分配给进程 Pi 并修改下面数据结构中的数值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Available[ j ] = Available[ j ] - Requesti[ j ]&lt;/p&gt;
&lt;p&gt;Allocation[ i, j ] = Allocation[ i, j ] + Requesti[ j ]&lt;/p&gt;
&lt;p&gt;Need[ i, j ] = Need[ i, j ] - Requesti[ j ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(4) 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程P，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程P等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性算法&lt;/p&gt;
&lt;p&gt;(1) 设置两个向量：①工作向量Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全性算法开始时，&lt;/p&gt;
&lt;p&gt;Wok = Available；② Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[ i ] = false；当有足够资源分配给进程时，再令 Finish[ i ] = true。&lt;br&gt;
(2) 从进程集合中找到一个能满足下述条件的进程 ① Finish[ i ] = false；② Needl[ i, j ] ≤ Work[ j ]；若找到，执行步骤(3)，否则，执行步骤(4)。&lt;br&gt;
(3) 当进程 P 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Work[ j ] = Work[ j ] + Allocation[ i, j ]&lt;/p&gt;
&lt;p&gt;Finish[ i ] = true&lt;/p&gt;
&lt;p&gt;go to step 2；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(4) 如果所有进程的 Finish[ⅰ] = true 都满足,则表示系统处于安全状态，否则，系统处于不安全状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-死锁的检测与解除&#34;&gt;8. 死锁的检测与解除&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检测&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/09/t44dJK.png&#34; alt=&#34;t44dJK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;若能消去图中所有的边，使所有的进程结点都成为孤立结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;死锁的解除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占资源。从一个或多个进程中抢占足够数量的资源,分配给死锁进程,以解除死锁状态。&lt;/li&gt;
&lt;li&gt;终止(或撇消)进程。终止(或撤消)系统中的一个或多个死锁进程,直至打破循环环路,使系统从死锁状态解脱出来。
&lt;ul&gt;
&lt;li&gt;终止所有死锁进程&lt;/li&gt;
&lt;li&gt;逐个终止进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">操作系统（三）--  处理机调度与死锁</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/&#34;&gt;操作系统学习笔记（一）--  引论&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/&#34;&gt;操作系统学习笔记（三）--  处理机调度与死锁&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/tRv9l6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRv9l6.md.png&#34; alt=&#34;tRv9l6.md.png&#34; style=&#34;zoom:80%;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-前趋图和程序执行&#34;&gt;1. 前趋图和程序执行&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;前驱图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRv4BD.png&#34; alt=&#34;tRv4BD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的顺序执行&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRv74A.png&#34; alt=&#34;tRv74A.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序性&lt;/li&gt;
&lt;li&gt;封闭性&lt;/li&gt;
&lt;li&gt;可再现性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的井发执行&lt;/p&gt;
&lt;p&gt;特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;间断性&lt;/li&gt;
&lt;li&gt;失去封闭性&lt;/li&gt;
&lt;li&gt;不可再现性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-进程的描述&#34;&gt;2. 进程的描述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程的定义和特征&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由程序段、相关的数据段和 &lt;strong&gt;PCB&lt;/strong&gt; 三部分便构成了进程实体(又称进程映像)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态性&lt;/li&gt;
&lt;li&gt;并发性&lt;/li&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;li&gt;异步性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程的基本状态及转换&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;三种基本状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就绪 Ready&lt;/li&gt;
&lt;li&gt;执行 Running&lt;/li&gt;
&lt;li&gt;阻塞 Block&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种基本状态的转换&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRzKeS.png&#34; alt=&#34;tRzKeS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;就绪状态→执行状态：为就绪队列队首的程序分配处理器。&lt;/li&gt;
&lt;li&gt;执行状态→就绪状态：时间片用完&lt;/li&gt;
&lt;li&gt;执行状态→阻塞状态：I/O请求&lt;/li&gt;
&lt;li&gt;阻塞状态→就绪状态：I/O完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入创建和终止的五状态转换&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWSVk4.png&#34; alt=&#34;tWSVk4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂起操作和进程状态的转换&lt;/p&gt;
&lt;p&gt;​		当该操作作用千某个进程时，该进程将被&lt;strong&gt;挂起&lt;/strong&gt;，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。 若原本处千就绪状态， 则该进程此时暂不接受调度。与挂起操作对应的操作是激活操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;挂起操作的引入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终端用户的需要&lt;/li&gt;
&lt;li&gt;父进程请求&lt;/li&gt;
&lt;li&gt;负荷调节的需要&lt;/li&gt;
&lt;li&gt;操作系统的需要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入挂起原语操作后三个进程状态的转换&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWPNa8.png&#34; alt=&#34;tWPNa8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;活动就绪(Readya) → 静止就绪(Readys)：未被挂起可以接受调度为Readya，挂起原语 Suspend 将该进程挂起后，变为Readys，不能接受调度。&lt;/li&gt;
&lt;li&gt;活动阻塞(Blockeda) → 静止阻塞(Blockeds)：未被挂起的阻塞为Blockeda，经 Suspend 挂起后，为 Blockeds；处于该状态的进程在其所期待的事件出现后，它将从 Blockeds 变为 Readys 状态。&lt;/li&gt;
&lt;li&gt;静止就绪(Readys) → 活动就绪(Readya)：处于 Readys 的进程被激活原语 Active 激活。&lt;/li&gt;
&lt;li&gt;静止阻塞(Blockeds) → 活动阻塞(Blockeda)：。处于 Blockeds 的进程被激活原语 Active 激活。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入挂起操作后五个进程状态的转换&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWPdPg.png&#34; alt=&#34;tWPdPg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程管理中的数据结构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程控制块 PCB 的作用&lt;/p&gt;
&lt;p&gt;PCB 的作用是使 在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位一个能与其他进程并发执行的进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为独立运行基本单位的标志&lt;/li&gt;
&lt;li&gt;能实现间断性运行方式&lt;/li&gt;
&lt;li&gt;提供进程管理所需要的信息&lt;/li&gt;
&lt;li&gt;提供进程调度所需要的信息&lt;/li&gt;
&lt;li&gt;实现与其它进程的同步与通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PCB 中的信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程标识符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部 ~ 用户&lt;/li&gt;
&lt;li&gt;内部 ~ OS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理机状态&lt;/p&gt;
&lt;p&gt;即处理机的上下文，由下面的寄存器组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器：用户程序可访问，用于暂存信息。&lt;/li&gt;
&lt;li&gt;指令计数器：存放要访问的下一条指令的地址。&lt;/li&gt;
&lt;li&gt;程序状态字 PSW：含有状态信息，如条件码、执行方式、中断屏蔽标志。&lt;/li&gt;
&lt;li&gt;用户栈指针：用于存放过程和系统调用参数及调用地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程调度信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程状态&lt;/li&gt;
&lt;li&gt;进程优先级&lt;/li&gt;
&lt;li&gt;进程调度其他信息&lt;/li&gt;
&lt;li&gt;事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程控制信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序和数据的地址&lt;/li&gt;
&lt;li&gt;程同步和通信机制&lt;/li&gt;
&lt;li&gt;资源清单&lt;/li&gt;
&lt;li&gt;链接指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程控制块的组织方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线性方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWktVx.png&#34; alt=&#34;tWktVx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWkrMd.png&#34; alt=&#34;tWkrMd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引方式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWkhRg.png&#34; alt=&#34;tWkhRg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-进程控制&#34;&gt;3. 进程控制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;操作系统内核&lt;/p&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统态（管态）：高权限，能执行一切指令，传统 OS 运行在此。&lt;/li&gt;
&lt;li&gt;应用态（目态）：低权限，只能运行一部分指令，应用程序运行在此。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;支撑功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;li&gt;时钟管理&lt;/li&gt;
&lt;li&gt;原语操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源管理功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程管理&lt;/li&gt;
&lt;li&gt;存储器管理&lt;/li&gt;
&lt;li&gt;设备管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程的创建与撤销&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方式：由系统程序创建、由父进程创建&lt;/li&gt;
&lt;li&gt;引起创建的事件：用户登录、作业调度、提供服务、应用请求&lt;/li&gt;
&lt;li&gt;过程：&lt;br&gt;
① 申请空白PCB&lt;br&gt;
② 为新进程分配资源&lt;br&gt;
③ 初始化进程控制块&lt;br&gt;
④ 将新进程插入就绪队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;撤销&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方式：由操作系统终止、有进程发出请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引起撤销的事件：正常结束、异常结束（越界错误、运行超时）、外界干预（父进程请求、父进程终止）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;p&gt;① 根据标识符找到该进程，读取状态&lt;/p&gt;
&lt;p&gt;② 若正处于执行状态，立即终止该，并置调度标志为真，用于指示该进程被终止后应重新进行调度&lt;/p&gt;
&lt;p&gt;③ 若该进程还有子孙进程，一并终止&lt;/p&gt;
&lt;p&gt;④ 将该进程所有资源还给父进程或 OS&lt;/p&gt;
&lt;p&gt;⑤ 将该进程 PCB 移出PCB表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程的阻塞与唤醒&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;引起阻塞或唤醒的主要事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求系统服务&lt;/li&gt;
&lt;li&gt;启动某些操作&lt;/li&gt;
&lt;li&gt;新数据尚未到达&lt;/li&gt;
&lt;li&gt;无新工作可做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程阻塞过程&lt;/p&gt;
&lt;p&gt;​		正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语 block 将自己阻塞(主动行为)。立即停止执行，把进程控制块中的现行状态由“执行“改为阻塞，并将 PCB 插入阻塞队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程唤醒过程&lt;/p&gt;
&lt;p&gt;​		调用唤醒原语 wakeup， 首先把被阻塞的进程从等待该事件的阻塞队列中移出， 将其 PCB 的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序的挂起与激活&lt;/p&gt;
&lt;p&gt;激活过程：（挂起为其逆过程）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将进程从外存调入内存&lt;/li&gt;
&lt;li&gt;检查该进程现行状态&lt;/li&gt;
&lt;li&gt;若是静止就绪，改为活动就绪；若是静止阻塞，改为活动阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-进程同步&#34;&gt;4. 进程同步&lt;/h3&gt;
&lt;p&gt;为保证多个进程能有条不紊地运行，在多道程序系统中，必须引入进程同步机制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程同步的基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;两种形式的制约关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;间接相互制约关系&lt;/li&gt;
&lt;li&gt;直接相互制约关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临界资源&lt;/p&gt;
&lt;p&gt;​		虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临界区&lt;/p&gt;
&lt;p&gt;在每个进程中访问临界资源的那段代码称为临界区。&lt;/p&gt;
&lt;p&gt;访问临界资源的循环进程描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while (TRUE) 
{
	进入区
	临界区
	退出区
	剩余区
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步机制应遵循的规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲让进&lt;/li&gt;
&lt;li&gt;忙则等待&lt;/li&gt;
&lt;li&gt;有限等待&lt;/li&gt;
&lt;li&gt;让权等待&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件同步机制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用 &lt;em&gt;&lt;strong&gt;Test-and-Set&lt;/strong&gt;&lt;/em&gt; 指令实现互斥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//lock=FALSE 时，表示该资源空闲； lock=TRUE 时， 表示该资源正在被使用。
boolean TS(boolean *lock) 
{
	Boolean old;
	old = *lock;
	*lock = TRUE;
	return old;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//为每个临界资源设置一个布尔变量lock, 初值为FALSE, 表示该临界资源空闲。进程在进入临界区之前，首先用TS测试lock, 若为FALSE则表示没有进程在临界区可以进入，并将TRUE值赋予lock，即关闭临界资源，使任何进程都不能进入临界区，否则必须循环测试直到TS(s)为TRUE。
do {
	while TS(&amp;amp;lock);
	critical section;
	lock := FALSE;
	remainder section;
} while(TRUE) ; 
//不符合让权等待原则
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用 &lt;em&gt;&lt;strong&gt;Swap&lt;/strong&gt;&lt;/em&gt; 指令实现进程互斥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void swap(boolean *a, booJean *b)
{
	boolean temp ;
	temp = *a;
	*a = *b;
	*b = temp; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//为每个临界资源设置一个全局的布尔变lock，其初值为false，在每个进程中再利用一个局部布尔变量key
do {
	key=TRUE;
	do {
	swap(&amp;amp;lock , &amp;amp;key);
} while (key!=FALSE );
	/*临界区操作*/
	lock = FALSE;
} while (TRUE); 
//不符合让权等待原则
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量机制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整型信号量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//S表示资源数目；P-V操作
wait(S)
{
	while (S&amp;lt;=O);
	S--;
}
signal(S)
{
	S++; 
}
//不符合让权等待原则
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录型信号量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct {
	int value; //表示资源数目
	struct process_control_block *list; //用于链接所有等待进程
} semaphore ; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//每次wait操作代表有一个进程试图访问临界资源
wait(semap hore *S) 
{ 
	S-&amp;gt;value--; //临界资源减1之后，≥0代表还有资源可以访问
	if (S-&amp;gt;value &amp;lt; 0) block (S-&amp;gt;list); //小于0随即进入等待队列
}

//每次signal操作代表有一个进程试图释放临界资源
signal(semaphore *S) 
{
	S-&amp;gt;value++; //临界资源加1后，小于0代表还没有临界资源可以访问
	if (S-&amp;gt;value &amp;lt;= O) wakeup(S-&amp;gt;list); //≤0代表还有进程试图访问临界资源，随即唤醒等待队列中的第一个进程
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AND 型信号量&lt;/p&gt;
&lt;p&gt;适用于一个进程需要访问两个及以上的临界资源。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Swait(Sl , S2,..., Sn)
{
	while (TRUE)
	{
		if (Si&amp;gt;=1 &amp;amp;&amp;amp;... &amp;amp;&amp;amp; Sn&amp;gt;=1)
        {
			for (i=1; i&amp;lt;=n; i++) Si--;
			break; 
        }
        else 
        {
			place the process in the waiting queue associated with the frrst Si found with
			Si&amp;lt;1 , and set the program count of this process to the beginning of Swait operation 
        }
	}
}

Ssignal(Sl , S2, .. ., Sn)
{
	while (TRUE) 
    {
		for(i=1; i&amp;lt;=n; i++) 
        {
			Si++;
			Remove all the process waiting in the queue associated with Si into the ready queue 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量集&lt;/p&gt;
&lt;p&gt;对 AND 信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量在一次 P、V 原语操作中完成申请或释放。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//资源分配下限值ti,即要求Si≥ti,否则不予分配。一旦允许分配，进程对该资源的需求值为di,即表示资源占用量,进行Si = Si - di操作。
Swait(S1 t1, d1, ..., Sn, tn, dn);

Ssignal(S1, d1,.. ., Sn, dn);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;Swait(S, d, d) //此时在信号量集中只有一个信号量S, 但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
Swait(S, 1, 1) //此时的信号量集已蜕化为一般的记录型信号量(S &amp;gt; 1时）或 互斥信号量(S = 1时）。
Swait(S, 1, 0) //当 S≥1 时，允许多个进程进入某特定区;当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量的应用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用信号量实现进程互斥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//mutex 互斥信号量其初值为1, 当mutex = 1时，表示两个进程皆未进入需要互斥的临界区; mutex = 0，表示有一个进程进入临界区运行，另外一个必须等待，挂入阻塞队列; 当mutex = -1 时，表示有一个进程正在临界区运行，另个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。
semaphore mutex= 1;
P(A)
{
    while(1) 
    {
		wait(mutex);
    	/*临界区*/
		signal(mutex);
		/*剩余区*/
	}
}

P(B)
{
    while(1)
    {
		wait(mutex);
		/*临界区*/
		signal(mutex);
		/*剩余区*/
    }
}
//wait(mutex) signal(mutex) 必须成对地出现，缺少wait(mutex)将会导致系统混乱，不能保证对临界资源的互斥访问; 缺少signal(mutex)将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程不能被唤醒。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用信号量实现前趋关系&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tW88Q1.png&#34; alt=&#34;tW88Q1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;p1() { S1; signal(a); signal(b);}
p2() { wait(a); S2; signal(c); signal(d);}
p3() { wait(b); S3; signal(e);}
p4() { wait(c); S4; signal(t);}
p5() { wait(d); Ss; signal(g);}
p6() { wait(e); wait(f); wait(g); S6;}
main() 
{
    semaphore a, b, c, d, e, f, g;
    a.value = b.value = c.value = 0；
    d.value = e.value = 0;
    f.value = g.value = 0;
    cobegin
        pl(); p2(); p3(); p4(); p5(); p6(); 
    coend
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-经典进程的同步问题&#34;&gt;5. 经典进程的同步问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生产者－消费者问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;​		一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int in=0, out=0; //指向生产、消费的指针
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
void producer() //生产者进程
{ 
    do{
        produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元 /*wait(empty);wait(mutex); 或 Swait(empty, mutex );*/
        P(mutex);  //进入临界区
        add nextp to buffer;  //将数据放入缓冲区
        in=(in+ 1) % n; //指针后移
        V(mutex);  //离开临界区,释放互斥信号量 /*signal(mutex);signal(full); 或 Ssignal(mutex, full);*/
        V(full);  //满缓冲区数加1
    }while(TRUE)
}
void consumer() //消费者进程
{  
    do{
        P(full);  //获取满缓冲区单元 /*wait(full);wait(mutex); 或 Swait(full, mutex );*/
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        out=(out+l) % n; //指针后移
        V (mutex);  //离开临界区，释放互斥信号量 /*signal(mutex);signal(empty); 或 Ssignal(mutex, empty);*/
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    }while(TRUE)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该类问题要注意对缓冲区大小为 &lt;em&gt;n&lt;/em&gt; 的处理，当缓冲区中有空时便可对empty变量执行 P操作，一旦取走一个产品便要执行 V操作 以释放空闲区。对empty和full变量的 P操作 必须放在对 &lt;em&gt;mutex&lt;/em&gt; 的 P操作 之前。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果生产者进程先执行P(mutex)，然后执行P(empty)，消费者执行P(mutex),然后执行P(fall),这样可不可以？&lt;/p&gt;
&lt;p&gt;答案是否定的。设想生产者进程已经将缓冲区放满，消费者进程并没有取产品，即 empty = 0，当下次仍然是生产者进程运行时，它先执行P(mutex)封锁信号量，再执行P(empty)时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行P(mutex)，然而由于生产者进程已经封锁mutex信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，陷入了无休止的等待。同理，如果消费者进程已经将缓冲区取空，即 full = 0,下次如果还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex、full先释放哪一个无所谓，消费者先释放mutex还是empty都可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哲学家进餐问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;​		一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {1, 1, 1, 1, 1}用于对5个筷子的互斥访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。
semaphore chopstick[5] = {1,1,1,1,1}; //定义信号量数组chopstick[5],并初始化
void Pi() //i号哲学家的进程
{  
    do{
        P(chopstick[i]); //取左边筷子 /*wait(chopstick[i]);wait(chopstick[(i+l)%5]); 或 Sswait(chopstick[(i+1)%5], chopstick[i]);*/
        P(chopstick[(i+1)%5]); //取右边篌子
        eat; //进餐
        V(chopstick[i]); //放回左边筷子 /*signal(chopstick[i]);signal(chopstick[(i+l)%5]); 或 Ssignal(chopstick[(i+1)%5], chopstick[i]);*/
        V(chopstick[(i+l)%5]); //放回右边筷子
        think; //思考
    } while(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该算法存在以下问题：&lt;br&gt;
当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完&lt;em&gt;wait(chopstick[i]&lt;/em&gt;);)筷子已经被拿光了，等到他们再想拿右边的筷子的时候（执行 &lt;em&gt;wait(chopstick[(i+l)%5]&lt;/em&gt;);)就全被阻塞了，这就出现了死锁。&lt;/p&gt;
&lt;p&gt;​		为了防止死锁的发生，可以对哲学家进程施加一些限制条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有 1 位哲学家能 够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐&lt;/li&gt;
&lt;li&gt;仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐&lt;/li&gt;
&lt;li&gt;规定奇数号哲学家先拿左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定将是 1、2号哲学家竞争 1号筷子，3、4号哲学家竞争 3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有 1位哲学家 能获得两只筷子而进餐.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读者-写者问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：&lt;br&gt;
① 允许多个读者可以同时对文件执行读操作；&lt;br&gt;
② 只允许一个写者往文件中写信息；&lt;br&gt;
③ 任一写者在完成写操作之前不允许其他读者或写者工作；&lt;br&gt;
④ 写者执行写操作前，应让已有的读者和写者全部退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int count=0;  //用于记录当前的读者数量
semaphore mutex=1;  //用于保护更新count变量时的互斥
semaphore rw=1;  //用于保证读者和写者互斥地访问文件
void writer() //写者进程
{  
    do{
        P(rw); // 互斥访问共享文件
        Writing;  //写入
        V(rw) ;  //释放共享文件
    }while(TRUE)
}
void reader () //读者进程
{  
    do{
        P (mutex) ;  //互斥访问count变量
        if (count==0)  //当第一个读进程读共享文件时
            P(rw);  //阻止写进程写
        count++;  //读者计数器加1
        V (mutex) ;  //释放互斥变量count
        reading;  //读取
        P (mutex) ;  //互斥访问count变量
        count--; //读者计数器减1
        if (count==0)  //当最后一个读进程读完共享文件
            V(rw) ;  //允许写进程写
        V (mutex) ;  //释放互斥变量 count
    }while(TRUE)
}
void main() 
{
	cobegin
	reader(); writer();
	coend 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-进程通信&#34;&gt;6. 进程通信&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;p&gt;进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;共享存储器系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于共享数据结构的通信方式：通信效率低下，属于低级通信。&lt;/li&gt;
&lt;li&gt;基于共享存储区的通信方式：属于高级通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;管道(pipe)通信系统&lt;/p&gt;
&lt;p&gt;​		一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息传递系统&lt;/p&gt;
&lt;p&gt;​		以格式化的消息(Message)为单位。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。&lt;/li&gt;
&lt;li&gt;间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户机－服务器系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;套接字Socket
&lt;ul&gt;
&lt;li&gt;基于文件型&lt;/li&gt;
&lt;li&gt;基于网络型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;远程过程调用和远程方法调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息传递通信的实现方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;直接消息传递系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接通信原语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称寻址方式&lt;/p&gt;
&lt;p&gt;send(recei ver, message); 发送一个消息给接收进程&lt;/p&gt;
&lt;p&gt;receive(sender, message); 接收 Sender 发来的消息&lt;/p&gt;
&lt;p&gt;缺点：进程一旦改变名字，则要找到其所有历史名字以便修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非对称寻址方式&lt;/p&gt;
&lt;p&gt;send(P , message); 发送一个消息给进程&lt;/p&gt;
&lt;p&gt;receive (id, message); 接收来自任何进程的消息， id变量可设置为进行通信的发送方进程 id 或名字。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信箱通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信箱结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信箱头，用以存放有关信箱的描述信息，如信箱标识符、信箱的拥有者、信箱口令、信箱的空格数等；&lt;/li&gt;
&lt;li&gt;信箱体，由若干个可以存放消息（或消息头）的信箱格组成，信箱格的数目以及每格的大小是在创建信箱时确定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tWo39S.png&#34; alt=&#34;tWo39S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信箱通信原语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;邮箱的创建和撤消&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息的发送和接收&lt;/p&gt;
&lt;p&gt;进程之间要利用邮箱进行通信时，必须使用共享邮箱。&lt;/p&gt;
&lt;p&gt;Send(mailbox, message); 个消息发送到指定邮箱&lt;/p&gt;
&lt;p&gt;Receive(mailbox, message); 从指定邮箱中接收一个消息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信箱的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私用邮箱：进程自己创建，所有者可以读取消息，其他进程只能发送。进程结束时，邮箱也随之消失。&lt;/li&gt;
&lt;li&gt;公用邮箱：OS 创建，经核准的进程可向其发送消息也可读取给自己的消息。在系统运行期间始终存在。&lt;/li&gt;
&lt;li&gt;共享邮箱：进程创建，创建时指明为共享邮箱并指出共享进程的名字，所有者和共享者可以读取给自己的消息。进程结束时，邮箱也随之消失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送进程和接收进程的四种关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一对一关系&lt;/li&gt;
&lt;li&gt;多对一关系&lt;/li&gt;
&lt;li&gt;一对多关系&lt;/li&gt;
&lt;li&gt;多对多关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-线程threads的基本概念&#34;&gt;7. 线程（Threads）的基本概念&lt;/h3&gt;
&lt;p&gt;引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程的引入&lt;/p&gt;
&lt;p&gt;线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是&lt;strong&gt;程序执行的最小单元&lt;/strong&gt;，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。&lt;/p&gt;
&lt;p&gt;引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理机的分配单元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程与进程的比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调度的基本单位&lt;/p&gt;
&lt;p&gt;进程较重，在被调度时执行上下文开销较大。将线程作为调度和分派的基本单位，切换代价较低。&lt;/p&gt;
&lt;p&gt;在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一进程中的线程时，必然会引起进程的切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发性&lt;/p&gt;
&lt;p&gt;进程间，一个进程中的多个/全部线程，不同进程中的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥有资源&lt;/p&gt;
&lt;p&gt;线程仅拥有必不可少的保证独立运行的资源，共享该进程的所有资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立性&lt;/p&gt;
&lt;p&gt;线程间的独立性远远低于进程间的独立性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统开销&lt;/p&gt;
&lt;p&gt;创建和撤销进程的开销远大于线程的开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持多处理机系统&lt;/p&gt;
&lt;p&gt;单线程进程，该进程只能运行在一个处理机上；多线程进程，可将进程中的多个线程分配到多个处理机上，并行执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的状态和线程控制块&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;三个状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行状态，表示线程已获得处理机而正在运行；&lt;/li&gt;
&lt;li&gt;就绪状态，指线程已具备了各种执行条件，只须再获得 CPU 便可立即执行；&lt;/li&gt;
&lt;li&gt;阻塞状态，指线程在执行中因某事件受阻而处于暂停状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程间的状态转换与进程间的状态转换相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程控制块 TCB&lt;/p&gt;
&lt;p&gt;① 线程标识符，为每个线程赋予一个唯一的线程标识符。&lt;/p&gt;
&lt;p&gt;② 一组寄存器，程序寄存器等。&lt;/p&gt;
&lt;p&gt;③ 线程运行状态，线程此时运行状态。&lt;/p&gt;
&lt;p&gt;④ 优先级，描述线程执行的优先程度。&lt;/p&gt;
&lt;p&gt;⑤ 线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等。&lt;/p&gt;
&lt;p&gt;⑥ 信号屏蔽，对某些信号加以屏蔽。&lt;/p&gt;
&lt;p&gt;⑦ 堆栈指针，保存局部变量和返回地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程 OS 中的进程属性&lt;/p&gt;
&lt;p&gt;① 进程是一个可拥有资源的基本单位。&lt;/p&gt;
&lt;p&gt;② 多个线程可并发执行。&lt;/p&gt;
&lt;p&gt;③ 进程已不是可执行的实体 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-线程的实现&#34;&gt;8. 线程的实现&lt;/h3&gt;
&lt;p&gt;实现方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;以线程为基本调度单位的内核支持线程[与内核紧密相关]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以进程为基本调度单位的用户级线程[与内核无关]&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
">操作系统学习笔记（二）--  进程的描述与控制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-yi-yin-lun/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/cao-zuo-xi-tong-xue-xi-bi-ji-er-jin-cheng-de-miao-shu-yu-kong-zhi/&#34;&gt;操作系统学习笔记（二）--  引论&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/cao-zuo-xi-tong-san-chu-li-ji-diao-du-yu-si-suo/&#34;&gt;操作系统学习笔记（三）--  处理机调度与死锁&lt;/a&gt;&lt;br&gt;
​		操作系统(OS)，是配置在计算机硬件的笫 一层软件，其主要作用是管理这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口便于用户使用。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-操作系统的目标和作用&#34;&gt;1. 操作系统的目标和作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方便性&lt;/li&gt;
&lt;li&gt;有效性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;开放性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OS 作为用户与计算机硬件系统之间的接口&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRbpSU.png&#34; alt=&#34;tRbpSU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS 作为计算机系统资源的管理者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS 实现了对计算机资源的抽象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-操作系统的发展过程&#34;&gt;2. 操作系统的发展过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;未配置操作系统的计算机系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;人工操作方式：手工操作、速度慢、CPU浪费严重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脱机输入/输出方式((Off-Line I/O)：该技术是事先将有用户程序和数据的纸袋装入纸袋输入机，在一台外围机的控制下，把纸带上的数据（程序）输入到磁带上。减少了 CPU 的空闲时间；提高了 I/O 速度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRqP9f.png&#34; alt=&#34;tRqP9f.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单道批处理系统：为实现对作业的连续处理，先把一批作业输入到磁带上，一个接一个的连续处理。注意&lt;strong&gt;在内存中始终只有一道作业&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特征： 自动性、顺序性、单道性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：系统中的资源得不到充分的利用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRqcVA.png&#34; alt=&#34;tRqcVA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多道批处理系统：用户提交的作业先放在外存上，排成“&lt;strong&gt;后备队列&lt;/strong&gt;”。由作业调度程序选择作业进入内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特征：多道性、无序性、调度性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优缺点：提高CPU利用率、提高内存和IO利用率、增加系统吞吐量；平均周转时间长、无交互能力。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/08/tRqq5q.png&#34; alt=&#34;tRqq5q.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分时系统：在一台主机上链接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键问题：及时接受、及时处理(时间片轮转)。&lt;/li&gt;
&lt;li&gt;特征：多路性、独占性、及时性、交互性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时系统：系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类：硬实时任务（对截止时间的要求十分严格）、软实时任务（对截止时间没那么严格）&lt;/li&gt;
&lt;li&gt;特征：多路性、独占性、及时性、交互性、可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微机操作系统：主要动力来源有不断提高计算机资源的利用率、方便用户、器件的不断更新换代、计算机体系结构的不断发展。每一代计算机几乎都是为了改进上一代计算机的缺点进而产生的，也促进了操作系统的不断发展。&lt;br&gt;
分类可以根据发展历程进行分类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单用户单任务：MS-DOS&lt;/li&gt;
&lt;li&gt;单用户多任务：windows95&lt;/li&gt;
&lt;li&gt;多用户多任务：UNIX OS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-操作系统的基本特性&#34;&gt;3.  操作系统的基本特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;并发性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;并行性是指多个时间在同一时刻发生。&lt;/li&gt;
&lt;li&gt;并发性是指多个事件在同一时间间隔内发生。&lt;br&gt;
并发性是指一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每个时刻只有一个程序在执行，微观上也是分时交替执行。若有多个处理机，则可以实现并行执行。&lt;/li&gt;
&lt;li&gt;并发性是四大特征中，最基础的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享性
&lt;ul&gt;
&lt;li&gt;共享是指系统中的资源可供内存中多个并发执行的进程共同使用。&lt;/li&gt;
&lt;li&gt;互斥共享：指一段时间内只允许一个进程访问某种资源，也成为临界资源或独占资源。如打印机、磁带机。&lt;/li&gt;
&lt;li&gt;同步共享：宏观上允许一段时间内多个进程同时对某资源进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟性&lt;br&gt;
虚拟是指利用某种技术，把一个物理实体变为若干个逻辑上的对应物。前者物理实体是实际存在的，而后者是用户感觉上的东西。如虚拟内存、虚拟处理机大等。
&lt;ul&gt;
&lt;li&gt;时分复用技术&lt;/li&gt;
&lt;li&gt;空分复用技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步性&lt;br&gt;
进程是以人们不可预知的速度向前推进的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-操作系统的主要功能&#34;&gt;4. 操作系统的主要功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;处理机管理功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程控制&lt;/li&gt;
&lt;li&gt;进程同步&lt;/li&gt;
&lt;li&gt;进程通信&lt;/li&gt;
&lt;li&gt;调度（作业调度、进程调度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器管理功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存分配（静态分配方式，动态分配方式）&lt;/li&gt;
&lt;li&gt;内存保护&lt;/li&gt;
&lt;li&gt;地址映射&lt;/li&gt;
&lt;li&gt;内存扩充（请求调入、置换）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备管理功能&lt;/p&gt;
&lt;p&gt;设备管理的主要任务如下： (1) 完成用户进程提出的 I/O 请求，为用户进程分配所需的 I/O 设备，并完成指定的 I/O 操作&lt;/p&gt;
&lt;p&gt;(2) 提高 CPU I/O 设备的利用率 提高 I/O 速度，方便用户使用 I/O 设备&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓冲管理&lt;/li&gt;
&lt;li&gt;设备分配&lt;/li&gt;
&lt;li&gt;设备处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件管理功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件存储空间的管理&lt;/li&gt;
&lt;li&gt;目录管理&lt;/li&gt;
&lt;li&gt;文件的读 写管理和保护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统与用户之间的接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户接口&lt;/li&gt;
&lt;li&gt;程序接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-os-结构设计&#34;&gt;5. OS 结构设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;传统操作系统结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无结构操作系统&lt;/li&gt;
&lt;li&gt;模块化结构 OS&lt;/li&gt;
&lt;li&gt;分层式结构 OS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现代操作系统的结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微内核结构：足够小的内核、基于客户-服务器模式、应用机制与策略分离原理、采用面向对象技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">操作系统学习笔记（一）--  引论</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/&#34;&gt;计算机网络学习笔记（一）--  计算机网络概述&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/&#34;&gt;计算机网络学习笔记（二）--  物理层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/&#34;&gt;计算机网络学习笔记（三）--  数据链路层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/&#34;&gt;计算机网络学习笔记（四）--  网络层&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-运输层协议概述&#34;&gt;1. 运输层协议概述&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程之间的通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向它上面的应用层提供通信服务。&lt;/li&gt;
&lt;li&gt;面向通信部分的最高层。&lt;/li&gt;
&lt;li&gt;用户功能中的最低层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通信的真正端点井不是主机而是主机中的进程。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgtV54.png&#34; alt=&#34;tgtV54.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运输层的两个主要协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户数据报协议 UDP&lt;/strong&gt; (User Datagram Protocol)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输控制协议 TCP&lt;/strong&gt; (Transmission Control Protocol)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgN9Fe.png&#34; alt=&#34;tgN9Fe.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运输层的端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;识别各应用层进程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只具有本地意义；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;端口范围：（0 - 65535）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①熟知端口号（0~1023）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②登记（或注册）端口号（1024~49151）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③客户（或动态、短暂）端口号（49152~65535）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套接字socket&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;套接字 socket = (IP 地址：端口号）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-用户数据报协议-udp&#34;&gt;2. 用户数据报协议 UDP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;p&gt;① 无连接；（减少开销和发送时延）&lt;/p&gt;
&lt;p&gt;③ 尽最大努力交付；&lt;/p&gt;
&lt;p&gt;④ 面向报文；（对报文不分拆，不合并）&lt;/p&gt;
&lt;p&gt;⑤ 没有拥塞控制；&lt;/p&gt;
&lt;p&gt;⑥ 支持一对一，一对多，多对一，多对多的交互通信；&lt;/p&gt;
&lt;p&gt;⑦ 首部开销小。（8个字节）&lt;/p&gt;
&lt;p&gt;⑧无编号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP首部格式&lt;/p&gt;
&lt;p&gt;有 8 个字节 ，由 4 个字段组成，每个字段的长度都是 2 个字节。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgNLtg.png&#34; alt=&#34;tgNLtg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;(1) &lt;strong&gt;源端口&lt;/strong&gt;：源端口号。在需要对方回信时选用。不需要时可用全 0。&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;目的端口&lt;/strong&gt;：目的端口号。这在终点交付报文时必须使用。&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;长度&lt;/strong&gt;：UDP用户数据报的长度，其最小值是 8 （仅有首部）。&lt;/p&gt;
&lt;p&gt;(4) &lt;strong&gt;检验和&lt;/strong&gt;：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgUE9J.png&#34; alt=&#34;tgUE9J.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果接收方 UDP 发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网 ICMP 发送“端口不可达”差错报文给发送方。&lt;/p&gt;
&lt;p&gt;UDP 的通信是无连接的，虽然使用了端口号但不需要使用套接字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP 计算检验和&lt;/p&gt;
&lt;p&gt;把首部和数据部分一起都检验，IP数据报是只检验首部&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgUhUU.png&#34; alt=&#34;tgUhUU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;16 位的字视为 1 字节。若数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-传输控制协议-tcp-概述&#34;&gt;3. 传输控制协议 TCP 概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;p&gt;① 面向连接的服务；&lt;/p&gt;
&lt;p&gt;② 面向字节流；（无结构的字节流）&lt;/p&gt;
&lt;p&gt;③ 全双工通信；（发送、接收缓存）&lt;/p&gt;
&lt;p&gt;④ 复用和分用；（发送—复用，接收—分用）&lt;/p&gt;
&lt;p&gt;⑤ 进程到进程的通信；（点对点，每个进程都需要一个连接）&lt;/p&gt;
&lt;p&gt;⑥ 可靠的服务。（无差错，不丢失，不重复，按序到达）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP 连接&lt;/p&gt;
&lt;p&gt;TCP 之间的通信必须要在两个套接字之间建立连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 连接：：＝ {socket, socket2} = { (IP1: port,), (IP2: port2) }&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-可靠传输的工作原理&#34;&gt;4. 可靠传输的工作原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;停止等待协议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无差错情况和出现差错&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tga0qx.png&#34; alt=&#34;tga0qx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;A 向 B 发送，B 收到后向 A 发送确认报文，A 发送下一条报文。若超过一段时间 A 没有收到确认报文就重传该报文。&lt;/p&gt;
&lt;p&gt;A 在发送完一个分组后，必须暂时保留已发送的分组的副本，收到确认后才能销毁。&lt;/p&gt;
&lt;p&gt;分组和确认分组都必须进行编号。&lt;/p&gt;
&lt;p&gt;超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确认丢失和确认迟到&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgdZex.png&#34; alt=&#34;tgdZex.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道利用率&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgdMfe.png&#34; alt=&#34;tgdMfe.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgd1ld.png&#34; alt=&#34;tgd1ld.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当使用流水线传输时，就要使用&lt;strong&gt;连续 ARQ 协议&lt;/strong&gt;和&lt;strong&gt;滑动窗口协议&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连续 ARQ 协议&lt;/p&gt;
&lt;p&gt;发送窗口，累积确认（对按序到达的最后一个分组发送确认）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tg0jOA.png&#34; alt=&#34;tg0jOA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;对按序到达的最后一个分组发送确认&lt;/strong&gt;，这就表示：到这个分组为止的所有分组都已正确收到了。&lt;/p&gt;
&lt;p&gt;优点：简单易实现；缺点：Go-back-N，即首尾收到，中间报文段丢失，则要重传丢失报文后的所有报文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-tcp-报文段的首部格式&#34;&gt;5. TCP 报文段的首部格式&lt;/h3&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgBmT0.png&#34; alt=&#34;tgBmT0.png&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;​	最小长度是 20 字节，后面有 4n 字节是根据需要而增加的选项 (n 是整数)，最大长度 60 字节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;源端口和目的端口：各占 2 个字节，分别写入源端口号和目的端口号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;序号：4 字节，使用 mod 2^32 运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确认号：4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若确认号＝ N, 则表明：到序号 N-1 为止的所有数据都已正确收到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据偏移：占 4 位，即首部长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保留：占 6 位，保留为今后使用，目前置为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紧急 URG：URG = 1 时，表明紧急指针字段有效，相当于优先级高的数据，要尽快传送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确认 ACK：仅当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。在TCP连接建立后所有传送的报文段都必须把 ACK 置 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推送 PSH：PSH = 1 时，立即收到响应，不必等缓存满了之后再向上交付。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位 RST：RST = 1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。还用来拒绝一个非法的报文段或拒绝打开一个连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步 SYN：在连接建立时用来同步序号，连接请求和连接接受。当 SYN = 1 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 ACK = 1 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止 FIN：用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口：2 字节，指的是发送本报文段的一方的&lt;strong&gt;接收窗口&lt;/strong&gt;（而不是自己的发送窗口)，窗口值作为接收方让发送方设置其发送窗口的依据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检验和：2 字节。检验和字段检验的范围包括首部和数据这两部分，与UDP检验方法相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紧急指针：2 字节。紧急指针仅在 URG = 1 时才有意义，它指向最后一字节的紧急数据。即使窗口为零时也可发送紧急数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项：长度可变，最长可达 40 字节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;最大报文段长度 MSS 选项: TCP数据报数据部分长度。&lt;/li&gt;
&lt;li&gt;时间戳选项：10 字节，其中最主要的字段是时间戳值字段 (4 字节）和时间戳回送回答字段 (4 字节): 用来计算往返时间 RTT，用于处理 TCP 序号超过 2^32 的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-tcp-可靠传输的实现&#34;&gt;6. TCP 可靠传输的实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以字节为单位的滑动窗口&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgsukt.png&#34; alt=&#34;tgsukt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;小于 P1 的是已发送并已收到确认的部分，而大于 P3 的是不允许发送的部分。&lt;/p&gt;
&lt;p&gt;P3 - P1 = A 的发送窗口&lt;/p&gt;
&lt;p&gt;P2 - P1 ＝已发送但尚未收到确认的字节数&lt;/p&gt;
&lt;p&gt;P3 - P2 = 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）&lt;/p&gt;
&lt;p&gt;B 未按序收到，A 从31号重传，B收到后把接收窗口向前移动 3 个序号。A 在继续发送完序号 42 ~ 53 的数据后，指针 P2 向前移动和 P3 重合。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgsv38.png&#34; alt=&#34;tgsv38.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超时重传时间的选择&lt;/p&gt;
&lt;p&gt;每当第一次测量到 RTT 样本时，  RTTs 值就取为所测量到的 RTT 样本 值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次  RTTs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新的 RTTs = (1 - α) x (旧的 RTTs) + α x (新的 RTT 样本)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RTO (超时重传时间) = RTTs + 4 x RTTD (RTT 的偏差的加权平均值)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新的 RTT0 = (1- β) x (旧的 RTTD)＋ β x | RTTs－新的 RTT 样本 |&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择确认 SACK&lt;/p&gt;
&lt;p&gt;首部选项加上允许 SACK 选项。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tg66F1.png&#34; alt=&#34;tg66F1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-tcp-的流量控制&#34;&gt;7. TCP 的流量控制&lt;/h3&gt;
&lt;p&gt;流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用滑动窗口实现流量控制&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tg6bfP.png&#34; alt=&#34;tg6bfP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发送方的发送窗口不能超过接收方给出的接受窗口的数值；&lt;/p&gt;
&lt;p&gt;设置持续计时器来防止窗口由零变为非零导致的僵局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输的效率（三种机制）&lt;/p&gt;
&lt;p&gt;① 维持一个等于MSS的变量来控制缓存。&lt;/p&gt;
&lt;p&gt;② 发送方的推送push操作。&lt;/p&gt;
&lt;p&gt;③ 计时器期限到了就将缓存数据装入报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-tcp-的拥塞控制&#34;&gt;8. TCP 的拥塞控制&lt;/h3&gt;
&lt;p&gt;​	拥塞控制是全局的控制，以网络能够承受现有的网络负荷为前提；流量控制是端口的控制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP 的拥塞控制方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;慢开始和拥塞避免&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送方让自己的发送窗口等于拥塞窗口。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判断网络拥塞的依据就是出现了超时。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;慢开始：以 MSS 作为发送窗口大小的初始值（拥塞窗口)，每经过一个传输轮次（从发送到确认)，cwnd就加倍；慢开始门限作为慢开始和拥塞避免的转换点；&lt;/p&gt;
&lt;p&gt;拥塞避免：每一个RTT，cwnd只加 1, (线性增长，加法增大)；&lt;/p&gt;
&lt;p&gt;出现拥塞时，慢开始门限设置为当前窗口值的一半(乘法减小)，cwnd设为1；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tg2pR0.png&#34; alt=&#34;tg2pR0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tg2nRx.png&#34; alt=&#34;tg2nRx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快重传和快恢复&lt;/p&gt;
&lt;p&gt;快重传：收到三个重复确认立即发送未被确认的报文段；&lt;/p&gt;
&lt;p&gt;快恢复：乘法减小后执行加法增大；&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgRxg0.png&#34; alt=&#34;tgRxg0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP 拥塞控制流程图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgWCbF.png&#34; alt=&#34;tgWCbF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;9-tcp-的运输连接管理&#34;&gt;9. TCP 的运输连接管理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;运输连接有三个阶段，即：连接建立、数据传送和连接释放。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP 连接的建立采用客户服务器方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP 的连接建立&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tgWwVg.png&#34; alt=&#34;tgWwVg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次握手&lt;/p&gt;
&lt;p&gt;客户端向服务端发送连接请求报文段。该报文段的头部中 SYN = 1，ACK = 0，seq = x。请求发送后，客户端便进入***SYN-SENT*** 状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SYN = 1，ACK = 0 表示该报文段为连接请求报文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x 为本次TCP通信的字节流的初始序号。TCP规定：SYN = 1 的报文段不能有数据部分，但要消耗掉一个序号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次握手&lt;/p&gt;
&lt;p&gt;服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN = 1，ACK = 1，seq=y，ack=x+1。该应答发送完成后便进入***SYN-RCVD*** 状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SYN = 1，ACK = 1 表示该报文段为连接同意的应答报文。&lt;/li&gt;
&lt;li&gt;seq = y 表示服务端作为发送者时，发送字节流的初始序号。&lt;/li&gt;
&lt;li&gt;ack = x + 1 表示服务端希望下一个数据报发送序号从x+1开始的字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次握手&lt;/p&gt;
&lt;p&gt;当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：&lt;em&gt;&lt;strong&gt;ACK=1，seq=x+1，ack=y+1&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么连接建立需要三次握手，而不是两次握手？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;背景：A首先发送一个连接请求，但是该请求在网络节点上滞留了，没有收到确认。于是A重传了一次请求，并且收到了B的确认，于是连接建立，数据传输完成后，释放连接。&lt;/p&gt;
&lt;p&gt;① 假定A发出的第一个请求报文段并没有丢失，而是在某些网络节点上滞留，本来是一个失效的请求，但B收到后误认为是A再次发出一个新请求，于是向A发送确认，同意建立连接。&lt;/p&gt;
&lt;p&gt;② 假定采用两次握手，那么只要B发出确认，则新的连接就建立了。由于A并没有发出请求，因此不理会B的确认，也不会向B发送数据，但B却以为新的连接已经建立，并一直等待A的数据，B的许多资源就这样白白浪费了。&lt;/p&gt;
&lt;p&gt;③ 假定采用三次握手，则B发出确认，但A因为并没有发请求，所以不理会B的确认，B没有收到A的确认，则连接建立失败，B知道连接建立失败。会回收资源。&lt;/p&gt;
&lt;p&gt;④ 极端的情况可能由于Client用户端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;TCP 的连接释放&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/07/tg5isx.png&#34; alt=&#34;tg5isx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次挥手&lt;br&gt;
若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN = 1，seq = u。此时，A将进入FIN-WAIT-1状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FIN = 1 表示该报文段是一个连接释放请求。&lt;/li&gt;
&lt;li&gt;seq = u，u - 1 是A向B发送的最后一个字节的序号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次挥手&lt;br&gt;
B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入 CLOSE-WAIT 状态，并向A发送连接释放的应答，其报文头包含：ACK = 1，seq = v，ack = u + 1。A收到该应答，进入 FIN-WAIT-2 状态，等待B发送连接释放请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACK = 1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的 ACK 都为1，表示应答。&lt;/li&gt;
&lt;li&gt;seq = v，v - 1 是B向A发送的最后一个字节的序号。&lt;/li&gt;
&lt;li&gt;ack = u + 1 表示希望收到从第 u+1 个字节开始的报文段，并且已经成功接收了前 u 个字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次挥手&lt;br&gt;
当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN = 1，ACK = 1，seq = w，ack = u+1。B便进入 LAST-ACK 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四次挥手&lt;br&gt;
A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT 状态。该状态会持续 2MSL 时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么挥手是四次，而握手时三次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;握手时 ACK 和 SYN 可以放在一个报文里发送，但是关闭连接时，当收到对方的 FIN 报文，你未必完成所有数据，所以可能发送 ACK 确认收到 FIN，然后发送 FIN 表示关闭连接。&lt;/p&gt;
&lt;/blockquote&gt;
">计算机网络学习笔记（五）--  运输层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/&#34;&gt;计算机网络学习笔记（一）--  计算机网络概述&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/&#34;&gt;计算机网络学习笔记（二）--  物理层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/&#34;&gt;计算机网络学习笔记（三）--  数据链路层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/&#34;&gt;计算机网络学习笔记（五）--  运输层&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-网络层提供的两种服务&#34;&gt;1. 网络层提供的两种服务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;虚电路服务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据报服务&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trd2DO.png&#34; alt=&#34;trd2DO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-网际协议-ip&#34;&gt;2. 网际协议 IP&lt;/h3&gt;
&lt;p&gt;网际协议 IP 是 TCP/IP 体系中两个最重要的协议之一，也是最重要的因特网标准协议之一。与 IP 协议配套是用的四个协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;地址解析协议 ARP&lt;/strong&gt;：是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网际控制报文协议 ICMP&lt;/strong&gt;：提供差错报告和询问报文，以提高 IP 数据交付成功的机会&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网际组管理协议 IGMP&lt;/strong&gt;：用于探寻、转发本局域网内的组成员关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trwlqO.png&#34; alt=&#34;trwlqO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		ARP 画在最下面，因为 IP 经常要使用这个协议。 ICMP、IGMP 画在这一层的上部，因为它们要使用 IP 协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;虚拟互连网络&lt;/p&gt;
&lt;p&gt;因为没有一种单一的网络能够适应所有的用户需求，所以网络互连也变得困难，所以需要一些中间设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层中间设备：&lt;strong&gt;转发器&lt;/strong&gt;(repeater)&lt;/li&gt;
&lt;li&gt;数据链路层中间设备：&lt;strong&gt;网桥或桥接器&lt;/strong&gt;(bridge)&lt;/li&gt;
&lt;li&gt;网络层中间设备：&lt;strong&gt;路由器&lt;/strong&gt;(router)&lt;/li&gt;
&lt;li&gt;网络层以上的中间设备：&lt;strong&gt;网关&lt;/strong&gt;(gateway)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类的 IP 地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP 地址&lt;/strong&gt;就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。由因特网名字与号码指派公司 ICANN 进行分配。&lt;/p&gt;
&lt;p&gt;IP地址编制方法的三个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分类的IP地址&lt;/li&gt;
&lt;li&gt;子网的划分&lt;/li&gt;
&lt;li&gt;构成超网&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IP 地址：：＝｛＜网络号＞，＜主机号＞｝&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个网络号在整个互联网范围内必须是唯一的，主机号在它前面的网络号所指明的网络范围内必须是唯一的。一个 IP 地址在整个互联网范围内是&lt;strong&gt;唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trDisP.png&#34; alt=&#34;trDisP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;A类
&lt;ul&gt;
&lt;li&gt;由1字节的网络地址和3字节主机地址组成。&lt;/li&gt;
&lt;li&gt;网络地址的最高位必须是“0“，可指派的网络数为2^7 - 2，减2的原因是&lt;strong&gt;0.0.0.0对应“本网络”&lt;/strong&gt;，另外一个是&lt;strong&gt;127.0.0.1是本地软件的回环地址&lt;/strong&gt;，用于测试自己电脑IP地址是否可用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址范围 1.0.0.0 到 126.255.255.255&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最大主机数为 2^24 - 2 = 16777214 台，减2的原因是&lt;strong&gt;全0的主机号字段代表该IP地址是&amp;quot;本主机“&lt;/strong&gt;，&lt;strong&gt;全1表示”所有的“&lt;/strong&gt;，表示该网络上的所有主机。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B类
&lt;ul&gt;
&lt;li&gt;由2字节的网络地址和2字节主机地址组成。&lt;/li&gt;
&lt;li&gt;网络地址的最高位必须是“10”，可指派的网络数为 2^14 -1，因为最高位为10，所以不存在全0全1的情况，但是B类网络地址&lt;strong&gt;128.0.0.0是不指派的&lt;/strong&gt;，可指派&lt;strong&gt;最小网络地址是128.1.0.0&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址范围 128.0.0.0 - 191.255.255.255。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最大主机数为2^16 - 2 = 65534台，减2同样是全0全1情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C类
&lt;ul&gt;
&lt;li&gt;由3字节的网络地址和1字节主机地址组成&lt;/li&gt;
&lt;li&gt;网络地址的最高位必须是“110”，可指派的网络数为2^21 - 1，192.0.0.0不指派，&lt;strong&gt;最小可指派网络地址是192.0.1.0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址范围192.0.0.0 - 223.255.255.255&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最大主机数为2^8 - 2 = 254台，减2同样是全0全1情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D类是多播地址，“1110”开始&lt;/li&gt;
&lt;li&gt;E类地址保留为今后使用，“11110”开头&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trsECQ.png&#34; alt=&#34;trsECQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 地址与硬件地址&lt;/p&gt;
&lt;p&gt;物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tryeiD.png&#34; alt=&#34;tryeiD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;IP 地址放在 IP数据报 的首部，而硬件地址放在 MAC帧 的首部。当数据报放入数据链路层的 MAC帧 中后，整个 IP数据报 就成为 MAC帧 的数据，因而在数据链路层看不见数据报的 IP 地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tryfyR.png&#34; alt=&#34;tryfyR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址解析协议 ARP&lt;/p&gt;
&lt;p&gt;ARP是解决&lt;strong&gt;同一个局域网上&lt;/strong&gt;的主机或路由器的 &lt;strong&gt;IP 地址和硬件地址的映射问题&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tr6STf.png&#34; alt=&#34;tr6STf.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每个主机都有一个 &lt;strong&gt;ARP 高速缓存&lt;/strong&gt;，存放映射表。如果一个 IP 地址 到 MAC 地址的映射不在该表中，主机通过广播的方式发送 ARP 请求分组，匹配 IP 地址的主机会发送 &lt;strong&gt;ARP 响应分组&lt;/strong&gt;告知 MAC 地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tr68XR.png&#34; alt=&#34;tr68XR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;A 收到 B 的 ARP响应分组后就在其 ARP 高速缓存中写入 B 主机 IP 地址到硬件地址的映射。同时 B 也会将 A的映射写入到自己的ARP 高速缓存。&lt;/p&gt;
&lt;p&gt;ARP 对保存在高速缓存中的每一个映射地址项目都设置生存时间。凡超过生存时间的项目就从高速缓存中删除掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 数据报的格式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trgpRg.png&#34; alt=&#34;trgpRg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是&lt;strong&gt;最长可为15*4=60字节&lt;/strong&gt;，除去固定部分的长度20字节，可变部分的长度最大为40字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区分服务(服务类型)：占8位，未使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总长度：IP报文的总长度。报头的长度和数据部分的长度之和。占16位，因此数据报的最大长度为2^16-1=65535字节（实际极少遇到）。&lt;/p&gt;
&lt;p&gt;在IP层下面的每一种数据链路层协议都规定了一个数据帧中的数据字段最大长度，这称为最大传送单元MTU。当一个IP数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层规定的MTU值。如：最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行&lt;strong&gt;分片&lt;/strong&gt;处理。&lt;/p&gt;
&lt;p&gt;IP协议规定，在因特网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报。即：假定上层交下来的数据长度有512字节，加上最长的IP首部60字节，再加上4字节的富裕量。否则就要进行分片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容&lt;em&gt;重新组成原先的数据&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标志：共3位。R、DF、MF三位。目前只有后两位有效，DF(don’t fragment)位：为1表示不分片，为0表示分片。MF(more fragment)：为1表示“更多的片”，为0表示这是最后一片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）&lt;/p&gt;
&lt;p&gt;IP数据报分片举例1：一数据报总长度3820字节，其数据部分3800字节长，需要分片为长度不超过1420字节的数据报片。因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1400字节。于是分为3个数据报片，其数据部分的长度分别为1400，1400，1000字节。原始数据报首部被复制为各数据片的首部，但必须修改有关字段的值。分片结果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tr2FpD.png&#34; alt=&#34;tr2FpD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tr2UA0.png&#34; alt=&#34;tr2UA0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首部校验和：&lt;strong&gt;只检验数据报的首部，但不包括数据部分。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tr2O4f.png&#34; alt=&#34;tr2O4f.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源IP地址：标识IP数据报的源端设备。32位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的IP地址：标识IP数据报的目的地址。32位&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 层转发分组的流程&lt;/p&gt;
&lt;p&gt;每一条路由最主要的两个信息：&lt;strong&gt;（目的网络地址，下一跳地址）&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trRUrd.png&#34; alt=&#34;trRUrd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;特定主机路由：可使网络管理人员更方便地控制网络和测试网络。&lt;/li&gt;
&lt;li&gt;默认路由：在一个网络只有很少的对外连接时很有用，可以以减小路由表所占用的空间和搜索路由表所用的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trRXZR.png&#34; alt=&#34;trRXZR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;分组转发算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。&lt;br&gt;
(2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。&lt;br&gt;
(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。&lt;br&gt;
(4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。&lt;br&gt;
(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)&lt;br&gt;
(6) 报告转发分组出错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-划分子网和构造超网&#34;&gt;3. 划分子网和构造超网&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;两级IP地址缺陷&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP 地址空间的利用率有时很低。&lt;/li&gt;
&lt;li&gt;给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。&lt;/li&gt;
&lt;li&gt;两级的 IP 地址不够灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子网划分的基本思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原来的两级 IP 地址在本单位内部就变为三级 IP 地址：&lt;strong&gt;网络号、 子网号和主机号&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IP 地址：：＝｛＜网络号＞，＜子网号＞，＜主机号＞｝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由器在收到IP数据报后，按目标网络号和子网号定位目标子网。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trW7kt.png&#34; alt=&#34;trW7kt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子网掩码&lt;/p&gt;
&lt;p&gt;从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trfEX4.png&#34; alt=&#34;trfEX4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;把 IP 地址的子网掩码和收到的数据报的目的 IP 地址&lt;strong&gt;逐位相与&lt;/strong&gt; (AND) ，得出了所要找的子网的网络地址。&lt;/p&gt;
&lt;p&gt;如果一个网络不划分子网， 那么该网络的子网掩码就使用默认子网掩码。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trfyuQ.png&#34; alt=&#34;trfyuQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;子网数是根据子网号(subnet-id) 计算出来的。若 subnet-id  &lt;em&gt;n&lt;/em&gt; 位，则共有 &lt;em&gt;2^n 种&lt;/em&gt;可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数*(2^ n - 2)*。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trhJ2T.png&#34; alt=&#34;trhJ2T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;同样的 IP 地址和不同的子网掩码可以得出相同的网络地址。但是，不同的掩码的效果是不同的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用子网时分组的转发&lt;/p&gt;
&lt;p&gt;使用子网划分后，路由表必须包含以下三项内容：&lt;strong&gt;目的网络地址、 子网掩码和下一跳地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在划分子网的情况下，路由器转发分组的算法如下：&lt;/p&gt;
&lt;p&gt;(1) 从收到的数据报的首部提取目的 IP 地址 D。&lt;/p&gt;
&lt;p&gt;(2) 先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相”与 “(AND 操作），若匹配，则进行直接交付；否则就是间接交付，执行(3) 。&lt;/p&gt;
&lt;p&gt;(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4) 。&lt;/p&gt;
&lt;p&gt;(4) 对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相”与 “(AND 操作），其结果为 N 。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行(5) 。&lt;/p&gt;
&lt;p&gt;(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否 则，执行(6)&lt;/p&gt;
&lt;p&gt;(6) 报告转发分组出错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无分类编址 CIDR （构造超网）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网络前缀&lt;/p&gt;
&lt;p&gt;CIDR 的记法是无分类的两级编址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IP 地址：：＝｛＜网络前缀＞，＜主机号＞｝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面部分是“网络前缀&amp;quot;（简称 “前缀＂），用来指明网络，后面部分则用来指明主机。&lt;/p&gt;
&lt;p&gt;“斜线记法 ”(slash notation) ，或称为 CIDR 记法，即在 IP 地址后面加上 斜线 &amp;quot;/&amp;quot;，然后写上网络前缀所占的位数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trIvod.png&#34; alt=&#34;trIvod.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;CIDR 使用的地址掩码也可继续称为子网掩码。&lt;strong&gt;斜线记法中，斜线后面的数字就是地址掩码中 1 的个数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络前缀越短，其地址块所包含的地址数就越多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最长前缀匹配&lt;/strong&gt;，即选择两个匹配的地址中更具体的一个。使用二叉线索查找路由表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-网际控制报文协议-icmp&#34;&gt;4. 网际控制报文协议 ICMP&lt;/h3&gt;
&lt;h5 id=&#34;为了更有效地转发ip数据报和提高交付成功的机会在网际层使用了icmpicmp允许主机或路由器报告差错情况和提供有关异常情况的报告&#34;&gt;为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trqsJJ.png&#34; alt=&#34;trqsJJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ICMP报文的种类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ICMP差错报告报文&lt;/li&gt;
&lt;li&gt;ICMP询问报文&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trqIFe.png&#34; alt=&#34;trqIFe.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trqvTS.png&#34; alt=&#34;trqvTS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ICMP 询问报文有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回送请求和回答报文：用来测试目的站是否可达以及了解其有关状态。由主机或路由器向一个特定的目的主机发出的询问。&lt;/li&gt;
&lt;li&gt;时间戳请求和回答报文：用于时钟同步和时间测量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-互联网的路由选择协议&#34;&gt;5. 互联网的路由选择协议&lt;/h3&gt;
&lt;p&gt;**静态路由选择策略（非自适应路由选择）**与  &lt;strong&gt;动态路由选择策略（自适应路由选择）&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分层次的路由选择协议&lt;/p&gt;
&lt;p&gt;把整个互联网划分为许多较小的自治系统，记做 &lt;strong&gt;AS&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内部网关协议 IGP&lt;/strong&gt;：RIP 、OSPF 协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部网关协议 EGP&lt;/strong&gt;：BGP协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/trXvTK.png&#34; alt=&#34;trXvTK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部网关协议 RIP&lt;/p&gt;
&lt;p&gt;​		RIP 是一种分布式的基于距离（也叫&lt;strong&gt;跳数&lt;/strong&gt;）向量的路由选择协议。RIP 允许一条路径最多只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。可见 RIP 只适用于小型 互联网。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅和相邻路由器交换信息。&lt;/li&gt;
&lt;li&gt;路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。&lt;/li&gt;
&lt;li&gt;按固定的时间间隔交换路由信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;距离向量算法&lt;/p&gt;
&lt;p&gt;(1) 对相邻地址 X 发来的 RIP 报文，先将报文中的所有下一跳字段更改为 X，并把跳数都加一。&lt;/p&gt;
&lt;p&gt;(2) 对修改后的每条路由信息做下面的操作：&lt;/p&gt;
&lt;p&gt;​	①若原来的路由表中没有目的网络 N, 则把该项目添加到路由表中；否则执行②；&lt;/p&gt;
&lt;p&gt;​	②若下一跳路由器地址是 X, 则把收到的项目替换原路由表中的项；否则执行③；&lt;/p&gt;
&lt;p&gt;​	③若收到的项目中的距离小于路由表中的距离，则进行更新，否则什么也不做。&lt;/p&gt;
&lt;p&gt;(3) 若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为 16。&lt;/p&gt;
&lt;p&gt;(4) 返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RIP 协议的报文格式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/ts9P1S.png&#34; alt=&#34;ts9P1S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4 + 20 X 25 = 504 字节。如超过，必须再用一个 RIP 报文来传送。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现简单，开销较小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;好消息传得快，坏消息传的慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/ts9W38.png&#34; alt=&#34;ts9W38.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部网关协议 OSPF（开放最短路径优先）&lt;/p&gt;
&lt;p&gt;OSPF最主要的特征就是使用分布式的链路状态协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;洪泛法&lt;/strong&gt;向本自治系统中所有路由器发送信息。&lt;/li&gt;
&lt;li&gt;发送的信息是与本路由器相邻的所有路由器的链路状态。&lt;/li&gt;
&lt;li&gt;只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OSPF 协议报文格式&lt;/p&gt;
&lt;p&gt;OSPF 不用 UDP 而是直接用 IP 数据报传送。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tsiljS.png&#34; alt=&#34;tsiljS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	(1) 版本当前的版本号是 2。&lt;/p&gt;
&lt;p&gt;​	(2) 类型可以是五种类型分组中的一种。&lt;/p&gt;
&lt;p&gt;​	(3) 分组长度 包括 OSPF 首部在内的分组长度，以字节为单位。&lt;/p&gt;
&lt;p&gt;​	(4) 路由器标识符 标志发送该分组的路由器的接口的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OSPF 的五种分组类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;问候(Hello) 分组&lt;/strong&gt;，用来发现和维待邻站的可达性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库描述(Database Description)分组&lt;/strong&gt;，向邻站给出自己的链路状态数据库 中的所有链路状态项目的摘要信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路状态请求(Link State Request)分组&lt;/strong&gt;，向对方请求发送某些链路状态项目的详细信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路状态更新(Link State Update)分组&lt;/strong&gt;，用洪泛法对全网更新链路状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路状态确认(Link State Acknowledgment)分组&lt;/strong&gt;，对链路更新分组的确认。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每两个相邻路由器每隔 10 秒钟要交换一次问候分组。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tsF326.png&#34; alt=&#34;tsF326.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tsFdIA.png&#34; alt=&#34;tsFdIA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;OSPF 还规定每隔一段时间，要刷新一次数据库中的链路状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部网关协议 BGP&lt;/p&gt;
&lt;p&gt;​		边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。 BGP 采用了路径向量路由选择协议，它与距离向量协议（如 RIP) 和链路状态协议（如 OSPF) 都有很大的区别。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tskUyT.png&#34; alt=&#34;tskUyT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。BGP 发言人与其他 AS BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP &lt;strong&gt;会话&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;BGP 的四种报文类型&lt;/p&gt;
&lt;p&gt;(1) OPEN （打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共有 6 个字段，即&lt;em&gt;版本&lt;/em&gt; (1 字节，现在的值是 4) 、&lt;em&gt;本自治系统号&lt;/em&gt; (2 字节， 使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配）、&lt;em&gt;保持时间&lt;/em&gt; (2 字节，以 秒计算的保持为邻站关系的时间）、 &lt;em&gt;BGP 标识符&lt;/em&gt; (4 字节，通常就是该路由器的 IP 地址）、 &lt;em&gt;可选参数长度&lt;/em&gt; (1 字节）和&lt;em&gt;可选参数&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2) UPDATE （更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共有 5 个字段，即&lt;em&gt;不可行路由长度&lt;/em&gt; (2 字节，指明下一个字段的长度）、 &lt;em&gt;撤销的路由&lt;/em&gt;（列出所有要撤销的路由）、&lt;em&gt;路径属性总长度&lt;/em&gt; (2 字节，指明下一个字段的长 度）、&lt;em&gt;路径属性&lt;/em&gt;（定义在这个报文中增加的路径的属性）和&lt;em&gt;网络层可达性信息 NLRI&lt;/em&gt; (Network Layer Reachability Information) 。最后这个字段定义发出此报文的网络，包括网络前缀的位数、 IP 地址前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(3) KEEPALIVE （保活）报文，用来周期性地证实邻站的连通性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有 BGP 19 字节长的通用首部。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(4) NOTIFICATION （通知）报文，用来发送检测到的差错。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 3 个字段，即&lt;em&gt;差错代码&lt;/em&gt; (1 字节）、&lt;em&gt;差错子代码&lt;/em&gt; (1 字节）和&lt;em&gt;差错数据&lt;/em&gt;（给出有关差错的诊断信息）。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/05/tsAIDU.png&#34; alt=&#34;tsAIDU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由器的构成&lt;/p&gt;
&lt;h5 id=&#34;路由器是一种具有多个输入端口和多个输出端口的专用计算机其任务是转发分组&#34;&gt;路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路由器的结构&lt;/p&gt;
&lt;p&gt;由**路由选择部分（控制部分）**和  &lt;strong&gt;分组转发部分&lt;/strong&gt;组成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyG1Og.png&#34; alt=&#34;tyG1Og.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;分组转发部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入端口&lt;/p&gt;
&lt;p&gt;为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中，路由选择处理机负责对各转发表的副本(影子副本)进行更新。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyJKE9.png&#34; alt=&#34;tyJKE9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出端口&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyJ336.png&#34; alt=&#34;tyJ336.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换结构把分组从一个输入端口转移到某个合适的输出端口。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyJw4I.png&#34; alt=&#34;tyJw4I.png&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-ipv6&#34;&gt;6. IPv6&lt;/h3&gt;
&lt;p&gt;IPv6 数据报由两大部分组成，即&lt;strong&gt;基本首部&lt;/strong&gt;和&lt;strong&gt;有效载荷(净负荷)&lt;/strong&gt;。有效载荷允许有零个或多个&lt;strong&gt;扩展首部&lt;/strong&gt;，但扩展首部不属于首部。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IPv6的基本首部&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyJOa9.png&#34; alt=&#34;tyJOa9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyJx8x.png&#34; alt=&#34;tyJx8x.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;：占4位，IPv6 该字段是6.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通信量类&lt;/strong&gt;：8位，区分不同的 IPv6 数据报的类别或优先级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流标号&lt;/strong&gt;：20位，对实时数据有用，对非实时数据无用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有效载荷长度&lt;/strong&gt;：16位，表示除基本首部（包括扩展首部）以外的字节数，最大值是 64 KB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;下一个首部&lt;/strong&gt;：8位，相当千 IPv4 的协议字段或可选字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无扩展首部时，作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（6代表TCP，17代表UDP）。&lt;/li&gt;
&lt;li&gt;有扩展首部时，值标识后面第一个扩展首部的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跳数限制&lt;/strong&gt;：8位，防止数据报在网络中无限期地存在。路由器在转发数据报时，要先把跳数限制字段中的值减1。为零时，就要把这个数据报丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源地址&lt;/strong&gt;：128 位。发送端的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;目的地址&lt;/strong&gt;：128 位。接收端的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv6 的地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;三种目的地址类型：&lt;strong&gt;单播&lt;/strong&gt;，&lt;strong&gt;多播&lt;/strong&gt;，&lt;strong&gt;任播&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个IPv6地址&lt;strong&gt;128位&lt;/strong&gt;，采用&lt;strong&gt;冒号十六进制记法&lt;/strong&gt;。把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。允许把数字前面的 0 省略，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF  把 0000 中的前三个 0 省略了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一连串连续的零可以为一对冒号所取代(零压缩法)，但在一个地址中只能使用一次。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FF05:0:0:0:0:0:0:B3  可记为  FF05: :B3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CIDR 的斜线表示法仍然可用。60 位的前缀 12AB00000000CD3(16进制表示，每个字符代表 4 位二进制数字)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可记为12AB:0000:0000:CD30:0000:0000:0000:0000/60&lt;/p&gt;
&lt;p&gt;​	或12AB::CD30:0:0:0:0/60&lt;/p&gt;
&lt;p&gt;​	或12AB:0:0:CD30::/60&lt;/p&gt;
&lt;p&gt;不可记为12AB:0:0:CD3/60  (最后的0不能省略)&lt;/p&gt;
&lt;p&gt;​	或12AB::CD30/60 （这是地址 12AB:0:0:0:0:0:0:CD30 的前 60 位二进制）&lt;/p&gt;
&lt;p&gt;​	或12AB: :CD3/60 （这是地址 12AB:0:0:0:0:0:0:0CD3 的前 60 位二进制）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyanYj.png&#34; alt=&#34;tyanYj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyal60.png&#34; alt=&#34;tyal60.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4 IPv6 过渡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;双协议栈&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyas0O.png&#34; alt=&#34;tyas0O.png&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隧道技术&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyagtH.png&#34; alt=&#34;tyagtH.png&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ICMPv6&lt;/p&gt;
&lt;p&gt;地址解析协议 ARP 和网际组管理协议 IGMP 的功能都被合并到 ICMPv6。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyaoB8.png&#34; alt=&#34;tyaoB8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyazuV.png&#34; alt=&#34;tyazuV.png&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-ip多播&#34;&gt;7. IP多播&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tydaVS.png&#34; alt=&#34;tydaVS.png&#34; style=&#34;zoom: 67%;&#34; /&gt;
&lt;p&gt;多播数据报和一般的 IP 数据报的区别就是它使用 &lt;strong&gt;D类&lt;/strong&gt; IP 地址作为目的地址，&lt;strong&gt;地址范围是 224.0.0.0 到 239.255.255.255&lt;/strong&gt;，并且首部中的协议字段值是 2, 表明使用网际组管理协议 IGMP。&lt;strong&gt;多播地址只能用于目的地址，而不能用于源地址&lt;/strong&gt;。多播数据报不产生 ICMP 差错报文。&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tywKs0.png&#34; alt=&#34;tywKs0.png&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 多播需要两种协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网际组管理协议 IGMP&lt;/strong&gt; 和 &lt;strong&gt;多播路由选择协议&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IGMP&lt;/p&gt;
&lt;p&gt;IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出了某个多播组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多播路由选择协议&lt;/p&gt;
&lt;p&gt;把多播数据报用最小代价传送给所有的组成员。&lt;/p&gt;
&lt;p&gt;三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;洪泛与剪除。&lt;/li&gt;
&lt;li&gt;隧道技术。&lt;/li&gt;
&lt;li&gt;基于核心的发现技术。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-虚拟专用网-vpn-和网络地址转换-nat&#34;&gt;8. 虚拟专用网 VPN 和网络地址转换 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;虚拟专用网 VPN&lt;/p&gt;
&lt;p&gt;仅在本机构有效的 IP 地址称为本地地址，全球唯一的 IP 地址称为全球地址。&lt;strong&gt;专用地址&lt;/strong&gt;(&lt;strong&gt;可重用地址&lt;/strong&gt;)只能用做本地地址不能用作全球地址。&lt;strong&gt;在互联网中的所有路由器，对目的地址是专用地址的数据报一 律不进行转发。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyBOaT.png&#34; alt=&#34;tyBOaT.png&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;A、B内部的通信量都不经过互联网，X 和 Y 通信时，X将报文交付给R1，经R1加密后，重新加上数据报首部，此时源地址变为R1，目的地址变为R2。R2收到后进行解密，发现目的地址是Y，将报文交付给Y。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络地址转换 NAT&lt;/p&gt;
&lt;p&gt;解决的问题就是专用网内部的一些主机本来已经分配到了本地 IP 地址 （即仅在本专用网内使用的专用地址），但现在又想和互联网上的主机通信。&lt;/p&gt;
&lt;p&gt;方法：安装NET路由器，它至少有一个有效的外部全球 IP 地址，NAT 路由器上将其本地地址转换成全球 IP 地址就能实现本地地址和全球地址通信了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyrUhD.png&#34; alt=&#34;tyrUhD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过 NAT 地址转换表将旧的目的 IP 地址, 转换为新的目的 IP 地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/06/tyssxJ.png&#34; alt=&#34;tyssxJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
">计算机网络学习笔记（四）--  网络层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/&#34;&gt;计算机网络学习笔记（一）--  计算机网络概述&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/&#34;&gt;计算机网络学习笔记（二）--  物理层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/&#34;&gt;计算机网络学习笔记（四）--  网络层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/&#34;&gt;计算机网络学习笔记（五）--  运输层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据链路层使用的信道有两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点对点信道&lt;/li&gt;
&lt;li&gt;广播信道&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;1-使用点对点信道的数据链路层&#34;&gt;1. 使用点对点信道的数据链路层&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据链路和帧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路&lt;/strong&gt; ：从一个结点到相邻结点的一段物理线路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据链路&lt;/strong&gt; ：把实现这些协议的硬件和软件加载链路上。&lt;br&gt;
现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;帧&lt;/strong&gt;：点对点信道的数据链路层的协议数据单元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t05kPf.png&#34; alt=&#34;t05kPf.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;点对点信道通信时的主要步骤&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。&lt;/li&gt;
&lt;li&gt;结点 A 把封装好的帧发送给结点 B 的数据链路层。&lt;/li&gt;
&lt;li&gt;若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据链路层三个基本问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;封装成帧&lt;/p&gt;
&lt;p&gt;就是在一段数据的前后分别&lt;strong&gt;添加首部&lt;/strong&gt;（帧开始符 SOH 01）和&lt;strong&gt;尾部&lt;/strong&gt;（帧结束符 EOT 04），然后就构成了一个&lt;strong&gt;帧&lt;/strong&gt;。（数据部分 &amp;lt;= 长度限制 MTU）首部和尾部的一个重要作用就是进行帧定界。&lt;br&gt;
&lt;strong&gt;帧定界是分组交换的必然要求&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0IK6e.png&#34; alt=&#34;t0IK6e.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0IJtP.png&#34; alt=&#34;t0IJtP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;透明传输&lt;/p&gt;
&lt;p&gt;为了达到透明传输（即传输的数据部分不会因为包含SOH和EOT而出错），在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制1B)&lt;br&gt;
&lt;strong&gt;透明传输避免消息符号与帧定界符号相混淆&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0IxHA.png&#34; alt=&#34;t0IxHA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;差错检测&lt;/p&gt;
&lt;p&gt;现实通信链路中比特在传输中会产生差错，传输错误的比特占比称为&lt;strong&gt;误码率BER&lt;/strong&gt;，为了保证可靠性，通常通过&lt;strong&gt;循环冗余检验CRC&lt;/strong&gt;来做差错检测。&lt;br&gt;
&lt;strong&gt;差错检测防止无效数据帧浪费后续路由上的传输和处理资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环冗余检验CRC&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;​		在发送端将数据分组，每组 &lt;em&gt;k&lt;/em&gt; bit，在待传送数据 &lt;em&gt;M&lt;/em&gt; (&lt;em&gt;k&lt;/em&gt; bit) 后添加 &lt;em&gt;n&lt;/em&gt; 位冗余码，构成一个帧发送出去，因此一共发送 &lt;em&gt;k+n&lt;/em&gt; bit。&lt;/p&gt;
&lt;p&gt;​		利用&lt;strong&gt;模二运算&lt;/strong&gt;（不进位，不借位）计算 &lt;em&gt;2^n x M / P&lt;/em&gt;, 即在待传送数据 &lt;em&gt;M&lt;/em&gt; 后加 n 个0作为被除数，除以商定好的除数 &lt;em&gt;P&lt;/em&gt;（比 n 多一位），得到的&lt;/p&gt;
&lt;p&gt;余数 &lt;em&gt;R&lt;/em&gt; （比 &lt;em&gt;n&lt;/em&gt; 少一位）即为冗余码，将其拼接到数据 &lt;em&gt;M&lt;/em&gt; 后发送出去。为了进行检错而添加的冗余码常称为帧检验序列 &lt;em&gt;FCS&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		在接收端把接收到的数据以帧为单位进行 CRC 检验：把收到的每一个帧都除以同样的 除数 &lt;em&gt;P&lt;/em&gt;（模二运算），然后检查得到的余数 &lt;em&gt;R&lt;/em&gt; 如果在传输过程中&lt;strong&gt;无差错，那么经过 CRC 检验后得出的余数肯定是0&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		若 &lt;em&gt;M&lt;/em&gt; = 101001(即&lt;em&gt;k&lt;/em&gt; = 6)，除数 &lt;em&gt;P&lt;/em&gt; = 1101, 还可表示为 &lt;em&gt;P(X) = X^3 + X^2 + 1&lt;/em&gt;，此时被除数 &lt;em&gt;2^n x M&lt;/em&gt; 为101001000除以 &lt;em&gt;P&lt;/em&gt; 的余数 &lt;em&gt;R&lt;/em&gt; 为001。因此加上 &lt;em&gt;FCS&lt;/em&gt; 后发送的帧是 101001001。接收端被除数即为 101001001，除以除数 &lt;em&gt;P&lt;/em&gt; 得到余数 &lt;em&gt;R&lt;/em&gt;。若 &lt;em&gt;R&lt;/em&gt; = 0，帧无错，接受；若 &lt;em&gt;R&lt;/em&gt; ≠ 0，帧出错(无法判断哪一位出错)，丢弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数据链 路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于通信质量良好的有线传输链路，不要求数据链路层向上提供可靠传输的服务。改正差错的任务就由上层协议（例如，运输层的 TCP 协议）来完成。 对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-点对点协议-ppp&#34;&gt;2. 点对点协议 PPP&lt;/h3&gt;
&lt;h5 id=&#34;ppp-协议就是用户-计算机和-isp-进行通信时所使用的数据链路层协议&#34;&gt;PPP 协议就是用户 计算机和 ISP 进行通信时所使用的数据链路层协议。&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBaXtI.png&#34; alt=&#34;tBaXtI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;!-- more --&gt;
&lt;p&gt;在 TCP/IP 协议族中，可靠传输由运输层的 TCP 协议负责，因此数据链路层的 PPP 议不需要进行纠错，不需要设置序号，也不需要进行流量控制。 PPP 协议不支待多点线路 （即一个主站轮流和链路上的多个从站进行通信），而&lt;strong&gt;只支持点对点的链路通信&lt;/strong&gt;。此外， PPP 协议&lt;strong&gt;只支持全双工链路&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PPP 协议的组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个将 IP 数据报封装到串行链路的方法。&lt;/li&gt;
&lt;li&gt;链路控制协议 LCP (Link Control Protocol)，用来建立、测试、配置数据链路连接。&lt;/li&gt;
&lt;li&gt;网络控制协议 NCP (Network Control Protocol)，用来支持不同的网络层协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PPP 协议帧格式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBPn9U.png&#34; alt=&#34;tBPn9U.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;若出现连续两个标志字段，就表示这是一个空帧，应当丢弃。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的)。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的开始或结束。&lt;/li&gt;
&lt;li&gt;首部中的地址字段A规定为0xFF(即11111111)，没有携带PPP协议帧的信息。&lt;/li&gt;
&lt;li&gt;首部中的控制字段C规定为0x03(即00000011)，没有携带PPP协议帧的信息。&lt;/li&gt;
&lt;li&gt;首部中的2字节的协议字段：&lt;br&gt;
(1) 当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。&lt;br&gt;
(2) 当协议字段为0xC021时，PPP帧的信息字段就是PPP链路控制协议LCP的数据。&lt;br&gt;
(3) 当协议字段为0x8021时，PPP帧的信息字段就是网络层的控制数据。&lt;/li&gt;
&lt;li&gt;信息部分不超过1500字节。&lt;/li&gt;
&lt;li&gt;尾部中的第一个字段(2个字节)是使用CRC的帧检验序列FCS。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;透明传输的实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字节填充——PPP使用异步传输&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 PPP 用在异步传输时，就使用一种特殊的字符填充法：将每一个 0x7E字节变为(0x7D, 0x5E)，0x7D转变成为(0x7D, 0x5D)。ASCII 码的控制字符（即数值小于 0x20 的字符），则在前面要加入0x7D，同时将该字符的编码加以改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;零比特填充——PPP使用同步传输&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要发现有5个连续的1，则立即填入一个0。接收端把5个连续的1后的0比特删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PPP 协议工作状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路静止  --  建立物理层  --  链路建立  --  PC发LCP  --  NCP分配IP地址  --  链路打开，网络层建立。（释放时倒过来）&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBFzh6.png&#34; alt=&#34;tBFzh6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-使用广播信道的数据链路层&#34;&gt;3. 使用广播信道的数据链路层&lt;/h3&gt;
&lt;h5 id=&#34;广播信道可以进行一对多的通信局域网具有广播功能局域网上的主机可共享连接在局-域网上的各种硬件和软件资源&#34;&gt;广播信道可以进行一对多的通信，局域网具有广播功能，局域网上的主机可共享连接在局 域网上的各种硬件和软件资源。&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;局域网的数据链路层（局域网的数据链路层被拆分为了两个子层）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逻辑链路控制LLC子层&lt;/strong&gt;：与传输媒体无关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;媒体接入控制MAC子层&lt;/strong&gt;：与接入到传输媒体有关的内容都放在 MAC 子层，和局域网都对 LLC 子层来说是透明的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适配器（网卡）的作用&lt;/p&gt;
&lt;p&gt;包含了***数据链路层***及***物理层***这两个层次的功能。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBAyLQ.png&#34; alt=&#34;tBAyLQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CSMA/CD 协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仅当数据帧中的目的地址与适配器 ROM 中存放的硬件地址(MAC 地址)一致时，该适配器才能接收这个数据帧。适配器对不是发送给自己的数据帧就丢弃。&lt;/p&gt;
&lt;p&gt;以太网采用 CSMA/CD协议(&lt;em&gt;&lt;strong&gt;载波监听多点接入／碰撞检测&lt;/strong&gt;&lt;/em&gt;) 的方式来协调总线上各计算机的工作。具有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供的服务是尽最大努力的交付，即不可靠的交付。&lt;/li&gt;
&lt;li&gt;双向交替通信（半双工）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;csmacd协议的要点&#34;&gt;CSMA/CD协议的要点：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多点接入&lt;/strong&gt;就是计算机以多点接入（动态媒体接入控制）的方式连接在一根总线上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;载波监听&lt;/strong&gt;就是”检测信道”，不管在发送前，还是在发送中，每个站都必须不停地检测信道。在发送前检测信道，是为了获得发送权。在发送中检测信道，是为了及时发现有 没有其他站的发送和本站发送的碰撞。即碰撞检测。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;碰撞检测&lt;/strong&gt;就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把总线上的单程端到端传播时延记为 &lt;em&gt;τ&lt;/em&gt; ，A 发送数据后，最迟要经过 &lt;em&gt;2τ&lt;/em&gt; 才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBZtZ4.png&#34; alt=&#34;tBZtZ4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;电磁波在 1km 电缆的传播时延约为 &lt;em&gt;5µs&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;以太网的端到端往返时间 &lt;em&gt;2τ&lt;/em&gt; 称为&lt;em&gt;&lt;strong&gt;争用期***，又叫&lt;/strong&gt;碰撞窗口&lt;/em&gt;* 。&lt;strong&gt;经过争用期这 段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以太网使用&lt;strong&gt;截断二进制指数退避算法&lt;/strong&gt;来确定碰撞后&lt;strong&gt;重传&lt;/strong&gt;的时机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;协议规定了基本退避时间为争用期 &lt;em&gt;2τ&lt;/em&gt;, 具体的争用期时间是 &lt;em&gt;&lt;strong&gt;51.2 µs&lt;/strong&gt;&lt;/em&gt; 。对于 10 Mbit/s 以太网，在争用期内可发送 512 bit, 即 64字节。也可以说争用期是 512 比特时间。可以直接使用&lt;strong&gt;比特&lt;/strong&gt;作为争用期的单位。争用期是 512bit, 即争用期是发送 512bit 所需的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 &lt;em&gt;[0,1, …，（2k -1)]&lt;/em&gt; 中随机取出一个数，记为 &lt;em&gt;r&lt;/em&gt; 。重传应推后的时间就是 &lt;em&gt;&lt;strong&gt;r 倍的争用期&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;k=Min［重传次数， 10]&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当重传达 16 次仍不能成功时（这表明同时打算发送数据的站太多，以致连续发生冲突），则丢弃该帧，并向高层报告。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最短帧长 64 字节，即 512 bit 。如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于 64 字节。&lt;strong&gt;凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧&lt;/strong&gt;。只要收到了这种无效帧，就应当立即将其丢弃。&lt;/p&gt;
&lt;h5 id=&#34;强化碰撞&#34;&gt;强化碰撞：&lt;/h5&gt;
&lt;p&gt;​		当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的&lt;em&gt;人为干扰信号&lt;/em&gt;，以便让所有用户都知道现在已经发生了碰撞。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBnhWR.png&#34; alt=&#34;tBnhWR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		总线被占用的时间是 &lt;em&gt;TB+ TJ + τ&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规定帧间最小间隔为 9.6 µs&lt;/strong&gt;, 相当于 96 比特时间。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。&lt;/p&gt;
&lt;h5 id=&#34;总结&#34;&gt;总结：&lt;/h5&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBuw7D.md.png&#34; alt=&#34;tBuw7D.png&#34; border=&#34;0&#34; /&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;以太网的信道利用率&#34;&gt;以太网的信道利用率&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;a&lt;/em&gt; 是以太网单程端到端时延 &lt;em&gt;2τ&lt;/em&gt; 与帧的发送时间 &lt;em&gt;To&lt;/em&gt; 之比：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBMVs0.png&#34; alt=&#34;tBMVs0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当 a -&amp;gt; 0 时表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数 &lt;em&gt;a&lt;/em&gt; 越大，表明争用期所占的比例越大，使得信道利用率明显降低。当数据率一定时，以太网的连线的长度受到限制（否则 &lt;em&gt;τ&lt;/em&gt; 的数值 会太大），同时以太网的帧长不能太短（否则 &lt;em&gt;τ&lt;/em&gt; 的值会太小，使 &lt;em&gt;To&lt;/em&gt; 值太大）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBQccR.png&#34; alt=&#34;tBQccR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;只有当参数 &lt;em&gt;a&lt;/em&gt; 远小于 1 才能得到尽可能高的极限信道利用率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-以太网的mac层&#34;&gt;4. 以太网的MAC层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MAC地址&lt;br&gt;
&lt;strong&gt;MAC地址&lt;/strong&gt;又叫做硬件地址或物理地址，实际上就是适配器地址或适配器标识符EUI-48。高位24位：注册管理机构 RA，组织唯一标识符 OUI，低位24位：由厂家自行指派，称为扩展标识符。&lt;/p&gt;
&lt;p&gt;路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MAC帧的格式&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBGEQJ.png&#34; alt=&#34;tBGEQJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;以太网V2的MAC帧由五个字段组成。前两个字段分别为6字长的目标地址和源地址字段。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。后面数据字段46~1500字节，帧检验序列FCS字段4个字节（使用 CRC 检验）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接收方可以很容易地通过发送方网络适配器的接口上的电压是否变化找到以太网帧的结束位置&lt;/em&gt;。在这个位置往前数 4 字节 (FCS 字段长度是 4 字节），就能确定数据字段的结束位置。因此MAC帧首部中不需要帧长度字段。&lt;/p&gt;
&lt;p&gt;当数据字段的长度小千 46 字节时， MAC 子层就会在数据字段的后面加入一个整数字节的&lt;em&gt;填充字段&lt;/em&gt;，以保证以太网的 MAC 帧长不小于 64 字节。&lt;/p&gt;
&lt;p&gt;为了接收端迅速实现位同步，从 MAC 子层向下传到物理层时还要在帧的前面插入8字节（由硬件生成），它由两个字段构成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个字段是 个字节的前同步码 (1 交替码），它的作用是“实现位同步”（比特同步）。&lt;/li&gt;
&lt;li&gt;第二个字段是帧开始定界符，定义为 10101011 。它的前六位的作用和前同步码一样，最后的两个连续1的就是告诉接收端适配器： “MAC 帧的信息马上就要来了，请适配器注意接收&#39;。MAC 帧的 FCS 字段的检验范围不包括前同步码和帧开始定界符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无效的 MAC 帧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帧的长度不是整数个字节；&lt;/li&gt;
&lt;li&gt;用收到的帧检验序列 FCS 查出有差错；&lt;/li&gt;
&lt;li&gt;收到的帧的 MAC 客户数据字段的长度不在 46 ~ 1500 字节之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-扩展的以太网&#34;&gt;5. 扩展的以太网&lt;/h3&gt;
&lt;h5 id=&#34;扩展的以太网在网络层看来仍然是一个网络&#34;&gt;扩展的以太网在网络层看来仍然是一个网络。&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在物理层扩展以太网&lt;/p&gt;
&lt;p&gt;扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光纤）和一对光纤调制解调器。&lt;/p&gt;
&lt;p&gt;光纤调制解调器的作用就是进行&lt;em&gt;电信号和光信号的转换&lt;/em&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBYkr9.png&#34; alt=&#34;tBYkr9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨网络通信。&lt;/li&gt;
&lt;li&gt;扩大了以太网覆盖的地理范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩大了碰撞域。&lt;/li&gt;
&lt;li&gt;不同的局域网使用不同的以太网技术（如数据率不同），那么就不可能用集线器将它们互连起来（速率向下兼容）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据链路层扩展以太网&lt;/p&gt;
&lt;h5 id=&#34;网桥自学习算法&#34;&gt;网桥（自学习算法）&lt;/h5&gt;
&lt;h5 id=&#34;以太网交换机第二层交换机-即多接口网桥强调这种交换机工作在数据链路层&#34;&gt;以太网交换机（第二层交换机 ），即多接口网桥，强调这种交换机工作在数据链路层。&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全双工方式通信。&lt;/li&gt;
&lt;li&gt;并行。&lt;/li&gt;
&lt;li&gt;相互通信的主机都是独占传输媒体，无碰撞地传输数据。&lt;/li&gt;
&lt;li&gt;接口还有存储器，能在输出端口繁忙时把到来的帧进行缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自学习功能&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBt5p8.png&#34; alt=&#34;tBt5p8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​		A 先向 B 发送一帧，从接口 1 进入到交换机。交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧（在 MAC 地址这一列中，找不到目的地址为 B 的项目）。然后，交换机把这个帧的源地址 A 和接口 1 写入交换表中并向除接口,以外的所有接口广播这个帧。C 和 D 丢弃该帧，因为目的地址不对。只有 B 才收下这个目的地址正确的帧。此即为&lt;strong&gt;过滤&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​		以后不管从哪一个接口收到帧，只要其目的地 址是 A, 就应当把收到的帧从接口 1 转发出去。&lt;/p&gt;
&lt;p&gt;​		B 向 A 发送帧时，交换机把这个帧的源地址 B 和接口 3 写入交换表中，此时不再广播，因为交换表中已经存在 A 的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟局域网VLAN&lt;/p&gt;
&lt;p&gt;每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN，而与物理位置无关。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBUZan.png&#34; alt=&#34;tBUZan.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;VLAN 标记的前两个字节总是设置为 0x8100 （即二进制的 10000001 00000000) ，称为 IEEE 802.1Q 标记类型。&lt;/p&gt;
&lt;p&gt;VLAN 标识符 VID(VLANID) ，它唯一地标志了这个以太网帧属于哪一个 VLAN。&lt;/p&gt;
&lt;p&gt;由于用于 VLAN 的以太网帧的首部增加了 4 个字节，因此以太网的最大帧长从原来的 1518 字节 (1500 字节的数据加上 18 字节的首部）变为 1522 字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-高速以太网&#34;&gt;6. 高速以太网&lt;/h3&gt;
&lt;p&gt;此部分转载自CSDN，&lt;a href=&#34;%5Bhttps://blog.csdn.net/KnightOnHourse/article/details/80198611?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159127115919725219954270%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;amp;request_id=159127115919725219954270&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-80198611.ecpm_v1_rank_ctr_v1&amp;amp;utm_term=%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91%5D(https://blog.csdn.net/KnightOnHourse/article/details/80198611?ops_request_misc=%7B%22request%5Fid%22%3A%22159127115919725219954270%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;amp;request_id=159127115919725219954270&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-80198611.ecpm_v1_rank_ctr_v1&amp;amp;utm_term=%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91)&#34;&gt;原文地址&lt;/a&gt;（如侵删）&lt;/p&gt;
&lt;div class=&#34;htmledit_views prism-atom-one-light&#34; id=&#34;content_views&#34;&gt;
                                            &lt;div class=&#34;blogpost-body&#34;&gt;&lt;p&gt;&lt;strong&gt;1. 100M以太网&lt;/strong&gt;&lt;/p&gt;&lt;p align=&#34;center&#34;&gt;快速以太网（100M）标准&lt;/p&gt;&lt;div align=&#34;center&#34;&gt;&lt;div class=&#34;table-box&#34;&gt;&lt;table border=&#34;1&#34; cellpadding=&#34;0&#34; cellspacing=&#34;0&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;名称&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;传输介质&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;网段最大长度&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;center&#34;&gt;特点&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;100BASE-TX&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;铜缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;100m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;两对UTP5类线或屏蔽双绞线&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;100BASE-T4&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;铜缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;100m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;四对UTP3类线或5类线&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;100BASE-FX&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;光纤&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;2000m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;两根光纤，发送和接收各用一根，全双工，长距离&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;（1）100BASE-T是在双绞线上传送100Mb/s基带信号的星型拓扑的以太网，仍使用IEEE802.3的CSMA/CD协议，它又称为快速以太网（FastEthernet）&lt;/p&gt;&lt;p&gt;（2）使用交换机组建的100BASE-T以太网，可在全双工方式下工作而无冲突发生。因此，&lt;span style=&#34;color:#ff00ff;&#34;&gt;&lt;strong&gt;CSMA/CD协议对全双工方式工作的快速以太网是不起作用的&lt;/strong&gt;&lt;/span&gt;。&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;因为其帧格式和以太网一样&lt;/strong&gt;&lt;/span&gt;，所以依然称&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;交换机组成的网络为以太网&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;（3）以太网的最短帧与带宽和链路长度有关。&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;100M以太网&lt;/strong&gt;&lt;/span&gt;比10M以太网速率提高10位，要想和10M以太网兼容，就要确保最短帧也是64字节，那就将电缆最大长度由1000m降到&lt;span style=&#34;color:#0000ff;&#34;&gt;&lt;strong&gt;100m&lt;/strong&gt;&lt;/span&gt;，因此以太网的争用期依然是51.2μs，最短帧依然是64字节。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 吉比特以太网&lt;/strong&gt;&lt;/p&gt;&lt;p align=&#34;center&#34;&gt;吉比特以太网（1000M）标准&lt;/p&gt;&lt;div align=&#34;center&#34;&gt;&lt;div class=&#34;table-box&#34;&gt;&lt;table border=&#34;1&#34; cellpadding=&#34;0&#34; cellspacing=&#34;0&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;名称&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;传输介质&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;网段最大长度&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;center&#34;&gt;特点&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;1000BASE-SX&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;光缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;550m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;多模光纤（10和62.5μm）&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;1000BASE-LX&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;光缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;5000m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;单模光纤（10μm）、多模光纤（50和62.5μm）&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;1000BASE-CX&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;铜线&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;25m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;使用两对屏蔽双绞线电缆STP&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;95&#34;&gt;&lt;p align=&#34;center&#34;&gt;1000BASE-T&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;铜线&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;130&#34;&gt;&lt;p align=&#34;center&#34;&gt;100m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;360&#34;&gt;&lt;p align=&#34;left&#34;&gt;使用四对UTP5类线&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;（1）吉比特（1000M）以太网的特点&lt;/p&gt;&lt;p&gt;　　①允许在1Gb/s下&lt;span style=&#34;color:#0000ff;&#34;&gt;&lt;strong&gt;全双工和半双工&lt;/strong&gt;&lt;/span&gt;两种方式下工作。&lt;/p&gt;&lt;p&gt;　　②使用IEEE802.3协议规定的帧格式&lt;/p&gt;&lt;p&gt;　　③在&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;半双工方式下使用CSMA/CD协议&lt;/strong&gt;（&lt;strong&gt;全双工方式不需要使用CSMA/CD协议&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　④与10BASE-T和100BASE-T技术向后兼容。&lt;/p&gt;&lt;p&gt;（2）“载波延伸”&lt;/p&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBw2J1.png&#34; alt=&#34;&#34; height=&#34;235&#34; width=&#34;658&#34;&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;　　①吉比特以太网工作&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;在半双工时&lt;/strong&gt;&lt;/span&gt;，就必须进行碰撞检测。数据速率提高了，要想和10M以太网兼容，就要确保最短帧也是64字节，这只能减少最大电缆长度，&lt;span style=&#34;color:#0000ff;&#34;&gt;&lt;strong&gt;以太网最大电缆就要缩短到10m&lt;/strong&gt;&lt;/span&gt;，短到几乎没有实用价值。&lt;/p&gt;&lt;p&gt;　　②吉比特以太网&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;为了增加最大传输距离&lt;/strong&gt;，&lt;strong&gt;将最短帧由64字节增加到512字节&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;　　③如果数据帧不超过512字节，则在&lt;span style=&#34;color:#ff00ff;&#34;&gt;&lt;strong&gt;FCS域后面添加“载波延伸”域&lt;/strong&gt;&lt;/span&gt;，当主机发送完短数据帧后，继续发送载波延伸信号，冲突信号传回来时，发送端就能感知到了。&lt;/p&gt;&lt;p&gt;（3）分组突发&lt;/p&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tBw4sO.png&#34; alt=&#34;&#34; height=&#34;251&#34; width=&#34;756&#34;&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;　　①如果发送的数据帧都是小于64字节的&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;短报文&lt;/strong&gt;&lt;/span&gt;时，那么&lt;span style=&#34;color:#ff00ff;&#34;&gt;&lt;strong&gt;链路的利用率就会很低&lt;/strong&gt;&lt;/span&gt;，因为“载波延伸”域占用了大量的带宽。于是，千兆以太网引入了“分组突发”机制来改善这个问题。&lt;/p&gt;&lt;p&gt;　　②当很多短帧要发送时，&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;strong&gt;第一个短帧采用“载波延伸”方法进行填充&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;&lt;span style=&#34;color:#0000ff;&#34;&gt;后面的一些短帧可以一个接一个发送&lt;/span&gt;，&lt;span style=&#34;color:#ff0000;&#34;&gt;它们之间只要留必要的帧间最小间隔即可&lt;/span&gt;&lt;/strong&gt;。这样就形成一串分组突发，直到达到1500字节或稍多一些为止。从而提高链路的利用率。&lt;/p&gt;&lt;p&gt;　　③“载波延伸”和“分组突发”&lt;span style=&#34;color:#0000ff;&#34;&gt;&lt;strong&gt;仅用于千兆以太网的半双工模式&lt;/strong&gt;&lt;/span&gt;；而全双工模式不需要使用CSMA/CD协议，也就不需要这两个特性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 10吉比特以太网&lt;/strong&gt;&lt;/p&gt;&lt;p align=&#34;center&#34;&gt;万兆以太网标准&lt;/p&gt;&lt;div align=&#34;center&#34;&gt;&lt;div class=&#34;table-box&#34;&gt;&lt;table border=&#34;1&#34; cellpadding=&#34;0&#34; cellspacing=&#34;0&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;101&#34;&gt;&lt;p align=&#34;center&#34;&gt;名称&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;传输介质&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;129&#34;&gt;&lt;p align=&#34;center&#34;&gt;网段最大长度&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;220&#34;&gt;&lt;p align=&#34;center&#34;&gt;特点&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;101&#34;&gt;&lt;p align=&#34;center&#34;&gt;10GBASE-SR&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;光缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;129&#34;&gt;&lt;p align=&#34;center&#34;&gt;300m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;220&#34;&gt;&lt;p align=&#34;left&#34;&gt;多模光纤（0.85μm）&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;101&#34;&gt;&lt;p align=&#34;center&#34;&gt;10GBASE-LR&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;光缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;129&#34;&gt;&lt;p align=&#34;center&#34;&gt;10km&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;220&#34;&gt;&lt;p align=&#34;left&#34;&gt;单模光纤（1.3μm）&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;101&#34;&gt;&lt;p align=&#34;center&#34;&gt;10GBASE-ER&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;光缆&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;129&#34;&gt;&lt;p align=&#34;center&#34;&gt;40m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;220&#34;&gt;&lt;p align=&#34;left&#34;&gt;单模光纤（1.3μm）&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;101&#34;&gt;&lt;p&gt;10GBASE-CX4&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;铜线&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;129&#34;&gt;&lt;p align=&#34;center&#34;&gt;15m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;220&#34;&gt;&lt;p align=&#34;left&#34;&gt;使用四对双芯同轴电缆&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&#34;top&#34; width=&#34;101&#34;&gt;&lt;p align=&#34;center&#34;&gt;10GBASE-T&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;81&#34;&gt;&lt;p align=&#34;center&#34;&gt;铜线&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;129&#34;&gt;&lt;p align=&#34;center&#34;&gt;100m&lt;/p&gt;&lt;/td&gt;&lt;td valign=&#34;top&#34; width=&#34;220&#34;&gt;&lt;p align=&#34;left&#34;&gt;使用4对6A类的UTP双绞线&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;（1）10GE的帧格式与10Mb/s、100Mb/s和1Gb/s以太网的帧格式完全相同。10GE还保留了802.3标准规定的了以太网最小和最长帧长。&lt;/p&gt;&lt;p&gt;（2）由于数据率很高，10GE不再使用铜线而只使用光纤作为传输媒体。它使用长距离（40km）的光收发器与单模光纤接口，以便能够工作在广域网和城域网的范围。&lt;/p&gt;&lt;p&gt;（3）10GE只工作在全双工模式，因此不存在争用问题，也不使用CSMA/CD协议。这就使用10GE的传输距离不再受碰撞检测的限制而大大提高了&lt;/p&gt;&lt;/div&gt;                                    &lt;/div&gt;">计算机网络学习笔记（三）--  数据链路层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/&#34;&gt;计算机网络学习笔记（一）--  计算机网络概述&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/&#34;&gt;计算机网络学习笔记（三）--  数据链路层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/&#34;&gt;计算机网络学习笔记（四）--  网络层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/&#34;&gt;计算机网络学习笔记（五）--  运输层&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-物理层特性&#34;&gt;1. 物理层特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机械特性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;电气特性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能特性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规程特性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;2-数据通信基础知识&#34;&gt;2. 数据通信基础知识&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;数据通信系统模型&#34;&gt;数据通信系统模型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据通信系统三部分：&lt;strong&gt;源系统(发送端)、传输系统、目的系统(接收端)&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twjDlq.png&#34; alt=&#34;twjDlq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模拟信号&lt;/strong&gt;：连续信号，表示消息的参数取值是连续的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数字信号&lt;/strong&gt;：离散信号，表示消息的参数取值是离散的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;信道&#34;&gt;信道&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;按照通信双方信息交互的方式分为：&lt;strong&gt;单工通信&lt;/strong&gt;、&lt;strong&gt;半双工通信&lt;/strong&gt;、&lt;strong&gt;全双工通信&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;曼切斯特编码产生的信号频率比不归零制高。不归零制没有自同步能力，曼切斯特编码具有自同步能力。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;基带信号：来自信源的信号.计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。包含有较多低频成分，需要进行调制。&lt;br&gt;
调制分为：
&lt;ul&gt;
&lt;li&gt;基带调制：对基带信号波形进行变换，仍然是基带信号&lt;/li&gt;
&lt;li&gt;带通调制：经过载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号。基本的带通调制方法有：&lt;/li&gt;
&lt;li&gt;调幅AM：载波的振幅随基带数字信号而变化。&lt;/li&gt;
&lt;li&gt;调频FM：载波的频率随基带数字信号而变化。&lt;/li&gt;
&lt;li&gt;调相PM：载波的初始相位随基带数字信号而变化。&lt;/li&gt;
&lt;li&gt;正交振幅调制QAM：多元制的振幅相位混合调制方法，信息传输速率更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调制解调原因&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;无线电通信系统：通过空间辐射方式传送信号。&lt;br&gt;
电磁波理论可知：天线尺寸为被辐射信号波长的十分之一或更大些，信号才能有效的被辐射。&lt;br&gt;
对于语音信号：天线尺寸需要在几十公里以上，因此需要调制(语音信号的频率范围为300~3400Hz)。&lt;br&gt;
调制过程：将信号频谱搬移到任何所需的较高频率范围，这就容易以电磁波形式辐射出去。&lt;br&gt;
如果不进行调制，而是把被传送的信号直接辐射出去，那么各电台所发出的信号频率就会相同，他们混在一起，收信者将无法选择所要接收的信号。&lt;br&gt;
调制作用的实质：把各种信号的频谱搬移，使它们互不重叠地占据不同的频率范围，即信号分别托付于不同频率的载波上，接收机可以分离出所需要的频率的信号，不致相互干扰。（实现了多路复用）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;信道极限容量&#34;&gt;信道极限容量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;码元传输的速率越高，或者信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形失真就越严重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限制码元在信道上的传输速率的因素有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;信道能够通过的频率范围&lt;br&gt;
奈氏准则：在任何信道中，码元传输的速率是由上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决成为不可能。&lt;/li&gt;
&lt;li&gt;信噪比：信号的平均功率和噪声的平均功率之比(S/N)单位dB&lt;br&gt;
信噪比(dB)=10log10(S/N)(dB)&lt;br&gt;
信道的极限信息传输速率C=Wlog2(1+S/N) (b/s)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出：&lt;strong&gt;信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提高信息的传输速率：尽可能的让每一个码元携带更多信息量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-物理层下的传输媒体&#34;&gt;3. 物理层下的传输媒体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;导向传输媒体：固体媒体(铜线或光纤)。双绞线、同轴电缆、光纤。&lt;/li&gt;
&lt;li&gt;非导向传输媒体：指利用无线电波在自由空间传播。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-信道复用技术&#34;&gt;4. 信道复用技术&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;频分-时分-统计时分复用&#34;&gt;频分、时分、统计时分复用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;频分复用&lt;/strong&gt;FDM：所有用户在同样的时间占用不同的带宽资源。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0FCDA.png&#34; alt=&#34;t0FCDA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时分复用&lt;/strong&gt;TDM：所有用户在不同的时间占用同样的频带宽度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0Fegg.png&#34; alt=&#34;t0Fegg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;TDM有时会造成信道利用率不高：&lt;/p&gt;
  &lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0eoin.png&#34; alt=&#34;t0eoin.png&#34; border=&#34;0&#34; /&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计时分复用&lt;/strong&gt;STDM：TDM的改进，提高信道利用率。&lt;/p&gt;
  &lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0e2M8.png&#34; alt=&#34;t0e2M8.png&#34; border=&#34;0&#34; /&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;波分复用&#34;&gt;波分复用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;波分复用&lt;/strong&gt;WDM：即光的频分复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
  &lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0FUKJ.png&#34; alt=&#34;t0FUKJ.png&#34; border=&#34;0&#34; /&gt;&lt;/div&gt;
&lt;p&gt;经过复用器合波后，速率达到8 x 2.5Gbit/s = 20Gbit/s。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;码分复用&#34;&gt;码分复用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;码分复用&lt;/strong&gt;CDM：即&lt;strong&gt;码分多址CDMA&lt;/strong&gt;，每一个用户可以在同样的时间使用同样的频带进行通信。&lt;/p&gt;
&lt;p&gt;为每个用户分配 m bit 的码片，并且所有的码片&lt;strong&gt;正交&lt;/strong&gt;，对于任意两个码片 &lt;em&gt;S&lt;/em&gt; (S站的码片向量) 和 &lt;em&gt;T&lt;/em&gt; (T站的码片向量) 有&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0k1Ld.png&#34; alt=&#34;t0k1Ld.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;为了方便，取 m=8，设码片 &lt;em&gt;S&lt;/em&gt; 为 00011011。在拥有该码片的用户&lt;strong&gt;发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码&lt;/strong&gt; 11100100。&lt;/p&gt;
&lt;p&gt;在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0kUW8.png&#34; alt=&#34;t0kUW8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/t0k0yQ.png&#34; alt=&#34;t0k0yQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中 &lt;em&gt;S&lt;/em&gt;&#39; 为 &lt;em&gt;S&lt;/em&gt; 的反码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任何一个码片向量和该码片向量自己的规格化内积都是1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用上面的式子我们知道，当接收端使用码片 &lt;em&gt;S&lt;/em&gt; 对接收到的数据进行内积运算时，&lt;strong&gt;结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码分复用需要发送的数据量为原先的 m 倍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-宽带接入技术&#34;&gt;5. 宽带接入技术&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;xdsl技术用数字技术对现有的模拟电话用户线进行改造使它能够承载宽带业务&#34;&gt;xDSL技术：用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。&lt;/h4&gt;
&lt;p&gt;其中，0-4kHz低端频谱留给传统电话使用，高端频谱留给用户上网使用。几种类型:ADSL/HDSL/SDSL/VDSL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ADSL技术：非对称数字用户线。ADSL把上行和下行带宽做成不对称的。上行指从用户到ISP,下行指从ISP到用户。用户线两端是调制解调器(DMT).&lt;br&gt;
DMT调制技术采用频分复用。40kHz-1.1MHz的高端频谱划分许多子信道，25个用于上行，249个用于下行。每个信道占据4kHz带宽。ADSL不能保证固定的数据率。&lt;/li&gt;
&lt;li&gt;基于ADSL的接入网组成：
&lt;ul&gt;
&lt;li&gt;数字用户线接入复用器DSLAM（包含许多ADSL调制解调器，记为ATU-C和ATU-R）&lt;/li&gt;
&lt;li&gt;用户线&lt;/li&gt;
&lt;li&gt;用户家的设施&lt;/li&gt;
&lt;li&gt;总结：ADSL是借助于在用户线两端安装ADSL调制解调器(即ATU-R和ATU-C)对数字信号进行调制，使得调制后的数字信号的频谱适合在原来的用线上传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;光纤同轴混合网(HFC网)&lt;br&gt;
HFC网是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民带宽接入网。
&lt;ul&gt;
&lt;li&gt;功能：传送CATV、电话业务、数据和其他宽带交互型业务。&lt;/li&gt;
&lt;li&gt;特点：
&lt;ol&gt;
&lt;li&gt;HFC网的主干线路采用光纤&lt;/li&gt;
&lt;li&gt;HFC网采用结点体系结构：从头端到各个光纤结点用模拟光纤连接，构成星型网。&lt;/li&gt;
&lt;li&gt;HFC网具有比CATV网更宽的频谱，且具有双向传输功能&lt;/li&gt;
&lt;li&gt;每个家庭要安装一个用户接口盒，其提供三种连接：使用同轴电缆连接到机顶盒再连接到用户的电视机；使用双绞线连接到用户的电话机；使用电缆调制解调器连接到用户的计算机。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;fttx技术光纤到&#34;&gt;FTTx技术（光纤到…）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;光纤到户FTTH：即将光纤一直铺设到用户家庭。&lt;/li&gt;
&lt;li&gt;光纤到大楼FTTB：支持大中型企业、大公司高速率宽带业务需求，比FTTH经济。&lt;/li&gt;
&lt;li&gt;光纤到路边FTTC：比较流行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">计算机网络学习笔记（二）--  物理层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-yi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-er/&#34;&gt;计算机网络学习笔记（二）--  物理层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-san-shu-ju-lian-lu-ceng/&#34;&gt;计算机网络学习笔记（三）--  数据链路层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-si-wang-luo-ceng/&#34;&gt;计算机网络学习笔记（四）--  网络层&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://keasar.com.cn/post/ji-suan-ji-wang-luo-xue-xi-bi-ji-wu-yun-shu-ceng/&#34;&gt;计算机网络学习笔记（五）--  运输层&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-互联网概述&#34;&gt;1. 互联网概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;计算机网络由若干&lt;strong&gt;结点&lt;/strong&gt;和连接这些结点的&lt;strong&gt;链路&lt;/strong&gt;组成。计算机、集线器、交换机、路由器都可以是结点。&lt;/li&gt;
&lt;li&gt;网络与网络之间通过&lt;strong&gt;路由器&lt;/strong&gt;连接成互联网。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tw57ge.png&#34; alt=&#34;tw57ge.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-isp&#34;&gt;2. ISP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;互联网服务提供商 &lt;strong&gt;ISP&lt;/strong&gt; 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。&lt;/li&gt;
&lt;li&gt;目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。&lt;/li&gt;
&lt;li&gt;互联网交换点 &lt;strong&gt;IXP&lt;/strong&gt; 允许两个 ISP 直接相连而不用经过第三个 ISP。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tw5qud.png&#34; alt=&#34;tw5qud.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-互联网的组成&#34;&gt;3. 互联网的组成&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;两大块&#34;&gt;两大块&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;边缘部分：所有连接在互联网上的&lt;strong&gt;主机&lt;/strong&gt;（又被称为端系统），用户可以直接使用。用来进行通信和资源共享等。&lt;/li&gt;
&lt;li&gt;核心部分：由大量的网络和连接这些网络的&lt;strong&gt;路由器&lt;/strong&gt;组成，用来为边缘部分的主机提供服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twIkbn.png&#34; alt=&#34;twIkbn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;主机间的通信方式&#34;&gt;主机间的通信方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;客户-服务器方式（C/S）：客户即是服务请求方，服务器是服务提供方。&lt;/li&gt;
&lt;li&gt;对等连接方式（P2P）：不区分客户和服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;互联网核心部分&#34;&gt;互联网核心部分&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;路由器在核心部分起到特殊作用，任务是转发收到的分组，完成分组交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;电路交换&#34;&gt;电路交换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;交换过程必须经过建立连接（占用信道资源）--  通话（一直占用信道资源）--  释放连接（归还通信资源）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在整个通信过程中通话的两个用户始终占用端到端的通信资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;报文交换&#34;&gt;报文交换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;分组交换&#34;&gt;分组交换&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;分组交换使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了&lt;strong&gt;目的地址&lt;/strong&gt;和&lt;strong&gt;源地址&lt;/strong&gt;等控制信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twIn8U.png&#34; alt=&#34;twIn8U.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-时延&#34;&gt;4. 时延&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;发送时延&#34;&gt;发送时延&lt;/h4&gt;
&lt;p&gt;主机或路由器发送数据帧所需要的时间。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twomdI.png&#34; alt=&#34;twomdI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中 l 表示数据帧的长度，v 表示发送速率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;传播时延&#34;&gt;传播时延&lt;/h4&gt;
&lt;p&gt;电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twTkt0.png&#34; alt=&#34;twTkt0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;处理时延&#34;&gt;处理时延&lt;/h4&gt;
&lt;p&gt;主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据部分等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;排队时延&#34;&gt;排队时延&lt;/h4&gt;
&lt;p&gt;分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twT6gS.png&#34; alt=&#34;twT6gS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;时延带宽积&#34;&gt;时延带宽积&lt;/h4&gt;
&lt;p&gt;时延带宽积 = 传播时延 x 带宽&lt;/p&gt;
&lt;p&gt;链路的时延带宽积被称为以比特为单位的链路长度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-计算机网络体系结构&#34;&gt;5. 计算机网络体系结构&lt;/h3&gt;
&lt;p&gt;​															&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/tw7hse.png&#34; alt=&#34;tw7hse.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。&lt;strong&gt;数据单位为报文&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运输层&lt;/strong&gt;：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 &lt;strong&gt;TCP，提供面向连接、可靠的数据传输服务&lt;/strong&gt;，&lt;strong&gt;数据单位为报文段&lt;/strong&gt;；用户数据报协议 &lt;strong&gt;UDP，提供无连接、尽最大努力的数据传输服务&lt;/strong&gt;，&lt;strong&gt;数据单位为用户数据报&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层产生的报文段或者用户数据报封装成**分组(IP数据报)**来进行传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组&lt;strong&gt;封装成帧&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;：考虑的是怎样在传输媒体上传输数据&lt;strong&gt;比特流&lt;/strong&gt;，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twbV9P.png&#34; alt=&#34;twbV9P.png&#34; border=&#34;0&#34; /&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP/IP体系结构&lt;/p&gt;
&lt;p&gt;现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twXlrT.png&#34; alt=&#34;twXlrT.png&#34; border=&#34;0&#34; /&gt;&lt;/div&gt;
&lt;p&gt;TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。&lt;/p&gt;
  &lt;div align=&#34;center&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/06/04/twqzee.png&#34; alt=&#34;twqzee.png&#34; border=&#34;0&#34; /&gt;&lt;/div&gt;
">计算机网络学习笔记（一）--  计算机网络概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/centos76-an-zhuang-docker-bing-zai-docker-zhong-li-yong-tomcat-bu-shu-jing-tai-wang-ye/"" data-c="
          &lt;h3 id=&#34;centos76安装docker并在docker中利用tomcat部署静态网页&#34;&gt;CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页&lt;/h3&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;1-安装docker&#34;&gt;1. 安装Docker&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更新yum包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum update
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看是否安装过docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;whereis docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果安装过，则删除之前的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum remove docker docker-common docker-selinux docker-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置yum源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看docker版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum list docker-ce --showduplicates | sort -r
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install docker-ce 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动Docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开机启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证安装是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker version
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如下存在Client和Server则成功&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;X:%5Cclassworks%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5Cdockerversion.png&#34; alt=&#34;dockerversion&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Docker常用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker 运行容器命令
docker ps
 
docker 所有容器命令
docker ps -a
 
docker 删除容器命令
docker rm 容器id
 
docker 镜像查看命令
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.利用Tomcat部署静态网页&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拉取Tomcat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull tomcat
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动容器，验证Tomcat服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -p 8080:8080 tomcat
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问&lt;/p&gt;
&lt;p&gt;服务器外网IP:8080即可&lt;/p&gt;
&lt;p&gt;如果不行，看是否能ping通或者是服务器端口是否开放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将静态页面拷贝到docker中tomcat的webapps下，建议挂载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将Tomcat启动，进入docker中查看命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it 容器id /bin/bash //容器ID可通过 docker ps命令查询
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挂载静态文件&lt;/p&gt;
&lt;p&gt;首先将静态资源文件夹上传至云服务器，例如我的上传至了/root下，即SongMove文件夹。下面这条命令即是将静态资源目录映射到容器的/ROOT下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d -v /root/SongMove/:/usr/local/tomcat/webapps/ROOT/ -p 8080:8080 tomcat:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.服务器IP:8080访问即可&lt;/p&gt;
">CentOS7.6安装Docker并在Docker中利用Tomcat部署静态网页</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/han-shu-shang/"" data-c="
          &lt;h2 id=&#34;函数的概念&#34;&gt;函数的概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 js 来说，函数就是把任意一段代码放在一个 &lt;strong&gt;盒子&lt;/strong&gt; 里面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在我想要让这段代码执行的时候，直接执行这个 &lt;strong&gt;盒子&lt;/strong&gt; 里面的代码就行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先看一段代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这个是我们以前写的一段代码
for (var i = 0; i &amp;lt; 10; i++) {
  console.log(i)
}

// 函数，这个 {} 就是那个 “盒子”
function fn() {
  // 这个函数我们以前写的代码
  for (var i = 0; i &amp;lt; 10; i++) {
    console.log(i)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数的两个阶段重点&#34;&gt;函数的两个阶段（重点）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按照我们刚才的说法，两个阶段就是 &lt;strong&gt;放在盒子里面&lt;/strong&gt; 和 &lt;strong&gt;让盒子里面的代码执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;函数定义阶段&#34;&gt;函数定义阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义阶段就是我们把代码 &lt;strong&gt;放在盒子里面&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们就要学习怎么 &lt;strong&gt;放进去&lt;/strong&gt;，也就是书写一个函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们有两种定义方式 &lt;strong&gt;声明式&lt;/strong&gt; 和 &lt;strong&gt;赋值式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;声明式&#34;&gt;声明式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;function&lt;/code&gt; 这个关键字来声明一个函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn() {
  // 一段代码
}
// function: 声明函数的关键字，表示接下来是一个函数了
// fn: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）
// (): 必须写，是用来放参数的位置（一会我们再聊）
// {}: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;赋值式&#34;&gt;赋值式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其实就是和我们使用 &lt;code&gt;var&lt;/code&gt; 关键字是一个道理了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先使用 &lt;code&gt;var&lt;/code&gt; 定义一个变量，把一个函数当作值直接赋值给这个变量就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var fn = function () {
  // 一段代码
}
// 不需要在 function 后面书写函数的名字了，因为在前面已经有了
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;函数调用阶段&#34;&gt;函数调用阶段&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;就是让 &lt;strong&gt;盒子里面&lt;/strong&gt; 的代码执行一下&lt;/li&gt;
&lt;li&gt;让函数执行&lt;/li&gt;
&lt;li&gt;两种定义函数的方式不同，但是调用函数的方式都以一样的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调用一个函数&#34;&gt;调用一个函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数调用就是直接写 &lt;code&gt;函数名()&lt;/code&gt; 就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 声明式函数
function fn() {
  console.log(&#39;我是 fn 函数&#39;)
}

// 调用函数
fn()

// 赋值式函数
var fn2 = function () {
  console.log(&#39;我是 fn2 函数&#39;)
}

// 调用函数
fn()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;注意： &lt;strong&gt;定义完一个函数以后，如果没有函数调用，那么写在 {} 里面的代码没有意义，只有调用以后才会执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调用上的区别&#34;&gt;调用上的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虽然两种定义方式的调用都是一样的，但是还是有一些区别的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明式函数： 调用可以在 &lt;strong&gt;定义之前或者定义之后&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 可以调用
fn()

// 声明式函数
function fn() {
  console.log(&#39;我是 fn 函数&#39;)
}

// 可以调用
fn()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋值式函数： 调用只能在 &lt;strong&gt;定义之前&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 会报错
fn()

// 赋值式函数
var fn = function () {
  console.log(&#39;我是 fn 函数&#39;)
}

// 可以调用
fn()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数的参数重点&#34;&gt;函数的参数（重点）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们在定义函数和调用函数的时候都出现过 &lt;code&gt;()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在我们就来说一下这个 &lt;code&gt;()&lt;/code&gt; 的作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就是用来放参数的位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数分为两种 &lt;strong&gt;行参&lt;/strong&gt; 和 &lt;strong&gt;实参&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 声明式
function fn(行参写在这里) {
  // 一段代码
}

fn(实参写在这里)

// 赋值式函数
var fn = function (行参写在这里) {
  // 一段代码
}
fn(实参写在这里)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;行参和实参的作用&#34;&gt;行参和实参的作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;行参&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;就是在函数内部可以使用的变量，在函数外部不能使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每写一个单词，就相当于在函数内部定义了一个可以使用的变量（遵循变量名的命名规则和命名规范）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个单词之间以 &lt;code&gt;,&lt;/code&gt; 分隔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 书写一个参数
function fn(num) {
  // 在函数内部就可以使用 num 这个变量
}

var fn1 = function (num) {
	// 在函数内部就可以使用 num 这个变量
}

// 书写两个参数
function fun(num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}

var fun1 = function (num1, num2) {
  // 在函数内部就可以使用 num1 和 num2 这两个变量
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果只有行参的话，那么在函数内部使用的值个变量是没有值的，也就是 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行参的值是在函数调用的时候由实参决定的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实参&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在函数调用的时候给行参赋值的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也就是说，在调用的时候是给一个实际的内容的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn(num) {
  // 函数内部可以使用 num 
}

// 这个函数的本次调用，书写的实参是 100
// 那么本次调用的时候函数内部的 num 就是 100
fn(100) 

// 这个函数的本次调用，书写的实参是 200
// 那么本次调用的时候函数内部的 num 就是 200
fn(200)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数内部的行参的值，由函数调用的时候传递的实参决定&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多个参数的时候，是按照顺序一一对应的&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 函数本次调用的时候，书写的参数是 100 和 200
// 那么本次调用的时候，函数内部的 num1 就是 100，num2 就是 200
fn(100, 200)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参数个数的关系&#34;&gt;参数个数的关系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;行参比实参少&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为是按照顺序一一对应的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行参少就会拿不到实参给的值，所以在函数内部就没有办法用到这个值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn(num1, num2) {
  // 函数内部可以使用 num1 和 num2
}

// 本次调用的时候，传递了两个实参，100 200 和 300
// 100 对应了 num1，200 对应了 num2，300 没有对应的变量
// 所以在函数内部就没有办法依靠变量来使用 300 这个值
fn(100, 200, 300)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行参比实参多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为是按照顺序一一对应的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以多出来的行参就是没有值的，就是 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn(num1, num2, num3) {
  // 函数内部可以使用 num1 num2 和 num3
}

// 本次调用的时候，传递了两个实参，100 和 200
// 就分别对应了 num1 和 num2
// 而 num3 没有实参和其对应，那么 num3 的值就是 undefined
fn(100, 200)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;函数的return重点&#34;&gt;函数的return（重点）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;return 返回的意思，其实就是给函数一个 &lt;strong&gt;返回值&lt;/strong&gt; 和 &lt;strong&gt;终断函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;终断函数&#34;&gt;终断函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当我开始执行函数以后，函数内部的代码就会从上到下的依次执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须要等到函数内的代码执行完毕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而 &lt;code&gt;return&lt;/code&gt; 关键字就是可以在函数中间的位置停掉，让后面的代码不在继续执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn() {
  console.log(1)
  console.log(2)
  console.log(3)
  
  // 写了 return 以后，后面的 4 和 5 就不会继续执行了
  return
  console.log(4)
  console.log(5)
}

// 函数调用
fn()
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;返回值&#34;&gt;返回值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数调用本身也是一个表达式，表达式就应该有一个值出现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在的函数执行完毕之后，是不会有结果出现的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 比如 1 + 2 是一个表达式，那么 这个表达式的结果就是 3
console.log(1 + 2) // 3

function fn() {
  // 执行代码
}

// fn() 也是一个表达式，这个表达式就没有结果出现
console.log(fn()) // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt; 关键字就是可以给函数执行完毕一个结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn() {
  // 执行代码
  return 100
}

// 此时，fn() 这个表达式执行完毕之后就有结果出现了
console.log(fn()) // 100
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;我们可以在函数内部使用 &lt;code&gt;return&lt;/code&gt; 关键把任何内容当作这个函数运行后的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;函数的优点&#34;&gt;函数的优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数就是对一段代码的封装，在我们想调用的时候调用&lt;/li&gt;
&lt;li&gt;函数的几个优点
&lt;ol&gt;
&lt;li&gt;封装代码，使代码更加简洁&lt;/li&gt;
&lt;li&gt;复用，在重复功能的时候直接调用就好&lt;/li&gt;
&lt;li&gt;代码执行时机，随时可以在我们想要执行的时候执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;预解析重点&#34;&gt;预解析（重点）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;预解析&lt;/strong&gt; 其实就是聊聊 js 代码的编译和执行&lt;/li&gt;
&lt;li&gt;js 是一个解释型语言，就是在代码执行之前，先对代码进行通读和解释，然后在执行代码&lt;/li&gt;
&lt;li&gt;也就是说，我们的 js 代码在运行的时候，会经历两个环节 &lt;strong&gt;解释代码&lt;/strong&gt; 和 &lt;strong&gt;执行代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解释代码&#34;&gt;解释代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;因为是在所有代码执行之前进行解释，所以叫做 &lt;strong&gt;预解析（预解释）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要解释的内容有两个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明式函数
&lt;ul&gt;
&lt;li&gt;在内存中先声明有一个变量名是函数名，并且这个名字代表的内容是一个函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt; 关键字
&lt;ul&gt;
&lt;li&gt;在内存中先声明有一个变量名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看下面一段代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fn()
console.log(num)

function fn() {
  console.log(&#39;我是 fn 函数&#39;)
}

var num = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;经过预解析之后可以变形为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function fn() {
  console.log(&#39;我是 fn 函数&#39;)
}
var num

fn()
console.log(num)
num = 100
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋值是函数会按照 &lt;code&gt;var&lt;/code&gt; 关键字的规则进行预解析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">函数（上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://keasar.com.cn/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/peace.js"></script>




  <div class="snow-container"></div>
  <script src="/media/js/bg/snow.js"></script>


</html>